{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to dropwizard-guicey\n\u00b6\n\n\nGuice\n integration for \ndropwizard\n.\n\n\nMain features\n\u00b6\n\n\n\n\nAuto configuration\n: use classpath scan to find and install extensions \nautomatically without manual configurations (of course, \nmanual mode\n is also possible)  \n\n\nWeb\n (servlets, filters):\n\n\nsupports both contexts (main and admin)\n\n\nguice ServletModule support is enabled by default (\ncould be disabled\n)\n\n\njee web annotations (@WebServlet, @WebFilter) support (\ncould be enabled\n)\n\n\n\n\n\n\nDropwizard style \nreporting\n: detected (and installed) extensions are printed to console to remove uncertainty\n\n\nAdmin context \nrest emulation\n\n\nTest support\n: custom junit and \nspock\n extensions\n\n\nDeveloper friendly: \n\n\ncore integrations may be replaced (to better fit needs)\n\n\nrich api for developing \ncustom integrations\n\n\nout of the box support for plug-n-play plugins (\nauto discoverable\n)\n\n\nself diagnostic tools (configuration process \ndiagnostic reporting\n) \n\n\n\n\n\n\n\n\nHow to use docs\n\u00b6\n\n\n\n\nGetting started\n section covers installation and main concepts. Ideal for introduction.\n\n\nUser guide\n section contain detailed features descriptions. Good to read, but if no time, read as you need it.\n\n\nInstallers\n section describes all guicey installers. Use it as a \nhand book\n for extensions declaration.\n\n\nExamples\n section contains common example cases.\n\n\nExtras\n section covers extra modules: admin rest, 3\nrd\n party integrations (event bus, jdbi) provided by guicey itself \nor extensions project.\n\n\n\n\nSources structure\n\u00b6\n\n\nThe main repository\n contains library itself and this documentation sources.\n\n\nGuicey stays as feature complete library with commonly used core integrations and \nrich api for building custom integrations (for specific needs). \nIt's very close to guice philosophy of being simple and stable.\n\n\nExamples repository\n holds examples of main features usage, dropwizard bundles \nintegrations and extensions samples.\n\n\nExtensions repository\n contains guicey external integrations. \n\n\nExtensions project shows what is possible to achieve based on guicey. Besides, provided integrations \nitself might be quite useful.\n\n\nBOM module\n unifies dependencies management for extensions, dropwizard and guice (as it includes boms for them).\nOverall, extensions project is more like spring: growing set of solutions for everything (more \"enterprisy\").",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-dropwizard-guicey",
            "text": "Guice  integration for  dropwizard .",
            "title": "Welcome to dropwizard-guicey"
        },
        {
            "location": "/#main-features",
            "text": "Auto configuration : use classpath scan to find and install extensions \nautomatically without manual configurations (of course,  manual mode  is also possible)    Web  (servlets, filters):  supports both contexts (main and admin)  guice ServletModule support is enabled by default ( could be disabled )  jee web annotations (@WebServlet, @WebFilter) support ( could be enabled )    Dropwizard style  reporting : detected (and installed) extensions are printed to console to remove uncertainty  Admin context  rest emulation  Test support : custom junit and  spock  extensions  Developer friendly:   core integrations may be replaced (to better fit needs)  rich api for developing  custom integrations  out of the box support for plug-n-play plugins ( auto discoverable )  self diagnostic tools (configuration process  diagnostic reporting )",
            "title": "Main features"
        },
        {
            "location": "/#how-to-use-docs",
            "text": "Getting started  section covers installation and main concepts. Ideal for introduction.  User guide  section contain detailed features descriptions. Good to read, but if no time, read as you need it.  Installers  section describes all guicey installers. Use it as a  hand book  for extensions declaration.  Examples  section contains common example cases.  Extras  section covers extra modules: admin rest, 3 rd  party integrations (event bus, jdbi) provided by guicey itself \nor extensions project.",
            "title": "How to use docs"
        },
        {
            "location": "/#sources-structure",
            "text": "The main repository  contains library itself and this documentation sources.  Guicey stays as feature complete library with commonly used core integrations and \nrich api for building custom integrations (for specific needs). \nIt's very close to guice philosophy of being simple and stable.  Examples repository  holds examples of main features usage, dropwizard bundles \nintegrations and extensions samples.  Extensions repository  contains guicey external integrations.   Extensions project shows what is possible to achieve based on guicey. Besides, provided integrations \nitself might be quite useful.  BOM module  unifies dependencies management for extensions, dropwizard and guice (as it includes boms for them).\nOverall, extensions project is more like spring: growing set of solutions for everything (more \"enterprisy\").",
            "title": "Sources structure"
        },
        {
            "location": "/getting-started/",
            "text": "Getting started\n\u00b6\n\n\n\n\nNote\n\n\nGetting started guide briefly covers the most important concepts and commonly used features.\nAdvanced description of mentioned topics may be found in user guide.    \n\n\n\n\nInstallation\n\u00b6\n\n\nAvailable from maven central and \nbintray jcenter\n.\n\n\nMaven:\n\n\n<dependency>\n\n  \n<groupId>\nru.vyarus\n</groupId>\n\n  \n<artifactId>\ndropwizard-guicey\n</artifactId>\n\n  \n<version>\n4.0.1\n</version>\n\n\n</dependency>\n\n\n\n\n\n\nGradle:\n\n\ncompile\n \n'ru.vyarus:dropwizard-guicey:4.0.1'\n\n\n\n\n\n\n\n\nYou can also use \nextensions project BOM\n.\n\n\n\n\nUsage\n\u00b6\n\n\n\n\nFull source of example application is \npublished here\n\n\n\n\nRegister guice bundle:\n\n\npublic\n \nclass\n \nSampleApplication\n \nextends\n \nApplication\n<\nConfiguration\n>\n \n{\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \nthrows\n \nException\n \n{\n\n            \nnew\n \nSampleApplication\n().\nrun\n(\nargs\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nBootstrap\n<\nConfiguration\n>\n \nbootstrap\n)\n \n{\n\n        \nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n.\nenableAutoConfig\n(\ngetClass\n().\ngetPackage\n().\ngetName\n())\n\n                \n.\nbuild\n());\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nConfiguration\n \nconfiguration\n,\n \nEnvironment\n \nenvironment\n)\n \nthrows\n \nException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nTip\n\n\nBundle builder contains shortcuts for all available features, so required function \nmay be found only by looking at available methods (and reading javadoc).\n\n\n\n\nAuto configuration (activated with \nenanleAutoConfig\n) means that guicey will search for extensions in application package and subpackages.\n\n\n\n\nTip\n\n\nYou can declare multiple packages for classpath scan: \n\n \n.\nenanleAutoConfig\n(\n\"com.mycompany.foo\"\n,\n \n\"com.mycompany.bar\"\n)\n\n\n\n\n\n\n\n\nApplication could be launched by simply running main class (assume you will use IDE run command):\n\n\nSampleApplication server\n\n\n\n\n\n\n\nNote\n\n\nconfig.yml is not passed as parameter because we don't need additional configuration now\n\n\n\n\nAdd resource\n\u00b6\n\n\nCreating custom rest resource:\n\n\n@Path\n(\n\"/sample\"\n)\n\n\n@Produces\n(\n\"application/json\"\n)\n\n\npublic\n \nclass\n \nSampleResource\n \n{\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/\"\n)\n\n    \npublic\n \nResponse\n \nask\n()\n \n{\n\n        \nreturn\n \nResponse\n.\nok\n(\n\"ok\"\n).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow, when you run application, you can see that resource was installed automatically:\n\n\nINFO  [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources:\n\n    GET     /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource)\n\n\n\n\n\nCall \nhttp://localhost:8080/sample/\n to make sure it works.\n\n\n\n\nTip\n\n\nRest context is mapped to root by default. To change it use configuration file:\n\nserver\n:\n\n    \nrootPath\n:\n \n'/rest/*'\n\n\n\n\n\n\n\n\nResource is a guice bean, so you can use guice injection here. To accessing request specific\nobjects like request, response, jersey \njavax.ws.rs.core.UriInfo\n etc. use \nProvider\n:\n\n\n@Path\n(\n\"/sample\"\n)\n\n\n@Produces\n(\n\"application/json\"\n)\n\n\npublic\n \nclass\n \nSampleResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/\"\n)\n\n    \npublic\n \nResponse\n \nask\n()\n \n{\n\n        \nfinal\n \nString\n \nip\n \n=\n \nrequestProvider\n.\nget\n().\ngetRemoteAddr\n();\n\n        \nreturn\n \nResponse\n.\nok\n(\nip\n).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow resource will return caller IP.\n\n\nAlso you can inject request specific objects with \nas method parameter\n\n\n\n\nNote\n\n\nField injection used in examples for simplicity. In real life projects \nprefer constructor injection\n.    \n\n\n\n\nAdd managed\n\u00b6\n\n\nDropwizard managed objects\n are extremely useful for managing resources.\n\n\nCreate simple managed implementation:\n\n\n@Singleton\n\n\npublic\n \nclass\n \nSampleBootstrap\n \nimplements\n \nManaged\n \n{\n\n    \nprivate\n \nfinal\n \nLogger\n \nlogger\n \n=\n \nLoggerFactory\n.\ngetLogger\n(\nSampleBootstrap\n.\nclass\n);\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n        \nlogger\n.\ninfo\n(\n\"Starting some resource\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstop\n()\n \nthrows\n \nException\n \n{\n\n        \nlogger\n.\ninfo\n(\n\"Shutting down some resource\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIt will be automatically discovered and installed. Guicey always reports installed extensions\n(when they are not reported by dropwizard itself). So you can see in startup logs now:\n\n\nINFO  [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap)\n\n\n\n\n\nAdd filter\n\u00b6\n\n\n\n\nNote\n\n\nGuice \nServletModule\n may be used for servlets and filters definitions, but most of the time it's more convenient\nto use simple servlet annotations (\n@WebFilter\n, \n@WebServlet\n, \n@WebListener\n). \nMoreover, guice servlet module is not able to register async filters and servlets.\n\n\n\n\nTo use \n@WebFilter\n annotation for filter installation web installers must be activated with shortcut method:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n.\nenableAutoConfig\n(\ngetClass\n().\ngetPackage\n().\ngetName\n())\n\n                \n.\nuseWebInstallers\n()\n\n                \n.\nbuild\n());\n\n\n\n\n\n\nAdd sample filter around rest methods:\n\n\n@WebFilter\n(\nurlPatterns\n \n=\n \n\"/*\"\n)\n\n\npublic\n \nclass\n \nCustomHeaderFilter\n \nimplements\n \nFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninit\n(\nFilterConfig\n \nfilterConfig\n)\n \nthrows\n \nServletException\n \n{\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndoFilter\n(\nServletRequest\n \nrequest\n,\n \nServletResponse\n \nresponse\n,\n \nFilterChain\n \nchain\n)\n\n            \nthrows\n \nIOException\n,\n \nServletException\n \n{\n\n        \nif\n \n(\n\"me\"\n.\nequals\n(\nrequest\n.\ngetParameter\n(\n\"user\"\n)))\n \n{\n\n            \nchain\n.\ndoFilter\n(\nrequest\n,\n \nresponse\n);\n\n        \n}\n \nelse\n \n{\n\n            \n((\nHttpServletResponse\n)\n \nresponse\n)\n\n                    \n.\nsendError\n(\nHttpServletResponse\n.\nSC_UNAUTHORIZED\n,\n \n\"Not authorized\"\n);\n\n        \n}\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndestroy\n()\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFilter will pass through only requests with \nuser=me\n request parameter. It is used just to show\nhow to register custom filters with annotations (implementation itself is not useful).\n\n\nNew lines in log will appear confirming filter installation:\n\n\nINFO  [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters =\n\n    /*                       (ru.vyarus.dropwizard.guice.examples.web.AuthFilter)   .auth\n\n\n\n\n\nCall \nhttp://localhost:8080/sample/\n and \nhttp://localhost:8080/sample/?user=me\n to make sure filter works.\n\n\nAdd guice module\n\u00b6\n\n\nIf you need to register guice module in injector:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n...\n\n                \n.\nmodules\n(\nnew\n \nSampleModule\n())\n\n                \n.\nbuild\n());\n\n\n\n\n\n\nMultiple modules could be registered:\n\n.\nmodules\n(\nnew\n \nSampleModule\n(),\n \nnew\n \nSome3rdPatyModule\n())\n\n\n\n\n\n\n\n\nGuice \nServletModule\n could be used for filters and servlets registration.\n\n\n\n\n\n\nIf you have at least one module of your own then it's recommended to move \nall guice modules registration there to encapsulate guice staff:\n\n.\nmodules\n(\nnew\n \nSampleModule\n())\n        \n\n\n\n\npublic\n \nclass\n \nSampleModule\n \nextends\n \nAbstractModule\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \ninstall\n(\nnew\n \nSome3rdPatyModule\n());\n\n\n        \n// some custom bindings there\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nGuicey removes duplicate registrations by type. For example, in case:\n\n.\nmodules\n(\nnew\n \nSampleModule\n(),\n \nnew\n \nSampleModule\n())\n\n\n\n\nOnly one module will be registered. This is intentional restriction to simplify bundles usage.\n\n\n\n\nIn some cases, it could be desired to use different instances of the same module:\n\n.\nmodules\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n),\n \nnew\n \nParametrizableModule\n(\n\"mod2\"\n))\n\n\n\n\nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module:\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n));\n\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod2\"\n));\n\n\n\n\n\n\nAccess dropwizard objects\n\u00b6\n\n\nYou may need dropwizard \nConfiguration\n or \nEnvironment\n inside module.\nFor example, to access configuration or to tune dropwizard environment.\n\n\nIn most cases simply extend \nDropwizardAwareModule\n:\n\n\npublic\n \nclass\n \nSampleModule\n \nextends\n \nDropwizardAwareModule\n<\nConfiguration\n>\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nconfiguration\n()...\n \n// access configuration\n\n        \nenvironment\n()...\n \n// access environment\n\n        \nbootstrap\n()...\n  \n// access dropwizard bootstrap\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\nThere are also \ninterfaces available\n, which may be implemented directly instead of extending class.\nBase class simply reduce boilerplate.\n\n\n\n\nAvailable bindings\n\u00b6\n\n\n\n\nConfiguration as \nio.dropwizard.Configuration\n, your configuration class and \nany class between them\n \n(and, optionally, \ninterfaces implemented by your configuration class\n)\n\n\nio.dropwizard.setup.Environment\n\n\n\n\nThese bindings are not immediately available as HK context \nstarts after guice\n:\n\n\n\n\njavax.ws.rs.core.Application\n\n\njavax.ws.rs.ext.Providers\n\n\norg.glassfish.hk2.api.ServiceLocator\n\n\norg.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider\n\n\n\n\nRequest-scoped bindings:\n\n\n\n\njavax.ws.rs.core.UriInfo\n\n\njavax.ws.rs.core.HttpHeaders\n\n\njavax.ws.rs.core.SecurityContext\n\n\njavax.ws.rs.core.Request\n\n\norg.glassfish.jersey.server.ContainerRequest\n\n\norg.glassfish.jersey.server.internal.process.AsyncContext\n\n\njavax.servlet.http.HttpServletRequest\n\n\njavax.servlet.http.HttpServletResponse\n\n\n\n\n\n\nRequest scoped objects must be used through provider:\n\n@Inject\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;\n\n\n\n\n\n\n\n\nManual mode\n\u00b6\n\n\nIf you don't want to use auto configuration, then you will have to manually specify all extensions.\nExample above would look in manual mode like this:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n.\nuseWebInstallers\n()\n\n                \n.\nmodules\n(\nnew\n \nSampleModule\n())\n\n                \n.\nextensions\n(\n\n                        \nSampleResource\n.\nclass\n,\n\n                        \nSampleBootstrap\n.\nclass\n,\n\n                        \nCustomHeaderFilter\n.\nclass\n\n                \n)\n\n                \n.\nbuild\n());\n\n\n\n\n\n\nAs you can see the actual difference is only the absence of classpath scan, so you have to manually\nspecify all extensions.\n\n\n\n\nTip\n\n\nExplicit extensions declaration could be used in auto configuration mode too: for example,\nclasspath scan could not cover all packages with extensions (e.g. due to too much classes)\nand not covered extensions may be specified manually.    \n\n\n\n\n\n\nWarning\n\n\nDuplicate extensions are filtered. If some extension is registered manually and also found with auto scan\nthen only one extension instance will be registered. \nEven if extension registered multiple times manually,\nonly one extension will work. \n\n\n\n\nInstallers\n\u00b6\n\n\nInstaller is the core concept in guicey: \n\n\n\n\nit detects extension in class (during classpath scan or manual extension specification)\n\n\nit installs extension (in most cases, request instance from guice and install in in dropwizard environment) \n\n\n\n\nMost installer implementations are very simple, so you can easily understand how it works.\n\n\nIf installer does not work as you need (not quite or has a bug), you can always replace it:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n...\n\n                \n.\ndisableInstaller\n(\nManagedInstaller\n.\nclass\n)\n\n                \n.\ninstallers\n(\nMyCustomManagedInstaller\n.\nclass\n)\n       \n                \n.\nbuild\n());\n\n\n\n\n\n\nIn this example, managed objects installer was disabled and custom implementation registered. \nOf course, installer could be simply disabled without replacement.\n\n\n\n\nWarning\n\n\nEach extension could be installed only by one installer. It will be the first installer which recognize\nthe extension in class (according to installers order).\n\n\n\n\n\n\nTip\n\n\nYou can disable all installers enabled by default with:\n\n.\nnoDefaultInstallers\n()\n\n\n\n\nIn this case, you will have to register some installers manually (even if it would be just a few of \nguicey's own installers).\n\n\n\n\nInstallers are perfect extension points: consider writing custom installers for custom integrations \n(for example, to automatically register scheduler jobs using some annotation).\n\n\n\n\nCustom installers are also detected during classpath scan and could be registered automatically\n\n\n\n\nBundles\n\u00b6\n\n\nFrom dropwizard you know that bundles are useful for re-using logic. \n\n\nGuicey has it's own bundles (\nGuiceyBundle\n) for the same reasons. Bundles allow grouping\nguice modules, guicey installers and extensions (and even other bundles transitively).\n\n\n\n\nTip\n\n\nGuicey can check registered dropwizard bundles if they implement \nGuiceyBunlde\n and register them as guicey bundles too.\nIt may be useful if guicey extensions are available in dropwizard bundle as additional (extra extension). \nTo enable it use:\n\n.\nconfigureFromDropwizardBundles\n()\n\n\n\n\n\n\n\n\nGuicey itself comes with multiple bundles: \n\n\n\n\nCore installers bundle\n - installers, enabled by default\n\n\nWeb installers bundle\n - web annotations installers for servlets and filters\n\n\nHk2/guice scope diagnostic bundle\n - enables instantiation tracking to catch extensions instantiation by both (or just not intended) DI\n\n\nDiagnostics bundle\n - configuration diagnostic reporting to look under the hood of configuration process\n\n\n\n\nExtensions project\n contains even more bundles with 3\nrd\n party integrations (guava event bus, jdbi, etc.).\n\n\nBundles loading\n\u00b6\n\n\nOut of the box guicey provides multiple mechanisms for bundles loading.\n\n\nFor example, bundle could be \nloaded automatically\n if it's present in classpath (plug-n-play modules).\nOr bundle could be loaded by \nsystem property\n, which is useful for testing.\n\n\nCustom bundle loading mechanism \ncould be registered\n.\n\n\nOptions\n\u00b6\n\n\nDropwizard configuration covers most configuration cases, except development specific cases.\nFor example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration).\nOther example is an ability of low level tuning for 3\nrd\n party bundles.\n\n\n\n\nOptions\n are developer configurations: either required only for development or triggers set during development \nand not intended to be changed later.\n\n\n\n\nGuicey itself use options for:\n\n\n\n\nInternal configurations (\nGuiceOptions\n enum, mostly configurable through main bundle builder methods): classpath scan packages, \nboolean flags, injector stage. Using options instead of internal bundle state allows any 3\nrd\n party\nbundle/installer/extension to access these values.\n\n\nInstallers options (\nInstallerOptions\n enum): mostly, fail or \"just print error\" behaviour trigger. Default values are permissive,\nbut developer could enforce failure.\n\n\n\n\nConfiguration diagnostic\n\u00b6\n\n\nGuicey always logs installed extensions in console (as shown above), so you can be sure\nif exact extension is installed or not.\n\n\nStill, some configuration aspects could be not obvious (especially when project gets bigger):\n\n\n\n\nWhere did it get this extension from\n\n\nHow long did it take to perform classpath scan\n\n\netc.\n\n\n\n\nDuring startup, guicey records configuration process. After enabling \nprintDiagnosticInfo\n:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n...\n\n                \n.\nprintDiagnosticInfo\n()\n\n                \n.\nbuild\n());\n\n\n\n\n\n\nYou can see additional logs in console like:\n\n\n    GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    ...\n\n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceSupportModule           (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    ...\n\n\n\n\n\nAnd \nother logs\n giving you inside look on configuration.\n\n\n\n\nTip\n\n\nIt may be even used in educational purposes to better understand how guicey work.",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "Note  Getting started guide briefly covers the most important concepts and commonly used features.\nAdvanced description of mentioned topics may be found in user guide.",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#installation",
            "text": "Available from maven central and  bintray jcenter .  Maven:  <dependency> \n   <groupId> ru.vyarus </groupId> \n   <artifactId> dropwizard-guicey </artifactId> \n   <version> 4.0.1 </version>  </dependency>   Gradle:  compile   'ru.vyarus:dropwizard-guicey:4.0.1'    You can also use  extensions project BOM .",
            "title": "Installation"
        },
        {
            "location": "/getting-started/#usage",
            "text": "Full source of example application is  published here   Register guice bundle:  public   class   SampleApplication   extends   Application < Configuration >   { \n\n     public   static   void   main ( String []   args )   throws   Exception   { \n             new   SampleApplication (). run ( args ); \n     } \n\n     @Override \n     public   void   initialize ( Bootstrap < Configuration >   bootstrap )   { \n         bootstrap . addBundle ( GuiceBundle . builder () \n                 . enableAutoConfig ( getClass (). getPackage (). getName ()) \n                 . build ()); \n     } \n\n     @Override \n     public   void   run ( Configuration   configuration ,   Environment   environment )   throws   Exception   { \n     }  }    Tip  Bundle builder contains shortcuts for all available features, so required function \nmay be found only by looking at available methods (and reading javadoc).   Auto configuration (activated with  enanleAutoConfig ) means that guicey will search for extensions in application package and subpackages.   Tip  You can declare multiple packages for classpath scan:    . enanleAutoConfig ( \"com.mycompany.foo\" ,   \"com.mycompany.bar\" )     Application could be launched by simply running main class (assume you will use IDE run command):  SampleApplication server   Note  config.yml is not passed as parameter because we don't need additional configuration now",
            "title": "Usage"
        },
        {
            "location": "/getting-started/#add-resource",
            "text": "Creating custom rest resource:  @Path ( \"/sample\" )  @Produces ( \"application/json\" )  public   class   SampleResource   { \n\n     @GET \n     @Path ( \"/\" ) \n     public   Response   ask ()   { \n         return   Response . ok ( \"ok\" ). build (); \n     }  }   Now, when you run application, you can see that resource was installed automatically:  INFO  [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources:\n\n    GET     /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource)  Call  http://localhost:8080/sample/  to make sure it works.   Tip  Rest context is mapped to root by default. To change it use configuration file: server : \n     rootPath :   '/rest/*'     Resource is a guice bean, so you can use guice injection here. To accessing request specific\nobjects like request, response, jersey  javax.ws.rs.core.UriInfo  etc. use  Provider :  @Path ( \"/sample\" )  @Produces ( \"application/json\" )  public   class   SampleResource   { \n\n     @Inject \n     private   Provider < HttpServletRequest >   requestProvider ; \n\n     @GET \n     @Path ( \"/\" ) \n     public   Response   ask ()   { \n         final   String   ip   =   requestProvider . get (). getRemoteAddr (); \n         return   Response . ok ( ip ). build (); \n     }  }   Now resource will return caller IP.  Also you can inject request specific objects with  as method parameter   Note  Field injection used in examples for simplicity. In real life projects  prefer constructor injection .",
            "title": "Add resource"
        },
        {
            "location": "/getting-started/#add-managed",
            "text": "Dropwizard managed objects  are extremely useful for managing resources.  Create simple managed implementation:  @Singleton  public   class   SampleBootstrap   implements   Managed   { \n     private   final   Logger   logger   =   LoggerFactory . getLogger ( SampleBootstrap . class ); \n\n     @Override \n     public   void   start ()   throws   Exception   { \n         logger . info ( \"Starting some resource\" ); \n     } \n\n     @Override \n     public   void   stop ()   throws   Exception   { \n         logger . info ( \"Shutting down some resource\" ); \n     }  }   It will be automatically discovered and installed. Guicey always reports installed extensions\n(when they are not reported by dropwizard itself). So you can see in startup logs now:  INFO  [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap)",
            "title": "Add managed"
        },
        {
            "location": "/getting-started/#add-filter",
            "text": "Note  Guice  ServletModule  may be used for servlets and filters definitions, but most of the time it's more convenient\nto use simple servlet annotations ( @WebFilter ,  @WebServlet ,  @WebListener ). \nMoreover, guice servlet module is not able to register async filters and servlets.   To use  @WebFilter  annotation for filter installation web installers must be activated with shortcut method:  bootstrap . addBundle ( GuiceBundle . builder () \n                 . enableAutoConfig ( getClass (). getPackage (). getName ()) \n                 . useWebInstallers () \n                 . build ());   Add sample filter around rest methods:  @WebFilter ( urlPatterns   =   \"/*\" )  public   class   CustomHeaderFilter   implements   Filter   { \n\n     @Override \n     public   void   init ( FilterConfig   filterConfig )   throws   ServletException   { \n     } \n\n     @Override \n     public   void   doFilter ( ServletRequest   request ,   ServletResponse   response ,   FilterChain   chain ) \n             throws   IOException ,   ServletException   { \n         if   ( \"me\" . equals ( request . getParameter ( \"user\" )))   { \n             chain . doFilter ( request ,   response ); \n         }   else   { \n             (( HttpServletResponse )   response ) \n                     . sendError ( HttpServletResponse . SC_UNAUTHORIZED ,   \"Not authorized\" ); \n         } \n     } \n\n     @Override \n     public   void   destroy ()   { \n     }  }   Filter will pass through only requests with  user=me  request parameter. It is used just to show\nhow to register custom filters with annotations (implementation itself is not useful).  New lines in log will appear confirming filter installation:  INFO  [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters =\n\n    /*                       (ru.vyarus.dropwizard.guice.examples.web.AuthFilter)   .auth  Call  http://localhost:8080/sample/  and  http://localhost:8080/sample/?user=me  to make sure filter works.",
            "title": "Add filter"
        },
        {
            "location": "/getting-started/#add-guice-module",
            "text": "If you need to register guice module in injector:  bootstrap . addBundle ( GuiceBundle . builder () \n                 ... \n                 . modules ( new   SampleModule ()) \n                 . build ());   Multiple modules could be registered: . modules ( new   SampleModule (),   new   Some3rdPatyModule ())     Guice  ServletModule  could be used for filters and servlets registration.    If you have at least one module of your own then it's recommended to move \nall guice modules registration there to encapsulate guice staff: . modules ( new   SampleModule ())           public   class   SampleModule   extends   AbstractModule   { \n\n     @Override \n     protected   void   configure ()   { \n         install ( new   Some3rdPatyModule ()); \n\n         // some custom bindings there \n     }  }      Warning  Guicey removes duplicate registrations by type. For example, in case: . modules ( new   SampleModule (),   new   SampleModule ())  \n\nOnly one module will be registered. This is intentional restriction to simplify bundles usage.   In some cases, it could be desired to use different instances of the same module: . modules ( new   ParametrizableModule ( \"mod1\" ),   new   ParametrizableModule ( \"mod2\" ))  \n\nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module: install ( new   ParametrizableModule ( \"mod1\" ));  install ( new   ParametrizableModule ( \"mod2\" ));",
            "title": "Add guice module"
        },
        {
            "location": "/getting-started/#access-dropwizard-objects",
            "text": "You may need dropwizard  Configuration  or  Environment  inside module.\nFor example, to access configuration or to tune dropwizard environment.  In most cases simply extend  DropwizardAwareModule :  public   class   SampleModule   extends   DropwizardAwareModule < Configuration >   { \n\n     @Override \n     protected   void   configure ()   { \n         configuration ()...   // access configuration \n         environment ()...   // access environment \n         bootstrap ()...    // access dropwizard bootstrap \n     }  }    Note  There are also  interfaces available , which may be implemented directly instead of extending class.\nBase class simply reduce boilerplate.",
            "title": "Access dropwizard objects"
        },
        {
            "location": "/getting-started/#available-bindings",
            "text": "Configuration as  io.dropwizard.Configuration , your configuration class and  any class between them  \n(and, optionally,  interfaces implemented by your configuration class )  io.dropwizard.setup.Environment   These bindings are not immediately available as HK context  starts after guice :   javax.ws.rs.core.Application  javax.ws.rs.ext.Providers  org.glassfish.hk2.api.ServiceLocator  org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider   Request-scoped bindings:   javax.ws.rs.core.UriInfo  javax.ws.rs.core.HttpHeaders  javax.ws.rs.core.SecurityContext  javax.ws.rs.core.Request  org.glassfish.jersey.server.ContainerRequest  org.glassfish.jersey.server.internal.process.AsyncContext  javax.servlet.http.HttpServletRequest  javax.servlet.http.HttpServletResponse    Request scoped objects must be used through provider: @Inject   Provider < HttpServletRequest >   requestProvider ;",
            "title": "Available bindings"
        },
        {
            "location": "/getting-started/#manual-mode",
            "text": "If you don't want to use auto configuration, then you will have to manually specify all extensions.\nExample above would look in manual mode like this:  bootstrap . addBundle ( GuiceBundle . builder () \n                 . useWebInstallers () \n                 . modules ( new   SampleModule ()) \n                 . extensions ( \n                         SampleResource . class , \n                         SampleBootstrap . class , \n                         CustomHeaderFilter . class \n                 ) \n                 . build ());   As you can see the actual difference is only the absence of classpath scan, so you have to manually\nspecify all extensions.   Tip  Explicit extensions declaration could be used in auto configuration mode too: for example,\nclasspath scan could not cover all packages with extensions (e.g. due to too much classes)\nand not covered extensions may be specified manually.        Warning  Duplicate extensions are filtered. If some extension is registered manually and also found with auto scan\nthen only one extension instance will be registered. \nEven if extension registered multiple times manually,\nonly one extension will work.",
            "title": "Manual mode"
        },
        {
            "location": "/getting-started/#installers",
            "text": "Installer is the core concept in guicey:    it detects extension in class (during classpath scan or manual extension specification)  it installs extension (in most cases, request instance from guice and install in in dropwizard environment)    Most installer implementations are very simple, so you can easily understand how it works.  If installer does not work as you need (not quite or has a bug), you can always replace it:  bootstrap . addBundle ( GuiceBundle . builder () \n                 ... \n                 . disableInstaller ( ManagedInstaller . class ) \n                 . installers ( MyCustomManagedInstaller . class )        \n                 . build ());   In this example, managed objects installer was disabled and custom implementation registered. \nOf course, installer could be simply disabled without replacement.   Warning  Each extension could be installed only by one installer. It will be the first installer which recognize\nthe extension in class (according to installers order).    Tip  You can disable all installers enabled by default with: . noDefaultInstallers ()  \n\nIn this case, you will have to register some installers manually (even if it would be just a few of \nguicey's own installers).   Installers are perfect extension points: consider writing custom installers for custom integrations \n(for example, to automatically register scheduler jobs using some annotation).   Custom installers are also detected during classpath scan and could be registered automatically",
            "title": "Installers"
        },
        {
            "location": "/getting-started/#bundles",
            "text": "From dropwizard you know that bundles are useful for re-using logic.   Guicey has it's own bundles ( GuiceyBundle ) for the same reasons. Bundles allow grouping\nguice modules, guicey installers and extensions (and even other bundles transitively).   Tip  Guicey can check registered dropwizard bundles if they implement  GuiceyBunlde  and register them as guicey bundles too.\nIt may be useful if guicey extensions are available in dropwizard bundle as additional (extra extension). \nTo enable it use: . configureFromDropwizardBundles ()     Guicey itself comes with multiple bundles:    Core installers bundle  - installers, enabled by default  Web installers bundle  - web annotations installers for servlets and filters  Hk2/guice scope diagnostic bundle  - enables instantiation tracking to catch extensions instantiation by both (or just not intended) DI  Diagnostics bundle  - configuration diagnostic reporting to look under the hood of configuration process   Extensions project  contains even more bundles with 3 rd  party integrations (guava event bus, jdbi, etc.).",
            "title": "Bundles"
        },
        {
            "location": "/getting-started/#bundles-loading",
            "text": "Out of the box guicey provides multiple mechanisms for bundles loading.  For example, bundle could be  loaded automatically  if it's present in classpath (plug-n-play modules).\nOr bundle could be loaded by  system property , which is useful for testing.  Custom bundle loading mechanism  could be registered .",
            "title": "Bundles loading"
        },
        {
            "location": "/getting-started/#options",
            "text": "Dropwizard configuration covers most configuration cases, except development specific cases.\nFor example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration).\nOther example is an ability of low level tuning for 3 rd  party bundles.   Options  are developer configurations: either required only for development or triggers set during development \nand not intended to be changed later.   Guicey itself use options for:   Internal configurations ( GuiceOptions  enum, mostly configurable through main bundle builder methods): classpath scan packages, \nboolean flags, injector stage. Using options instead of internal bundle state allows any 3 rd  party\nbundle/installer/extension to access these values.  Installers options ( InstallerOptions  enum): mostly, fail or \"just print error\" behaviour trigger. Default values are permissive,\nbut developer could enforce failure.",
            "title": "Options"
        },
        {
            "location": "/getting-started/#configuration-diagnostic",
            "text": "Guicey always logs installed extensions in console (as shown above), so you can be sure\nif exact extension is installed or not.  Still, some configuration aspects could be not obvious (especially when project gets bigger):   Where did it get this extension from  How long did it take to perform classpath scan  etc.   During startup, guicey records configuration process. After enabling  printDiagnosticInfo :  bootstrap . addBundle ( GuiceBundle . builder () \n                 ... \n                 . printDiagnosticInfo () \n                 . build ());   You can see additional logs in console like:      GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    ...\n\n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceSupportModule           (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    ...  And  other logs  giving you inside look on configuration.   Tip  It may be even used in educational purposes to better understand how guicey work.",
            "title": "Configuration diagnostic"
        },
        {
            "location": "/guide/configuration/",
            "text": "Configuration\n\u00b6\n\n\nBuilder \nGuiceBundle.builder()\n contains shortcuts for all available features, so you can always find required function \nby looking at available methods and reading javadoc.\n\n\n\n\nConfiguration subjects (vocabulary)\n\n\n\n\nInstallers - used to recognize and install extension (usually encapsulates integration logic: get extension instance from guice injector and register in dropwizard (or jersey, hk, whatever))\n\n\nExtensions - actual application parts, written by you (resources, tasks, health checks, servlets etc)\n\n\nGuice modules\n\n\nGuicey bundles - groups installers, extensions, gucie modules and other guicey bundles (represent reusable logic or \n3\nrd\n party integrations; very similar to dropwizard bundles)\n\n\nOptions - general mechanism for low level configurations (development time triggers)\n\n\nCommands - dropwizard commands (mentioned because of ability for automatic registration)\n\n\n\n\n\n\n\n\nWarning\n\n\nConfigured bundles, modules, installers and extensions are checked for duplicates using class type. Duplicate configurations will be simply ignored.\nFor modules and bundles, which configured using instances, duplicates removes means that if two instances of the same type registered, then second instance will\nbe ignored.\n\n\n\n\nConfiguration process is recorded and may be observed with by \ndiagnostic info\n,\nso there is always a way to understand what and how was configured.\n\n\nAuto configuration\n\u00b6\n\n\nAuto configuration enables \nclasspath scan\n to search for extensions and custom installers. \nWithout auto scan, all extensions (resource, managed, health check etc.) must be registered \nmanually\n (manual mode).\n\n\n.\nenableAutoConfig\n(\n\"com.mycompany.app\"\n)\n\n\n\n\n\n\nor multiple packages\n\n\n.\nenableAutoConfig\n(\n\"com.mycompany.app.resources\"\n,\n \n\"com.mycompany.app.staff\"\n)\n\n\n\n\n\n\nCommands search\n\u00b6\n\n\nIn auto configuration mode guicey could also \nsearch and install\n dropwiard commands (register in bootstrap object):\n\n\n.\nsearchCommands\n()\n\n\n\n\n\n\nBy default commands scan is disabled because it may confusing. Besides, it's not often needed.\n\n\nExtensions\n\u00b6\n\n\nAll features installed with guicey installers are called extensions. When auto configuration is enabled, extensions are discovered\nautomatically. Without auto configuratin (manual mode) all extensions must be specified manually.\n\n\n.\nextensions\n(\nMyResource1\n.\nclass\n,\n \nMyHealthCheck\n.\nclass\n)\n\n\n\n\n\n\nAuto configuration may be used together with manual definition (for example, manually registered extension could be unreachable for\nclasspath scan).\n\n\n\n\nEach extension could be installed only by one installer: if multiple installers could recognize extension, \nonly one of them will install it (first one according to priority).\n\n\n\n\nInstallers\n\u00b6\n\n\nGuicey come with pre-defined set of installers (for common extensions). But you can write your own installers\n(or use some 3\nrd\n party ones).\n\n\n\n\nMost installers implementations are very simple and easy to understand. Look installer source to better understand\nhow extensions work. In case when default installer does not fit your needs, it's not hard to replace installer \nwith your custom version.\n\n\n\n\n.\ninstallers\n(\nMyExtensionInstaller\n.\nclass\n,\n \nThirdPartyExtensionInstaller\n.\nclass\n)\n\n\n\n\n\n\n\n\nTip\n\n\nIn auto configuration mode, installers are also detected and installed automatically\n\n\n\n\nDefault installers\n\u00b6\n\n\nGuicey come with a set of pre defined installers, enabled by default (for common extensions installation like resource, health check, task, managed etc.).\nYou can disable them with:\n\n\n.\nnoDefaultInstallers\n()\n\n\n\n\n\n\nWeb installers\n\u00b6\n\n\nGuicey has \nadvanced installers\n for standard servlet annotations (\n@WebServlet\n, \n@WebFilter\n, \n@WebListener\n).\nThey are not enabled by default to avoid confusion: user may not expect guice support for these standard annotations.\n\n\nTo enable web installers:\n\n\n.\nuseWebInstallers\n()\n\n\n\n\n\n\nDisable installer\n\u00b6\n\n\nYou can disable installers (even if it's not registered)\n\n\n.\ndisableInstallers\n(\nManagedInstaller\n.\nclass\n,\n \nResourceInstaller\n.\nclass\n)\n\n\n\n\n\n\nDebug installers\n\u00b6\n\n\nSpecial debug option could \nprint to console all available installers\n (with registration sources):\n\n\n.\nprintAvailableInstallers\n()\n\n\n\n\n\n\nUse to quickly understand available features.\n\n\nGuice modules\n\u00b6\n\n\nYou can register one or more guice modules (including guice \nServletModule\ns):\n\n\n.\nmodules\n(\nnew\n \nMyModule1\n(),\n \nnew\n \nMyModule2\n())\n\n\n\n\n\n\nIf you have many modules try to group their installation inside your custom module in order\nto keep guice staff together.\n\n\nIn some cases, it could be desired to use different instances of the same module:\n\n.\nmodules\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n),\n \nnew\n \nParametrizableModule\n(\n\"mod2\"\n))\n\n\n\n\nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module:\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n));\n\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod2\"\n));\n\n\n\n\n\n\nGuicey bundles\n\u00b6\n\n\nIn essence, \nguicey bundles\n are the same as dropwizard bundles: used to install re-usable logic or \n3\nrd\n party library integration.\n\n\n.\nbundles\n(\nnew\n \nMyBundle\n(),\n \nnew\n \nThirdPartyBundle\n());\n\n\n\n\n\n\nDropwizard bundles unification\n\u00b6\n\n\nGuice bundles must implement interface (\nGuiceyBundle\n). Dropwizard bundle could inmplement it too. \nThis may be useful for \nuniversal bundles\n when all main features are \nactivated by dropwizard bundle and guicey features are optional (if guicey present).\n\n\nWhen:\n\n\n.\nconfigureFromDropwizardBundles\n()\n\n\n\n\n\n\nguicey checks registered dropwizard bundles if they are also \nGuiceyBundle\n and register them as guicey bundles.\n\n\nBundle lookup\n\u00b6\n\n\nBundle lookup\n mechanism provides support for indirect guicey bundles installation.\nDefault lookup mechanism allows using service loader (plug-n-play bundles) or system property (test/diagnostic bundles). \n\n\nCustom implementation could be specified:\n\n\n.\nbundleLookup\n(\nnew\n \nMyBundleLookupImpl\n())\n\n\n\n\n\n\nShortcut to disable default bundle lookup:\n\n\n.\ndisableBundleLookup\n()\n\n\n\n\n\n\nOptions\n\u00b6\n\n\nOptions\n are used for development time configurations (test specific triggers or low level configurations).\nGuicey option enums: \nGuiceyOptions\n and \nInstallersOptions\n\n\n.\noption\n(\nGuiceyOptions\n.\nInjectorStage\n,\n \nStage\n.\nDEVELOPMENT\n)\n\n\n\n\n\n\n\n\nTip\n\n\nOptions look better with static import: \n.\noption\n(\nInjectorStage\n,\n \nDEVELOPMENT\n)\n\n\n\n\nTo provide multiple options at once (batch options load):\n\n\n.\noptions\n(\nnew\n \nMyOptionsLookup\n().\ngetOptions\n())\n\n\n\n\n\n\nGuice\n\u00b6\n\n\nStage\n\u00b6\n\n\nGuice stage cold be provided in:\n\n\n.\nbuild\n(\nStage\n.\nDEVELOPMENT\n)\n\n\n\n\n\n\nBy default, PRODUCTION stage used.\n\n\nInjector\n\u00b6\n\n\nCustom guice injector factory\n may be registered to customize injector creation \n(e.g. required for \ngovernator\n):\n\n\n.\ninjectorFactory\n(\nnew\n \nGovernatorInjectorFactory\n())\n\n\n\n\n\n\nServletModule\n\u00b6\n\n\nBy default, guicey \nregisters\n \nGuiceFilter\n for both main and admin contexts to provide request scopes for both contexts and\nability to use guice \nServletModule\ns on main context.\n\n\nGuiceFilter\n is registered with REQUEST dispatcher type. If you need to use other types:\n\n\n.\noption\n(\nGuiceFilterRegistration\n,\n \nEnumSet\n.\nof\n(\nREQUEST\n,\n \nFORWARD\n))\n\n\n\n\n\n\nIf you \ndon't need servlet module support\n (and request scopes), guice filter installation could be disabled:\n\n\n.\nnoGuiceFilter\n()\n\n\n\n\n\n\nServlet modules will be rejected in this case. Intended to be used when \nweb installers\n enabled.\n\n\n\n\nNote\n\n\nHttpServletRequest\n and \nHttpServletResponse\n objects will be available for injection only in scope of jersey resources call.\n\n\n\n\nConfiguration binding\n\u00b6\n\n\nIt may be useful to bind configuration instance to interface. Suppose some 3\nrd\n party requires your configuration\nto implement interface:\n\n\npublic\n \nclass\n \nMyConfiguraton\n \nextends\n \nConfiguration\n \nimplements\n \nHasRequiredConfig\n \n{...}\n\n\n\n\n\n\nIf binding by interface is enabled:\n\n\n.\nbindConfigurationInterfaces\n()\n\n\n\n\n\n\nThen configuration could be injected by interface:\n\n\n@Inject\n \nHasRequiredConfig\n \nconf\n;\n\n\n\n\n\n\n\n\nNote\n\n\nBy default, configuration is bound only for \nall classes in hierarchy\n. In example above it would be \n\nConfiguration\n and \nMyConfiguration\n.\n\n\n\n\nDiagnostic\n\u00b6\n\n\nEnable configuration \ndiagnostic console logs\n to diagnose configuration problems:\n\n\n.\nprintDiagnosticInfo\n()\n\n\n\n\n\n\nIn case of doubts about extension owner (guice or HK) and suspicious for duplicate instantiation,\nyou can enable \nstrict control\n which will throw exception in case of wrong owner:\n\n\n.\nstrictScopeControl\n()",
            "title": "Configuration"
        },
        {
            "location": "/guide/configuration/#configuration",
            "text": "Builder  GuiceBundle.builder()  contains shortcuts for all available features, so you can always find required function \nby looking at available methods and reading javadoc.   Configuration subjects (vocabulary)   Installers - used to recognize and install extension (usually encapsulates integration logic: get extension instance from guice injector and register in dropwizard (or jersey, hk, whatever))  Extensions - actual application parts, written by you (resources, tasks, health checks, servlets etc)  Guice modules  Guicey bundles - groups installers, extensions, gucie modules and other guicey bundles (represent reusable logic or \n3 rd  party integrations; very similar to dropwizard bundles)  Options - general mechanism for low level configurations (development time triggers)  Commands - dropwizard commands (mentioned because of ability for automatic registration)     Warning  Configured bundles, modules, installers and extensions are checked for duplicates using class type. Duplicate configurations will be simply ignored.\nFor modules and bundles, which configured using instances, duplicates removes means that if two instances of the same type registered, then second instance will\nbe ignored.   Configuration process is recorded and may be observed with by  diagnostic info ,\nso there is always a way to understand what and how was configured.",
            "title": "Configuration"
        },
        {
            "location": "/guide/configuration/#auto-configuration",
            "text": "Auto configuration enables  classpath scan  to search for extensions and custom installers. \nWithout auto scan, all extensions (resource, managed, health check etc.) must be registered  manually  (manual mode).  . enableAutoConfig ( \"com.mycompany.app\" )   or multiple packages  . enableAutoConfig ( \"com.mycompany.app.resources\" ,   \"com.mycompany.app.staff\" )",
            "title": "Auto configuration"
        },
        {
            "location": "/guide/configuration/#commands-search",
            "text": "In auto configuration mode guicey could also  search and install  dropwiard commands (register in bootstrap object):  . searchCommands ()   By default commands scan is disabled because it may confusing. Besides, it's not often needed.",
            "title": "Commands search"
        },
        {
            "location": "/guide/configuration/#extensions",
            "text": "All features installed with guicey installers are called extensions. When auto configuration is enabled, extensions are discovered\nautomatically. Without auto configuratin (manual mode) all extensions must be specified manually.  . extensions ( MyResource1 . class ,   MyHealthCheck . class )   Auto configuration may be used together with manual definition (for example, manually registered extension could be unreachable for\nclasspath scan).   Each extension could be installed only by one installer: if multiple installers could recognize extension, \nonly one of them will install it (first one according to priority).",
            "title": "Extensions"
        },
        {
            "location": "/guide/configuration/#installers",
            "text": "Guicey come with pre-defined set of installers (for common extensions). But you can write your own installers\n(or use some 3 rd  party ones).   Most installers implementations are very simple and easy to understand. Look installer source to better understand\nhow extensions work. In case when default installer does not fit your needs, it's not hard to replace installer \nwith your custom version.   . installers ( MyExtensionInstaller . class ,   ThirdPartyExtensionInstaller . class )    Tip  In auto configuration mode, installers are also detected and installed automatically",
            "title": "Installers"
        },
        {
            "location": "/guide/configuration/#default-installers",
            "text": "Guicey come with a set of pre defined installers, enabled by default (for common extensions installation like resource, health check, task, managed etc.).\nYou can disable them with:  . noDefaultInstallers ()",
            "title": "Default installers"
        },
        {
            "location": "/guide/configuration/#web-installers",
            "text": "Guicey has  advanced installers  for standard servlet annotations ( @WebServlet ,  @WebFilter ,  @WebListener ).\nThey are not enabled by default to avoid confusion: user may not expect guice support for these standard annotations.  To enable web installers:  . useWebInstallers ()",
            "title": "Web installers"
        },
        {
            "location": "/guide/configuration/#disable-installer",
            "text": "You can disable installers (even if it's not registered)  . disableInstallers ( ManagedInstaller . class ,   ResourceInstaller . class )",
            "title": "Disable installer"
        },
        {
            "location": "/guide/configuration/#debug-installers",
            "text": "Special debug option could  print to console all available installers  (with registration sources):  . printAvailableInstallers ()   Use to quickly understand available features.",
            "title": "Debug installers"
        },
        {
            "location": "/guide/configuration/#guice-modules",
            "text": "You can register one or more guice modules (including guice  ServletModule s):  . modules ( new   MyModule1 (),   new   MyModule2 ())   If you have many modules try to group their installation inside your custom module in order\nto keep guice staff together.  In some cases, it could be desired to use different instances of the same module: . modules ( new   ParametrizableModule ( \"mod1\" ),   new   ParametrizableModule ( \"mod2\" ))  \n\nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module: install ( new   ParametrizableModule ( \"mod1\" ));  install ( new   ParametrizableModule ( \"mod2\" ));",
            "title": "Guice modules"
        },
        {
            "location": "/guide/configuration/#guicey-bundles",
            "text": "In essence,  guicey bundles  are the same as dropwizard bundles: used to install re-usable logic or \n3 rd  party library integration.  . bundles ( new   MyBundle (),   new   ThirdPartyBundle ());",
            "title": "Guicey bundles"
        },
        {
            "location": "/guide/configuration/#dropwizard-bundles-unification",
            "text": "Guice bundles must implement interface ( GuiceyBundle ). Dropwizard bundle could inmplement it too. \nThis may be useful for  universal bundles  when all main features are \nactivated by dropwizard bundle and guicey features are optional (if guicey present).  When:  . configureFromDropwizardBundles ()   guicey checks registered dropwizard bundles if they are also  GuiceyBundle  and register them as guicey bundles.",
            "title": "Dropwizard bundles unification"
        },
        {
            "location": "/guide/configuration/#bundle-lookup",
            "text": "Bundle lookup  mechanism provides support for indirect guicey bundles installation.\nDefault lookup mechanism allows using service loader (plug-n-play bundles) or system property (test/diagnostic bundles).   Custom implementation could be specified:  . bundleLookup ( new   MyBundleLookupImpl ())   Shortcut to disable default bundle lookup:  . disableBundleLookup ()",
            "title": "Bundle lookup"
        },
        {
            "location": "/guide/configuration/#options",
            "text": "Options  are used for development time configurations (test specific triggers or low level configurations).\nGuicey option enums:  GuiceyOptions  and  InstallersOptions  . option ( GuiceyOptions . InjectorStage ,   Stage . DEVELOPMENT )    Tip  Options look better with static import:  . option ( InjectorStage ,   DEVELOPMENT )   To provide multiple options at once (batch options load):  . options ( new   MyOptionsLookup (). getOptions ())",
            "title": "Options"
        },
        {
            "location": "/guide/configuration/#guice",
            "text": "",
            "title": "Guice"
        },
        {
            "location": "/guide/configuration/#stage",
            "text": "Guice stage cold be provided in:  . build ( Stage . DEVELOPMENT )   By default, PRODUCTION stage used.",
            "title": "Stage"
        },
        {
            "location": "/guide/configuration/#injector",
            "text": "Custom guice injector factory  may be registered to customize injector creation \n(e.g. required for  governator ):  . injectorFactory ( new   GovernatorInjectorFactory ())",
            "title": "Injector"
        },
        {
            "location": "/guide/configuration/#servletmodule",
            "text": "By default, guicey  registers   GuiceFilter  for both main and admin contexts to provide request scopes for both contexts and\nability to use guice  ServletModule s on main context.  GuiceFilter  is registered with REQUEST dispatcher type. If you need to use other types:  . option ( GuiceFilterRegistration ,   EnumSet . of ( REQUEST ,   FORWARD ))   If you  don't need servlet module support  (and request scopes), guice filter installation could be disabled:  . noGuiceFilter ()   Servlet modules will be rejected in this case. Intended to be used when  web installers  enabled.   Note  HttpServletRequest  and  HttpServletResponse  objects will be available for injection only in scope of jersey resources call.",
            "title": "ServletModule"
        },
        {
            "location": "/guide/configuration/#configuration-binding",
            "text": "It may be useful to bind configuration instance to interface. Suppose some 3 rd  party requires your configuration\nto implement interface:  public   class   MyConfiguraton   extends   Configuration   implements   HasRequiredConfig   {...}   If binding by interface is enabled:  . bindConfigurationInterfaces ()   Then configuration could be injected by interface:  @Inject   HasRequiredConfig   conf ;    Note  By default, configuration is bound only for  all classes in hierarchy . In example above it would be  Configuration  and  MyConfiguration .",
            "title": "Configuration binding"
        },
        {
            "location": "/guide/configuration/#diagnostic",
            "text": "Enable configuration  diagnostic console logs  to diagnose configuration problems:  . printDiagnosticInfo ()   In case of doubts about extension owner (guice or HK) and suspicious for duplicate instantiation,\nyou can enable  strict control  which will throw exception in case of wrong owner:  . strictScopeControl ()",
            "title": "Diagnostic"
        },
        {
            "location": "/guide/lifecycle/",
            "text": "Integration lifecycle\n\u00b6\n\n\nJersey2 guice integration is more complicated than for jersey1, because of \nHK2\n container, used by jersey2.\n\n\n\n\nNote\n\n\nMany people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it \nin the same elegant way as we can use guice. HK context is launched too late (after dropwizard run phase).\nFor example, it is impossible to use HK to instantiate dropwizard managed object because managed\nmust be registered before HK context starts.\n\n\n\n\nGuice integration done in guice exclusive way as much as possible: everything should be managed by guice and invisibly integrated into HK2.\nAnyway, it is not always possible to hide integration details, especially if you need to register jersey extensions.\n\n\n\n\nGuice context starts before HK context.\n\n\n\n\nLifecycle\n\u00b6\n\n\n\n\nDropwizard configuration phase    \n\n\nGuice bundle registered (in application \ninitialize\n method)\n\n\nPerform \nclasspath scan for commands\n (\noptional\n)\n\n\n\n\n\n\nDropwizard run phase\n\n\nDropwizard runs bundles (guice bundle is one of them so guice initialization may be performed between other dropwizard bundles)\n\n\nSearch guicey bundles in dropwizard bundles (\noptional\n) \n\n\nLookup guicey bundles\n   \n\n\nApply configuration from guicey bundles\n\n\nInjector creation\n (\nusing factory\n)\n\n\nBind dropwizard objects\n: Environment, Configuration, Bootstrap\n\n\nScan for installers (in auto configuration mode)\n\n\nScan for extensions (in auto configuration mode)\n\n\nRegister \nGuiceFeature\n in environment (jersey \nFeature\n which will trigger jersey side installations)\n\n\nApply \nlazy jersey bindings\n\n\nActivate \nguice servlet support\n, register GuiceFilter on admin and main contexts (\ncould be disabled\n)\n\n\n\n\n\n\nInjector created\n\n\nCall installers to register extensions\n\n\n\n\n\n\nYour application's \nrun\n method executed. Injector is already available, so any guice bean could be \naccessed\n          \n\n\n\n\n\n\nJersey start\n\n\nManaged beans\n started\n\n\nHK2 context creation\n\n\nGuiceFeature\n (registered earlier) called\n\n\nRegister \nhk2-guice bridge\n (only guice to hk way to let hk managed beans inject guice beans)\n\n\nRun jersey specific installers (\nresource\n, \nextension\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nAny \nEnvironmentCommand\n did no start jersey, so managed objects will not be started.\nAlso, all jersey related extensions will not be started. Still, core guice context will be completely operable. \n\n\n\n\n\n\nWhen guice context is created, \njersey context doesn't exist\n and when jersey context is created \nit doesn't aware of guice existence\n.\n\n\n\n\nCross context bindings\n\u00b6\n\n\nAccess jersey beans from guice\n\u00b6\n\n\nTo access HK bindings we need HK2 \nServiceLocator\n: it's instance is registered by \nGuiceFeature\n (in time of HK context startup).\n\n\nJersey components are bound as providers:\n\n\nbinder\n.\nbind\n(\njerseyType\n).\ntoProvider\n(\nnew\n \nLazyJerseyProvider\n(\njerseyType\n));\n\n\n\n\n\n\nInternally this provider will perform lookup in HK service locator:\n\n\ninjector\n.\ngetInstance\n(\nServiceLocator\n.\nclass\n).\ngetService\n(\njerseyType\n);\n\n\n\n\n\n\nThis way jersey beans are \"bridged\" to guice. They can't be accessed directly in guice beans\nat injector creation time (as there is nothing to \"bridge\" yet). \n\n\n@Inject\n \nProvider\n<\nJerseyType\n>\n \nprovider\n must be used to access such beans.     \n\n\nSee more details in \njersey bindings module\n.\n\n\nAccess guice beans from jersey\n\u00b6\n\n\n\n\nNote\n\n\nIt's almost never required to care about beans visibility from HK side because guicey already did all required\nbindings.\n\n\n\n\nHK could see all guice beans because of registered guice-bridge. But it doesn't mean HK can analyze \nall guice beans to search for extensions (it can resolve only direct injection).\n\n\nSpecific jersey installers (\nresource\n, \nextension\n) \ncreate required bindings manually in time of HK context creation.\n\n\nJersey extensions installer\n handles most specific installation cases\n(where HK knowledge is required). It uses the same technic, as the other side binding:\n\n\nbinder\n.\nbindFactory\n(\nnew\n \nLazyGuiceProvider\n(\nguiceType\n)).\nto\n(\ntype\n)\n\n\n\n\n\n\nOn request, factory will simply delegate lookup to guice injector:\n\n\ninjector\n.\ngetInstance\n(\nguiceType\n);\n\n\n\n\n\n\n\n\nTip\n\n\nIf you just want to add some beans in HK context, annotate such beans with \n@Provider\n and \n@HK2Managed\n - provider\nwill be recognized by installer and hk managed annotation will trigger simple registration (overall it's the same\nas write binding manually).\n\n@HK2Managed\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyBeanMangedByHK\n \n{\n \n...\n \n}\n    \n\n\n\n\n\n\n\nFor more details look \njersey provider installer\n\n\nProblematic cases\n\u00b6\n\n\nThe problems may appear with binding of jersey extensions.\nGood example is \nValueFactoryProvider\n. Most likely you will use \nAbstractValueFactoryProvider\n as base class, but it declares\ndirect binding for \nMultivaluedParameterExtractorProvider\n. So such bean would be impossible to create eagerly in guice context.\n\n\nThere are two options to solve this:\n\n\n\n\nuse \n@LazyBinding\n: bean instance will not be created together with guice context (when \nMultivaluedParameterExtractorProvider\n is not available),\nand creation will be initiated by HK, when binding could be resolved.\n\n\nor use \n@HK2Managed\n this will delegate instance management to HK, but still guice specific extensions may be used.\n\n\n\n\nIn other cases simply wrap jersey specific bindings into \nProvider\n.",
            "title": "Integration lifecycle"
        },
        {
            "location": "/guide/lifecycle/#integration-lifecycle",
            "text": "Jersey2 guice integration is more complicated than for jersey1, because of  HK2  container, used by jersey2.   Note  Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it \nin the same elegant way as we can use guice. HK context is launched too late (after dropwizard run phase).\nFor example, it is impossible to use HK to instantiate dropwizard managed object because managed\nmust be registered before HK context starts.   Guice integration done in guice exclusive way as much as possible: everything should be managed by guice and invisibly integrated into HK2.\nAnyway, it is not always possible to hide integration details, especially if you need to register jersey extensions.   Guice context starts before HK context.",
            "title": "Integration lifecycle"
        },
        {
            "location": "/guide/lifecycle/#lifecycle",
            "text": "Dropwizard configuration phase      Guice bundle registered (in application  initialize  method)  Perform  classpath scan for commands  ( optional )    Dropwizard run phase  Dropwizard runs bundles (guice bundle is one of them so guice initialization may be performed between other dropwizard bundles)  Search guicey bundles in dropwizard bundles ( optional )   Lookup guicey bundles      Apply configuration from guicey bundles  Injector creation  ( using factory )  Bind dropwizard objects : Environment, Configuration, Bootstrap  Scan for installers (in auto configuration mode)  Scan for extensions (in auto configuration mode)  Register  GuiceFeature  in environment (jersey  Feature  which will trigger jersey side installations)  Apply  lazy jersey bindings  Activate  guice servlet support , register GuiceFilter on admin and main contexts ( could be disabled )    Injector created  Call installers to register extensions    Your application's  run  method executed. Injector is already available, so any guice bean could be  accessed               Jersey start  Managed beans  started  HK2 context creation  GuiceFeature  (registered earlier) called  Register  hk2-guice bridge  (only guice to hk way to let hk managed beans inject guice beans)  Run jersey specific installers ( resource ,  extension )          Note  Any  EnvironmentCommand  did no start jersey, so managed objects will not be started.\nAlso, all jersey related extensions will not be started. Still, core guice context will be completely operable.     When guice context is created,  jersey context doesn't exist  and when jersey context is created  it doesn't aware of guice existence .",
            "title": "Lifecycle"
        },
        {
            "location": "/guide/lifecycle/#cross-context-bindings",
            "text": "",
            "title": "Cross context bindings"
        },
        {
            "location": "/guide/lifecycle/#access-jersey-beans-from-guice",
            "text": "To access HK bindings we need HK2  ServiceLocator : it's instance is registered by  GuiceFeature  (in time of HK context startup).  Jersey components are bound as providers:  binder . bind ( jerseyType ). toProvider ( new   LazyJerseyProvider ( jerseyType ));   Internally this provider will perform lookup in HK service locator:  injector . getInstance ( ServiceLocator . class ). getService ( jerseyType );   This way jersey beans are \"bridged\" to guice. They can't be accessed directly in guice beans\nat injector creation time (as there is nothing to \"bridge\" yet).   @Inject   Provider < JerseyType >   provider  must be used to access such beans.       See more details in  jersey bindings module .",
            "title": "Access jersey beans from guice"
        },
        {
            "location": "/guide/lifecycle/#access-guice-beans-from-jersey",
            "text": "Note  It's almost never required to care about beans visibility from HK side because guicey already did all required\nbindings.   HK could see all guice beans because of registered guice-bridge. But it doesn't mean HK can analyze \nall guice beans to search for extensions (it can resolve only direct injection).  Specific jersey installers ( resource ,  extension ) \ncreate required bindings manually in time of HK context creation.  Jersey extensions installer  handles most specific installation cases\n(where HK knowledge is required). It uses the same technic, as the other side binding:  binder . bindFactory ( new   LazyGuiceProvider ( guiceType )). to ( type )   On request, factory will simply delegate lookup to guice injector:  injector . getInstance ( guiceType );    Tip  If you just want to add some beans in HK context, annotate such beans with  @Provider  and  @HK2Managed  - provider\nwill be recognized by installer and hk managed annotation will trigger simple registration (overall it's the same\nas write binding manually). @HK2Managed  @Provider  public   class   MyBeanMangedByHK   {   ...   }         For more details look  jersey provider installer",
            "title": "Access guice beans from jersey"
        },
        {
            "location": "/guide/lifecycle/#problematic-cases",
            "text": "The problems may appear with binding of jersey extensions.\nGood example is  ValueFactoryProvider . Most likely you will use  AbstractValueFactoryProvider  as base class, but it declares\ndirect binding for  MultivaluedParameterExtractorProvider . So such bean would be impossible to create eagerly in guice context.  There are two options to solve this:   use  @LazyBinding : bean instance will not be created together with guice context (when  MultivaluedParameterExtractorProvider  is not available),\nand creation will be initiated by HK, when binding could be resolved.  or use  @HK2Managed  this will delegate instance management to HK, but still guice specific extensions may be used.   In other cases simply wrap jersey specific bindings into  Provider .",
            "title": "Problematic cases"
        },
        {
            "location": "/guide/injector/",
            "text": "Injector instance\n\u00b6\n\n\nRestrictive options\n\u00b6\n\n\nGuicey itself is compatible with the following guice restrictive options:\n\n\npublic\n \nclass\n \nMyModule\n \nextends\n \nAbstractModule\n \n{\n\n        \n@Override\n\n        \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n            \nbinder\n().\ndisableCircularProxies\n();\n\n            \nbinder\n().\nrequireExactBindingAnnotations\n();\n\n            \nbinder\n().\nrequireExplicitBindings\n();\n\n        \n}\n\n    \n}\n\n\n\n\n\n\nSo it is safe to enable them.\n\n\nAccess injector\n\u00b6\n\n\nIn some cases it may be important to get injector instance outside of guice context.\n\n\n\n\nNote\n\n\nInjector is created on dropwizard run phase. Attempt to obtain injector before it\nwill lead to exception.\n\n\n\n\nInjector instance could be resolved with:\n\n\n\n\ngetInjector()\n method on GuiceBundle instance (NPE will be thrown if injector not initialized)\n\n\nInjectorLookup.getInjector(app).get()\n static call using application instance (lookup returns \nOptional\n for null safety).\n\n\n\n\nIf you need lazy injector reference, you can use \nInjectorProvider\n class (it's actually \nProvider<Injector>\n):\n\n\nProvider\n<\nInjector\n>\n \nprovider\n \n=\n \nnew\n \nInjectorProvider\n(\napp\n);\n\n\n// somewhere after run phase\n\n\nInjector\n \ninjector\n \n=\n \nprovider\n.\nget\n();\n\n\n\n\n\n\nWhen you are inside your application class:\n\n\npublic\n \nclass\n \nMyApplication\n \nextends\n \nApplication\n<\nConfiguration\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nTestConfiguration\n \nconfiguration\n,\n \nEnvironment\n \nenvironment\n)\n \nthrows\n \nException\n \n{\n\n        \nInjectorLookup\n.\ngetInjector\n(\nthis\n).\nget\n()\n\n                \n.\ngetInstance\n(\nSomeService\n.\nclass\n).\ndoSomething\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nTip\n\n\nMost likely, requirement for injector instance means integration with some third party library.\nConsider writing custom installer in such cases (it will eliminate need for injector instance).\n\n\n\n\nInside guice context you can simply inject Injector instance:\n\n\n@Inject\n \nInjector\n \ninjector\n;\n\n\n\n\n\n\nInjector factory\n\u00b6\n\n\nYou can control guice injector creation through \nru.vyarus.dropwizard.guice.injector.InjectorFactory\n. \n\n\nDefault implementation is very simple:\n\n\npublic\n \nclass\n \nDefaultInjectorFactory\n \nimplements\n \nInjectorFactory\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nInjector\n \ncreateInjector\n(\nfinal\n \nStage\n \nstage\n,\n \nfinal\n \nIterable\n<?\n \nextends\n \nModule\n>\n \nmodules\n)\n \n{\n\n        \nreturn\n \nGuice\n.\ncreateInjector\n(\nstage\n,\n \nmodules\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nInjector creation customization may be required by some 3\nrd\n party library.\nFor example, \nnetflix governator\n \nowns injector creation (\nsee example\n).\n\n\nCustom injector factory could be registered in guice bundle builder:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\ninjectorFactory\n(\nnew\n \nCustomInjectorFactory\n())\n\n            \n...",
            "title": "Injector"
        },
        {
            "location": "/guide/injector/#injector-instance",
            "text": "",
            "title": "Injector instance"
        },
        {
            "location": "/guide/injector/#restrictive-options",
            "text": "Guicey itself is compatible with the following guice restrictive options:  public   class   MyModule   extends   AbstractModule   { \n         @Override \n         protected   void   configure ()   { \n             binder (). disableCircularProxies (); \n             binder (). requireExactBindingAnnotations (); \n             binder (). requireExplicitBindings (); \n         } \n     }   So it is safe to enable them.",
            "title": "Restrictive options"
        },
        {
            "location": "/guide/injector/#access-injector",
            "text": "In some cases it may be important to get injector instance outside of guice context.   Note  Injector is created on dropwizard run phase. Attempt to obtain injector before it\nwill lead to exception.   Injector instance could be resolved with:   getInjector()  method on GuiceBundle instance (NPE will be thrown if injector not initialized)  InjectorLookup.getInjector(app).get()  static call using application instance (lookup returns  Optional  for null safety).   If you need lazy injector reference, you can use  InjectorProvider  class (it's actually  Provider<Injector> ):  Provider < Injector >   provider   =   new   InjectorProvider ( app );  // somewhere after run phase  Injector   injector   =   provider . get ();   When you are inside your application class:  public   class   MyApplication   extends   Application < Configuration >   { \n\n     @Override \n     public   void   run ( TestConfiguration   configuration ,   Environment   environment )   throws   Exception   { \n         InjectorLookup . getInjector ( this ). get () \n                 . getInstance ( SomeService . class ). doSomething (); \n     }  }    Tip  Most likely, requirement for injector instance means integration with some third party library.\nConsider writing custom installer in such cases (it will eliminate need for injector instance).   Inside guice context you can simply inject Injector instance:  @Inject   Injector   injector ;",
            "title": "Access injector"
        },
        {
            "location": "/guide/injector/#injector-factory",
            "text": "You can control guice injector creation through  ru.vyarus.dropwizard.guice.injector.InjectorFactory .   Default implementation is very simple:  public   class   DefaultInjectorFactory   implements   InjectorFactory   { \n\n     @Override \n     public   Injector   createInjector ( final   Stage   stage ,   final   Iterable <?   extends   Module >   modules )   { \n         return   Guice . createInjector ( stage ,   modules ); \n     }  }   Injector creation customization may be required by some 3 rd  party library.\nFor example,  netflix governator  \nowns injector creation ( see example ).  Custom injector factory could be registered in guice bundle builder:  bootstrap . addBundle ( GuiceBundle . builder () \n             . injectorFactory ( new   CustomInjectorFactory ()) \n             ...",
            "title": "Injector factory"
        },
        {
            "location": "/guide/module-autowiring/",
            "text": "Module autowiring\n\u00b6\n\n\nBecause guice modules are registered in dropwizard init section only \nBootstrap\n instance is available.\nOften \nEnvironment\n and \nConfiguration\n objects are also required.\n\n\nAutowiring interfaces\n\u00b6\n\n\nGuicey can automatically inject environment and configuration objects into your module if \nit implements any of (or all of them): \nBootstrapAwareModule\n, \nEnvironmentAwareModule\n \nand \nConfigurationAwareModule\n interfaces. \n\n\nReference object will be set to module just before injector creation, so you can use it inside your \nmodule logic (\nconfiguration\n method).\n\n\n\n\nWarning\n\n\nModule autowiring will only work for modules directly set to \nmodules()\n (of main bundle or any guicey bundle).\n\n\n\n\npublic\n \nclass\n \nMyModule\n \nimplements\n \nEnvironmentAwareModule\n \n{\n\n    \nprivate\n \nEnvironemnt\n \nenvironment\n;\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nsetEnvironment\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nthis\n.\nenvironment\n \n=\n \nenvironment\n;\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \n// use environment here\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAutowiring base class\n\u00b6\n\n\nTo avoid manually implementing interfaces (avoid boilerplate) you can use \nDropwizardAwareModule\n as \nbase class which already implements all autowiring interfaces:\n\n\npublic\n \nclass\n \nMyModule\n \nextends\n \nDropwizardAwareModule\n<\nMyConfiguration\n>\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nbootstrap\n()\n     \n// Bootstrap instance\n\n        \nenvironment\n()\n   \n// Environment instance\n\n        \nconfiguration\n()\n \n// MyConfiguration instance\n\n        \nappPackage\n()\n    \n// application class package \n\n    \n}\n\n\n}",
            "title": "Module autowiring"
        },
        {
            "location": "/guide/module-autowiring/#module-autowiring",
            "text": "Because guice modules are registered in dropwizard init section only  Bootstrap  instance is available.\nOften  Environment  and  Configuration  objects are also required.",
            "title": "Module autowiring"
        },
        {
            "location": "/guide/module-autowiring/#autowiring-interfaces",
            "text": "Guicey can automatically inject environment and configuration objects into your module if \nit implements any of (or all of them):  BootstrapAwareModule ,  EnvironmentAwareModule  \nand  ConfigurationAwareModule  interfaces.   Reference object will be set to module just before injector creation, so you can use it inside your \nmodule logic ( configuration  method).   Warning  Module autowiring will only work for modules directly set to  modules()  (of main bundle or any guicey bundle).   public   class   MyModule   implements   EnvironmentAwareModule   { \n     private   Environemnt   environment ; \n\n     @Override \n     public   void   setEnvironment ( Environment   environment )   { \n         this . environment   =   environment ; \n     } \n\n     @Override \n     protected   void   configure ()   { \n         // use environment here \n     }  }",
            "title": "Autowiring interfaces"
        },
        {
            "location": "/guide/module-autowiring/#autowiring-base-class",
            "text": "To avoid manually implementing interfaces (avoid boilerplate) you can use  DropwizardAwareModule  as \nbase class which already implements all autowiring interfaces:  public   class   MyModule   extends   DropwizardAwareModule < MyConfiguration >   { \n     @Override \n     protected   void   configure ()   { \n         bootstrap ()       // Bootstrap instance \n         environment ()     // Environment instance \n         configuration ()   // MyConfiguration instance \n         appPackage ()      // application class package  \n     }  }",
            "title": "Autowiring base class"
        },
        {
            "location": "/guide/bindings/",
            "text": "Bindings\n\u00b6\n\n\nAll extensions, installed by guicey installers are explicitly bound to guice (except cases when \nit's not possible, like \neager extension\n).\n\n\nAlso, guicey binds some dropwizard and jersey objects. \n\n\nConfiguration\n\u00b6\n\n\nConfiguration\n bound to guice as:\n\n\n\n\nio.dropwizard.Configuration\n\n\nYour configuration class (\nMyConfiguration\n \nextends\n \nConfiguration\n)\n\n\nAll classes between them\n\n\n\n\nFor example, if\n\n\nMyConfiguration\n \nextends\n \nMyAbstractConfiguration\n \nextends\n \nConfiguration\n\n\n\n\n\n\nThen \nMyAbstractConfiguration\n will be also bound and following injection will work:\n\n\n@Inject\n \nMyAbstractConfiguration\n \nconf\n\n\n\n\n\n\nWhen \n.bindConfigurationInterfaces()\n enabled, all direct interfaces implemented by configuration class (or any subclass) are bound.\nThis may be used to support common \nHas<Something>\n configuration interfaces convention used to recognize your extension configuration in configuration object.\n\n\nFor example:\n\n\n    \nGuiceBundle\n.\nbuilder\n()\n\n        \n.\nbundConfigurationInterfactes\n()\n\n        \n...\n\n\n    \npublic\n \ninterface\n \nHasFeatureX\n \n{\n\n        \nFeatureXConfig\n \ngetFetureXConfig\n();\n\n    \n}\n\n\n    \npublic\n \nclass\n \nMyConfiguration\n \nextends\n \nConfiguration\n \nimplements\n \nHasFeatureXConfig\n \n{...}\n\n\n    \npublic\n \nclass\n \nMyBean\n \n{\n\n        \n@Inject\n \nHasFeatureX\n \nconfiguration\n;\n\n        \n...\n\n    \n}\n\n\n\n\n\n\nInterface binding will ignore interfaces in \njava.*\n or \ngroovy.*\n packages (to avoid unnecessary bindings).\n\n\nEnvironment binding\n\u00b6\n\n\nDropwizard \nio.dropwizard.setup.Environment\n is bound to guice context.\n\n\nIt is mostly useful to perform additional configurations in guice bean for features not covered with installers. \nFor example:\n\n\npublic\n \nclass\n \nMyBean\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nMyBean\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nenvironment\n.\nlifecycle\n().\naddServerLifecycleListener\n(\nnew\n \nServerLifecycleListener\n \n{\n\n            \npublic\n \nvoid\n \nserverStarted\n(\nServer\n \nserver\n)\n \n{\n\n                \ncallSomeMethod\n();\n\n            \n}\n\n        \n})\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIt's not the best example, but it illustrates usage (and such things usually helps to quick-test something). \n\n\nSee also \nauthentication configuration example\n.\n\n\nJersey specific bindings\n\u00b6\n\n\nJersey bindings are not immediately available, because HK context starts after guice, \nso use \nProvider\n to inject these bindings.\n\n\nThese bindings available after HK context start:\n\n\n\n\njavax.ws.rs.core.Application\n\n\njavax.ws.rs.ext.Providers\n\n\norg.glassfish.hk2.api.ServiceLocator\n\n\norg.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider\n\n\n\n\nRequest-scoped bindings:\n\n\n\n\njavax.ws.rs.core.UriInfo\n\n\njavax.ws.rs.core.HttpHeaders\n\n\njavax.ws.rs.core.SecurityContext\n\n\njavax.ws.rs.core.Request\n\n\norg.glassfish.jersey.server.ContainerRequest\n\n\norg.glassfish.jersey.server.internal.process.AsyncContext\n\n\n\n\nRequest and response\n\u00b6\n\n\nBy default, \nGuiceFilter\n is enabled on both contexts (admin and main). So you can inject\nrequest and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions).\n\n\nIf you disable guice filter with \n.noGuiceFilter()\n then\nguicey will bridge objects from HK context:\n\n\n\n\njavax.servlet.http.HttpServletRequest\n\n\njavax.servlet.http.HttpServletResponse\n\n\n\n\n\n\nThis means you can still inject them, but request and response will\nonly be available under resource calls (the only part managed by jersey).\n\n\n\n\nExample usage:\n\n\n@Inject\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;",
            "title": "Bindings"
        },
        {
            "location": "/guide/bindings/#bindings",
            "text": "All extensions, installed by guicey installers are explicitly bound to guice (except cases when \nit's not possible, like  eager extension ).  Also, guicey binds some dropwizard and jersey objects.",
            "title": "Bindings"
        },
        {
            "location": "/guide/bindings/#configuration",
            "text": "Configuration  bound to guice as:   io.dropwizard.Configuration  Your configuration class ( MyConfiguration   extends   Configuration )  All classes between them   For example, if  MyConfiguration   extends   MyAbstractConfiguration   extends   Configuration   Then  MyAbstractConfiguration  will be also bound and following injection will work:  @Inject   MyAbstractConfiguration   conf   When  .bindConfigurationInterfaces()  enabled, all direct interfaces implemented by configuration class (or any subclass) are bound.\nThis may be used to support common  Has<Something>  configuration interfaces convention used to recognize your extension configuration in configuration object.  For example:       GuiceBundle . builder () \n         . bundConfigurationInterfactes () \n         ... \n\n     public   interface   HasFeatureX   { \n         FeatureXConfig   getFetureXConfig (); \n     } \n\n     public   class   MyConfiguration   extends   Configuration   implements   HasFeatureXConfig   {...} \n\n     public   class   MyBean   { \n         @Inject   HasFeatureX   configuration ; \n         ... \n     }   Interface binding will ignore interfaces in  java.*  or  groovy.*  packages (to avoid unnecessary bindings).",
            "title": "Configuration"
        },
        {
            "location": "/guide/bindings/#environment-binding",
            "text": "Dropwizard  io.dropwizard.setup.Environment  is bound to guice context.  It is mostly useful to perform additional configurations in guice bean for features not covered with installers. \nFor example:  public   class   MyBean   { \n\n     @Inject \n     public   MyBean ( Environment   environment )   { \n         environment . lifecycle (). addServerLifecycleListener ( new   ServerLifecycleListener   { \n             public   void   serverStarted ( Server   server )   { \n                 callSomeMethod (); \n             } \n         }) \n     }  }   It's not the best example, but it illustrates usage (and such things usually helps to quick-test something).   See also  authentication configuration example .",
            "title": "Environment binding"
        },
        {
            "location": "/guide/bindings/#jersey-specific-bindings",
            "text": "Jersey bindings are not immediately available, because HK context starts after guice, \nso use  Provider  to inject these bindings.  These bindings available after HK context start:   javax.ws.rs.core.Application  javax.ws.rs.ext.Providers  org.glassfish.hk2.api.ServiceLocator  org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider   Request-scoped bindings:   javax.ws.rs.core.UriInfo  javax.ws.rs.core.HttpHeaders  javax.ws.rs.core.SecurityContext  javax.ws.rs.core.Request  org.glassfish.jersey.server.ContainerRequest  org.glassfish.jersey.server.internal.process.AsyncContext",
            "title": "Jersey specific bindings"
        },
        {
            "location": "/guide/bindings/#request-and-response",
            "text": "By default,  GuiceFilter  is enabled on both contexts (admin and main). So you can inject\nrequest and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions).  If you disable guice filter with  .noGuiceFilter()  then\nguicey will bridge objects from HK context:   javax.servlet.http.HttpServletRequest  javax.servlet.http.HttpServletResponse    This means you can still inject them, but request and response will\nonly be available under resource calls (the only part managed by jersey).   Example usage:  @Inject   Provider < HttpServletRequest >   requestProvider ;",
            "title": "Request and response"
        },
        {
            "location": "/guide/scan/",
            "text": "Classpath scan\n\u00b6\n\n\n\n\nSummary\n\n\nUse scan only for application package. When part of application extracted to it's own library (usually already mature part) \ncreate guicey bundle for it with explicit extensions definition. Use manual bundles installation or bundle lookup mechanism \nto install custom bundles.\n\n\n\n\nConfiguration\n\u00b6\n\n\nClasspath scanning is activated by specifying package to scan in bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nenableAutoConfig\n(\n\"package.to.scan\"\n)\n\n\n\n\n\n\nOr multiple packages:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nenableAutoConfig\n(\n\"com.mycompany.pkg1\"\n,\n \n\"com.mycompany.pkg2\"\n)\n\n\n\n\n\n\nHow it works\n\u00b6\n\n\nWhen auto scan enabled:\n\n\n\n\nExtension installers are searched in classpath (classes implementing \nFeatureInstaller\n).\n\n\nExtensions are searched using registered installers (\nFeatureInstaller#matches\n method).\n\n\nIf commands search is enabled (\n.searchCommands()\n), performs search for all classes extending \nCommand\n and \ninstall them into\nbootstrap\n.\n\n\n\n\nClasses are searched in specified packages and all their subpackages.\nAbstract classes are ignored. \n\n\nInner static classes are also resolved:\n\n\npublic\n \nabstract\n \nclass\n \nAbstractExceptionMapper\n<\nT\n \nextends\n \nException\n>\n \nimplements\n \nExceptionMapper\n<\nT\n>\n \n{\n\n\n    \n@Provider\n\n    \npublic\n \nstatic\n \nclass\n \nFooExceptionMapper\n \nextends\n \nAbstractExceptionMapper\n<\nIOException\n>\n \n{\n \n...\n \n}\n\n\n    \n@Provider\n\n    \npublic\n \nstatic\n \nclass\n \nBarExceptionMapper\n \nextends\n \nAbstractExceptionMapper\n<\nServletException\n>\n \n{\n \n...\n \n}\n\n\n}\n\n\n\n\n\n\nFooExceptionMapper\n and \nBarExceptionMapper\n would be detected and installed.\n\n\nHide class from scan\n\u00b6\n\n\n@InvisibleForScanner\n annotation hides class from scanner (for example, to install it manually or to avoid installation at all)\n\n\n@Provider\n\n\n@InvisibleForScanner\n\n\npublic\n \nstatic\n \nclass\n \nFooExceptionMapper\n \nextends\n \nAbstractExceptionMapper\n<\nIOException\n>\n \n{\n \n...\n \n}\n\n\n\n\n\n\nIn this case \nFooExceptionMapper\n will be ignored by classpath scanner. But you still can install extension manually.\n\n\nMotivation\n\u00b6\n\n\nUsually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case). \n\n\nClasspath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like \nreflections\n, \n\nfast scanner\n or even jersey's internal classpath scan parse class structure instead of loading classes. \nIn general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. \nMoreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple).\n\n\nUsing classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer.\nActual application configuration could always be checked with \ndiagnostic output\n),\nso there should not be any problems for using classpath scan for production too.\n\n\n\n\nWarning\n\n\nIt's a bad idea to use classpath scan for resolving extensions from 3\nrd\n party jars. Group extensions from external \njars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, \nso it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions.\nIf you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup (enabled by default) which could load \nbundles with service loader definition (ServiceLoaderBundleLookup).",
            "title": "Classpath scan"
        },
        {
            "location": "/guide/scan/#classpath-scan",
            "text": "Summary  Use scan only for application package. When part of application extracted to it's own library (usually already mature part) \ncreate guicey bundle for it with explicit extensions definition. Use manual bundles installation or bundle lookup mechanism \nto install custom bundles.",
            "title": "Classpath scan"
        },
        {
            "location": "/guide/scan/#configuration",
            "text": "Classpath scanning is activated by specifying package to scan in bundle:  GuiceBundle . builder () \n     . enableAutoConfig ( \"package.to.scan\" )   Or multiple packages:  GuiceBundle . builder () \n     . enableAutoConfig ( \"com.mycompany.pkg1\" ,   \"com.mycompany.pkg2\" )",
            "title": "Configuration"
        },
        {
            "location": "/guide/scan/#how-it-works",
            "text": "When auto scan enabled:   Extension installers are searched in classpath (classes implementing  FeatureInstaller ).  Extensions are searched using registered installers ( FeatureInstaller#matches  method).  If commands search is enabled ( .searchCommands() ), performs search for all classes extending  Command  and  install them into\nbootstrap .   Classes are searched in specified packages and all their subpackages.\nAbstract classes are ignored.   Inner static classes are also resolved:  public   abstract   class   AbstractExceptionMapper < T   extends   Exception >   implements   ExceptionMapper < T >   { \n\n     @Provider \n     public   static   class   FooExceptionMapper   extends   AbstractExceptionMapper < IOException >   {   ...   } \n\n     @Provider \n     public   static   class   BarExceptionMapper   extends   AbstractExceptionMapper < ServletException >   {   ...   }  }   FooExceptionMapper  and  BarExceptionMapper  would be detected and installed.",
            "title": "How it works"
        },
        {
            "location": "/guide/scan/#hide-class-from-scan",
            "text": "@InvisibleForScanner  annotation hides class from scanner (for example, to install it manually or to avoid installation at all)  @Provider  @InvisibleForScanner  public   static   class   FooExceptionMapper   extends   AbstractExceptionMapper < IOException >   {   ...   }   In this case  FooExceptionMapper  will be ignored by classpath scanner. But you still can install extension manually.",
            "title": "Hide class from scan"
        },
        {
            "location": "/guide/scan/#motivation",
            "text": "Usually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case).   Classpath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like  reflections ,  fast scanner  or even jersey's internal classpath scan parse class structure instead of loading classes. \nIn general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. \nMoreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple).  Using classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer.\nActual application configuration could always be checked with  diagnostic output ),\nso there should not be any problems for using classpath scan for production too.   Warning  It's a bad idea to use classpath scan for resolving extensions from 3 rd  party jars. Group extensions from external \njars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, \nso it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions.\nIf you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup (enabled by default) which could load \nbundles with service loader definition (ServiceLoaderBundleLookup).",
            "title": "Motivation"
        },
        {
            "location": "/guide/installers/",
            "text": "Installers\n\u00b6\n\n\nInstaller is a core integration concept: every extension point has it's own installer. Installers used for both \nauto scan\n and manual modes\n(the only difference is in manual mode classes specified manually).\nInstallers itself are resolved using classpath scanning, so it's very easy to add custom installers (and possibly override default one by disabling it and registering alternative).\n\n\nAll default installers are registered by \nCoreInstallersBundle\n\n\nHow it works\n\u00b6\n\n\nWhen installer recognize class, it binds it into guice \nbinder.bind(foundClass)\n (or bind by installer if it \nsupport binding\n).\nBut extensions annotated with \n@LazyBinding\n are not bound to guice context. This may be useful to \ndelay bean creation\n:\nby default, guice production stage will instantiate all registered beans.\n\n\nOn run phase (after injector created) all found or manually provided extensions are installed by type or instantiated (\ninjector.getInstance(foundClass)\n) and passed to installer \nto register extension within dropwizard (installation type is defined by installer).\n\n\nInstallers are \nordered\n.\n\n\n\n\nEach extension is installed by only one installer!\n\n\nIf extension could be recognized by more then one installers, it will be installed only by first \nmatching installer (according to installers order). \n\n\n\n\nWriting custom installer\n\u00b6\n\n\nInstaller should implement \nFeatureInstaller\n\ninterface. It will be automatically registered if auto scan is enabled. To register manually use \n.installers()\n bundle option.\n\n\nInstaller \nmatches\n method implements feature detection logic. You can use \nFeatureUtils\n for type checks, because it's denies\nabstract classes. Method is called for classes found during scan to detect installable features and for classes directly specified\nwith \n.extensions()\n bundle option to detect installer.\n\n\nThree types of installation supported. Installer should implement one or more of these interfaces:\n\n\n\n\nBindingInstaller\n allows custom guice bindings. If installer doesn't implement this interface sinmple \nbind(type)\n will be called to register in guice.\n\n\nTypeInstaller\n used for registration based on type (no instance created during installation).\n\n\nInstanceInstaller\n used for instance registration. Instance created using \ninjector.getInstance(type)\n.\n\n\nJerseyInstaller\n used for registration of bindings in HK context.\n\n\n\n\nNote that extensions may use \n@LazyBinding\n annotation. In general case such extensions will not be registered in guice.\nIn case of \nBindingInstaller\n, special hint will be passed and installer should decide how to handle it (may throw exception as not supported).\n\n\nBindingInstaller\n called in time of injector creation, whereas \nTypeInstaller\n and \nInstanceInstaller\n are called just after injector creation.\n\nJerseyInstaller\n is called on jersey start.\n\n\n\n\nInstallers are not guice beans! So injections can't be used inside them. \nThis is because installers also used during initialization phase and instantiated before injector creation.\n\n\n\n\nExample installer:\n\n\npublic\n \nclass\n \nCustomInstaller\n \nimplements\n \nFeatureInstaller\n<\nCustomFeature\n>\n \n{\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nmatches\n(\nfinal\n \nClass\n<?>\n \ntype\n)\n \n{\n\n        \nreturn\n \nFeatureUtils\n.\nis\n(\ntype\n,\n \nCustomFeature\n.\nclass\n);\n\n    \n}\n    \n\n}\n\n\n\n\n\n\nFinds all CustomFeature derived classes and register them in guice (implicit registration - all classes matched by installer are registered in injector). Note that no installer interfaces were used, \nbecause guice registration is enough.\n\n\nNow suppose CustomFeature is a base class for our jersey extensions. Then installer will be:\n\n\npublic\n \nclass\n \nCustomInstaller\n \nimplements\n \nFeatureInstaller\n<\nCustomFeature\n>,\n \nJerseyInstaller\n<\nCustomFeature\n>\n \n{\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nmatches\n(\nfinal\n \nClass\n<?>\n \ntype\n)\n \n{\n\n        \nreturn\n \nFeatureUtils\n.\nis\n(\ntype\n,\n \nCustomFeature\n.\nclass\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninstall\n(\nfinal\n \nAbstractBinder\n \nbinder\n,\n \nfinal\n \nClass\n<\nCustomFeature\n>\n \ntype\n)\n \n{\n\n        \nJerseyBinding\n.\nbindComponent\n(\nbinder\n,\n \ntype\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nreport\n()\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOrdering\n\u00b6\n\n\nIn order to support \nordering\n, installer must implement \nOrdered\n interface.\nIf installer doesn't implement it extensions will not be sorted, even if extensions has \n@Order\n annotations. \n\n\nAs example, see \nManagedInstaller\n\n\nReporting\n\u00b6\n\n\nInstallers \nreport()\n method will be called after it finish installation of all found extensions. Report provides\nuser visibility of installed extensions. \n\n\nTo simplify reporting use predefined \nReporter\n class. \nSee example usage in \nManagedInstaller\n\n\nINFO  [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.support.feature.DummyManaged)\n\n\n\n\n\nFor complex cases, reporter may be extended to better handle installed extensions. As examples see \n\nplugin installer reporter\n\nand \nprovider installer reporter\n\n\nINFO  [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins =\n\n    Set<PluginInterface>\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1)\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2)\n\n    Map<DummyPluginKey, PluginInterface>\n        ONE        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1)\n        TWO        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2)",
            "title": "Installers"
        },
        {
            "location": "/guide/installers/#installers",
            "text": "Installer is a core integration concept: every extension point has it's own installer. Installers used for both  auto scan  and manual modes\n(the only difference is in manual mode classes specified manually).\nInstallers itself are resolved using classpath scanning, so it's very easy to add custom installers (and possibly override default one by disabling it and registering alternative).  All default installers are registered by  CoreInstallersBundle",
            "title": "Installers"
        },
        {
            "location": "/guide/installers/#how-it-works",
            "text": "When installer recognize class, it binds it into guice  binder.bind(foundClass)  (or bind by installer if it  support binding ).\nBut extensions annotated with  @LazyBinding  are not bound to guice context. This may be useful to  delay bean creation :\nby default, guice production stage will instantiate all registered beans.  On run phase (after injector created) all found or manually provided extensions are installed by type or instantiated ( injector.getInstance(foundClass) ) and passed to installer \nto register extension within dropwizard (installation type is defined by installer).  Installers are  ordered .   Each extension is installed by only one installer!  If extension could be recognized by more then one installers, it will be installed only by first \nmatching installer (according to installers order).",
            "title": "How it works"
        },
        {
            "location": "/guide/installers/#writing-custom-installer",
            "text": "Installer should implement  FeatureInstaller \ninterface. It will be automatically registered if auto scan is enabled. To register manually use  .installers()  bundle option.  Installer  matches  method implements feature detection logic. You can use  FeatureUtils  for type checks, because it's denies\nabstract classes. Method is called for classes found during scan to detect installable features and for classes directly specified\nwith  .extensions()  bundle option to detect installer.  Three types of installation supported. Installer should implement one or more of these interfaces:   BindingInstaller  allows custom guice bindings. If installer doesn't implement this interface sinmple  bind(type)  will be called to register in guice.  TypeInstaller  used for registration based on type (no instance created during installation).  InstanceInstaller  used for instance registration. Instance created using  injector.getInstance(type) .  JerseyInstaller  used for registration of bindings in HK context.   Note that extensions may use  @LazyBinding  annotation. In general case such extensions will not be registered in guice.\nIn case of  BindingInstaller , special hint will be passed and installer should decide how to handle it (may throw exception as not supported).  BindingInstaller  called in time of injector creation, whereas  TypeInstaller  and  InstanceInstaller  are called just after injector creation. JerseyInstaller  is called on jersey start.   Installers are not guice beans! So injections can't be used inside them. \nThis is because installers also used during initialization phase and instantiated before injector creation.   Example installer:  public   class   CustomInstaller   implements   FeatureInstaller < CustomFeature >   { \n     @Override \n     public   boolean   matches ( final   Class <?>   type )   { \n         return   FeatureUtils . is ( type ,   CustomFeature . class ); \n     }      }   Finds all CustomFeature derived classes and register them in guice (implicit registration - all classes matched by installer are registered in injector). Note that no installer interfaces were used, \nbecause guice registration is enough.  Now suppose CustomFeature is a base class for our jersey extensions. Then installer will be:  public   class   CustomInstaller   implements   FeatureInstaller < CustomFeature >,   JerseyInstaller < CustomFeature >   { \n     @Override \n     public   boolean   matches ( final   Class <?>   type )   { \n         return   FeatureUtils . is ( type ,   CustomFeature . class ); \n     } \n\n     @Override \n     public   void   install ( final   AbstractBinder   binder ,   final   Class < CustomFeature >   type )   { \n         JerseyBinding . bindComponent ( binder ,   type ); \n     } \n\n     @Override \n     public   void   report ()   { \n     }  }",
            "title": "Writing custom installer"
        },
        {
            "location": "/guide/installers/#ordering",
            "text": "In order to support  ordering , installer must implement  Ordered  interface.\nIf installer doesn't implement it extensions will not be sorted, even if extensions has  @Order  annotations.   As example, see  ManagedInstaller",
            "title": "Ordering"
        },
        {
            "location": "/guide/installers/#reporting",
            "text": "Installers  report()  method will be called after it finish installation of all found extensions. Report provides\nuser visibility of installed extensions.   To simplify reporting use predefined  Reporter  class. \nSee example usage in  ManagedInstaller  INFO  [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.support.feature.DummyManaged)  For complex cases, reporter may be extended to better handle installed extensions. As examples see  plugin installer reporter \nand  provider installer reporter  INFO  [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins =\n\n    Set<PluginInterface>\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1)\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2)\n\n    Map<DummyPluginKey, PluginInterface>\n        ONE        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1)\n        TWO        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2)",
            "title": "Reporting"
        },
        {
            "location": "/guide/ordering/",
            "text": "Ordering\n\u00b6\n\n\nGuicey \n@Order\n annotation should be used to order extensions and installers.\n\n\nGeneral\n\u00b6\n\n\nOrder is natural. For example, \n@Order(10)\n will be before \n@Order(20)\n.\n\n\nWhen no annotation present, class order set to \nInteger\n.\nMAX_VALUE\n, so\nall classes without order annotation will always goes last.\n\n\nExtensions order\n\u00b6\n\n\n\n\nNote\n\n\nNot all extensions supports ordering: look specific installer page for details.\nFor example, managed, lifecycle, servlets and filters installers support order.\n\n\n\n\n\n\nTip\n\n\nInstallers supporting ordering implement \nOrdered\n interface.\n\n\n\n\nThe most common case for ordering is ordering managed objects. For example:\n\n\n@Order\n(\n20\n)\n\n\npublic\n \nclass\n \nManaged1\n \nimplements\n \nManaged\n \n{\n \n...\n \n}\n\n\n\n@Order\n(\n10\n)\n\n\npublic\n \nclass\n \nManaged2\n \nimplements\n \nManaged\n \n{\n \n...\n \n}\n\n\n\npublic\n \nclass\n \nManaged3\n \nimplements\n \nManaged\n \n{\n \n...\n \n}\n\n\n\n\n\n\nWill be ordered as: \nManaged2\n, \nManaged1\n, \nManaged3\n\n\n\n\nNote\n\n\nGuicey remembers extensions registration order:\n\n.\nextensions\n(\nExt1\n.\nclass\n,\n \nExt2\n.\nclass\n)\n\n\n\n\nSo when no explicit ordering defined (or for elements with the same order value)\nregistration order will be preserved.\n\n\n\n\n\n\nTip\n\n\nConsole reporters for most extensions report extensions in correct order.\nYou can use diagnostic reporting to be sure about actual extensions order. \n\n\n\n\nInstallers order\n\u00b6\n\n\nAll bundled \ninstallers\n are ordered from 0 to ~110 with gap 10 between them to let you easily\nput your installers between (if required).\n\n\nUse \n@Order\n annotation to order custom installer, otherwise it will go after all\ndefault installers.\n\n\nBundles order\n\u00b6\n\n\n\n\nAttention\n\n\nGuicey bundles does not support ordering.\n\n\n\n\nIt makes no sense to order \nguicey bundles\n because they simply register other extensions and installers.\nYou can always order installers and extensions registered by bundles.\n\n\nMoreover, bundles are transitive, so it would be extremely hard to understand actual order:\nfor example, when bundle registered both transitively and manually.\n\n\nThere are implicit order of bundle processing:\n\n\n\n\nManually registered bundles (including transitive)\n\n\nDropwizard bundles (when recognition enabled)\n\n\nBundles lookup\n\n\n\n\nBut, again, don't count on this order because, for example, bundle resolved through lookup\nmechanism could be also manually registered and so installed as manual bundle.\n\n\nModules order\n\u00b6\n\n\n\n\nAttention\n\n\nGuicey does not support modules ordering.\n\n\n\n\nIt makes no sense to order guice modules because they simply register bindings.\nAccording to guice guice: \nmodules should not contain conditional logic\n\n\nSo all that modules should do is registering bindings and order does not matter in that case.\n\n\nModules, registered directly in guice bundle, must be executed before modules, registered in bundles \n(because registration order is preserved).",
            "title": "Ordering"
        },
        {
            "location": "/guide/ordering/#ordering",
            "text": "Guicey  @Order  annotation should be used to order extensions and installers.",
            "title": "Ordering"
        },
        {
            "location": "/guide/ordering/#general",
            "text": "Order is natural. For example,  @Order(10)  will be before  @Order(20) .  When no annotation present, class order set to  Integer . MAX_VALUE , so\nall classes without order annotation will always goes last.",
            "title": "General"
        },
        {
            "location": "/guide/ordering/#extensions-order",
            "text": "Note  Not all extensions supports ordering: look specific installer page for details.\nFor example, managed, lifecycle, servlets and filters installers support order.    Tip  Installers supporting ordering implement  Ordered  interface.   The most common case for ordering is ordering managed objects. For example:  @Order ( 20 )  public   class   Managed1   implements   Managed   {   ...   }  @Order ( 10 )  public   class   Managed2   implements   Managed   {   ...   }  public   class   Managed3   implements   Managed   {   ...   }   Will be ordered as:  Managed2 ,  Managed1 ,  Managed3   Note  Guicey remembers extensions registration order: . extensions ( Ext1 . class ,   Ext2 . class )  \n\nSo when no explicit ordering defined (or for elements with the same order value)\nregistration order will be preserved.    Tip  Console reporters for most extensions report extensions in correct order.\nYou can use diagnostic reporting to be sure about actual extensions order.",
            "title": "Extensions order"
        },
        {
            "location": "/guide/ordering/#installers-order",
            "text": "All bundled  installers  are ordered from 0 to ~110 with gap 10 between them to let you easily\nput your installers between (if required).  Use  @Order  annotation to order custom installer, otherwise it will go after all\ndefault installers.",
            "title": "Installers order"
        },
        {
            "location": "/guide/ordering/#bundles-order",
            "text": "Attention  Guicey bundles does not support ordering.   It makes no sense to order  guicey bundles  because they simply register other extensions and installers.\nYou can always order installers and extensions registered by bundles.  Moreover, bundles are transitive, so it would be extremely hard to understand actual order:\nfor example, when bundle registered both transitively and manually.  There are implicit order of bundle processing:   Manually registered bundles (including transitive)  Dropwizard bundles (when recognition enabled)  Bundles lookup   But, again, don't count on this order because, for example, bundle resolved through lookup\nmechanism could be also manually registered and so installed as manual bundle.",
            "title": "Bundles order"
        },
        {
            "location": "/guide/ordering/#modules-order",
            "text": "Attention  Guicey does not support modules ordering.   It makes no sense to order guice modules because they simply register bindings.\nAccording to guice guice:  modules should not contain conditional logic  So all that modules should do is registering bindings and order does not matter in that case.  Modules, registered directly in guice bundle, must be executed before modules, registered in bundles \n(because registration order is preserved).",
            "title": "Modules order"
        },
        {
            "location": "/guide/bundles/",
            "text": "Guicey bundles\n\u00b6\n\n\nBy analogy with dropwizard bundles, guicey has it's own \nGuiceyBundle\n. These bundles contains almost the same options as \nmain \nGuiceBundle\n builder. The main purpose is to group installers, extensions and guice modules related to specific \nfeature.\n\n\nGuicey bundles are initialized during dropwizard \nrun\n phase. All guice modules registered in bundles will also be checked if \n\ndropwizard objects autowiring\n required.\n\n\nFor example, custom integration with some scheduler framework will require installers to register tasks and guice module\nto configure framework. GuiceyBundle will allow reduce integration to just one bundle installation.\n\n\npublic\n \nclass\n \nXLibIntegrationBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nfinal\n \nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nbootstrap\n.\ninstallers\n(\n\n                \nXLibFeature1Installer\n.\nclass\n,\n\n                \nXLibFeature2Installer\n.\nclass\n,\n                \n        \n)\n\n        \n.\nmodules\n(\nnew\n \nXLibGuiceModule\n());\n\n    \n}\n\n\n}\n\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundles\n(\nnew\n \nXLibIntegrationBundle\n())\n\n        \n.\nenableAutoConfig\n(\n\"package.to.scan\"\n)\n\n        \n.\nbuild\n()\n\n\n);\n\n\n\n\n\n\nBundles may be used to group application features: e.g. ResourcesBundle, TasksBundle (for example, when auto-scan not enabled to decompose configuration).\n\n\nBundles are transitive - bundle can install other bundles. \nDuplicate bundles are detected using bundle type, so infinite configuration loops or duplicate configurations are not possible.\n\n\n\n\nWarning\n\n\nBe careful if bundle is parameterizable (requires constructor arguments). If two such bundles will be registered, only\nfirst registration will be actually used and other instance ignored. Note that application configurations (using main GuiceBundle methods) \nperformed before bundles processing and so bundle instance with correct parameters could be registered there.\n\n\n\n\nTransitive bundles (or simply a lot of bundles) may cause confusion. Use \ndiagnostic info\n to see how guicey was actually configured.  \n\n\nPredefined bundles\n\u00b6\n\n\nGuicey ships with few predefined bundles.\n\n\nCore installers bundle\n\u00b6\n\n\nDefault installers are grouped into \nCoreInstallersBundle\n. This bundle is always installed implicitly (so you always have default installers).\nIt may be disabled using \n.noDefaultInstallers()\n method.\n\n\nWeb installers bundle\n\u00b6\n\n\nWebInstallersBundle\n provides installers for servlets, filters and listeners installation using servlet api annotations\n(@WebServlet, @WebFilter, @WebListener). \n\n\nBundle is not installed by default to avoid confusion. May be enabled using \n.useWebInstallers()\n. \n\n\nNOTE: If web installers used, then you may not need guice ServletModule support. To remove GuiceFilter registrations and ServletModule support use\n\n.noGuiceFilter()\n.\n\n\nHK debug bundle\n\u00b6\n\n\nHK2DebugBundle\n is special debug bundle to check that beans properly instantiated by guice or HK \n(and no beans are instantiated by both).\n\n\nOnly beans installed by installers implementing \nJerseyInstaller\n (\nResourceInstaller\n, \nJerseyProviderInstaller\n).\nAll beans must be created by guice and only beans annotated with \n@HK2Managed\n must be instantiated by HK.\n\n\nBundle may be used in tests. For example using \nguicey.bundles\n property (see bundles lookup below).\n\n\nMay be enabled by \n.strictScopeControl()\n shortcut method.\n\n\nDiagnostic bundle\n\u00b6\n\n\nBundle renders collected guicey \ndiagnostic information\n.\n\n\nOutput is highly configurable, use: \nDiagnosticBundle.builder()\n to configure reporting (if required).\n\n\nBundle may be registered with \nbundle lookup mechanism\n. For example:\n\n\nPropertyBundleLookup\n.\nenableBundles\n(\nDiagnosticBundle\n.\nclass\n);\n\n\n\n\n\n\nMay be enabled by \n.printDiagnosticInfo()\n shortcut method.\n\n\nSpecial shortcut \n.printAvailableInstallers()\n register diagnostic bundle configured for \nshowing only installers\n. Useful when you looking for available features.\n\n\n\n\nOnly one bundle instance accepted, both options can't be enabled at the same time.\n\n\n\n\nDropwizard bundles unification\n\u00b6\n\n\nGuicey bundles and dropwizard bundles may be unified providing single (standard) extension point for both \ndropwizard and guicey features.\n\n\nFeature is disabled by default, to enable it use \n.configureFromDropwizardBundles()\n method.\n\n\nbootstrap\n.\naddBundle\n(\nnew\n \nXLibBundle\n());\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nconfigureFromDropwizardBundles\n(\ntrue\n)\n\n        \n.\nbuild\n()\n\n\n);\n\n\n\n\n\n\nwhere\n\n\npublic\n \nclass\n \nXLibBundle\n \nimplements\n \nBundle\n,\n \nGuiceyBundle\n \n{\n\n    \npublic\n \nvoid\n \ninitialize\n(\nBootstrap\n<?>\n \nbootstrap\n)\n \n{...}\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n){...}\n\n    \npublic\n \nvoid\n \nrun\n(\nEnvironment\n \nenvironment\n)\n \n{...}\n\n\n}\n\n\n\n\n\n\nWhen active, all registered bundles are checked if they implement \nGuiceyBundle\n.\nAlso, works with dropwizard \nConfiguredBundle\n.\n\n\n\n\nWarning\n\n\nDon't assume if guicey bundle's \ninitialize\n method will be called before/after dropwizard bundle's \nrun\n method. \nBoth are possible (it depends if bundle registered before or after GuiceBundle).\n\n\n\n\nBundle lookup\n\u00b6\n\n\nBundle lookup mechanism used to lookup guicey bundles in various sources. It may be used to activate specific bundles\nin tests (e.g. HK2DebugBundle) or to install 3\nrd\n party extensions from classpath.\n\n\nBundle lookup is equivalent to registering bundle directly using builder \nbundles\n method.\n\n\nBy default, 2 lookup mechanisms active. All found bundles are logged into console.\nDuplicate bundles are removed (using bundle class to detect duplicate).\n\n\nTo disable default lookups use \ndisableBundleLookup\n:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\ndisableBundleLookup\n()\n\n        \n.\nbuild\n()\n\n\n\n\n\n\nSystem property lookup\n\u00b6\n\n\nSystem property \nguicey.bundles\n could contain comma separated list of guicey bundle classes. These bundles \nmust have no-args constructor.\n\n\nFor example, activate HK debug bundle for tests:\n\n\njava ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle\n\n\n\n\n\nAlternatively, system property may be set in code:\n\n\nPropertyBundleLookup\n.\nenableBundles\n(\nHK2DebugBundle\n.\nclass\n)\n\n\n\n\n\n\nService loader lookup\n\u00b6\n\n\nUsing default java \nServiceLoader\n \nmechanism, loads all GuiceyBundle services.\n\n\nThis is useful for automatically install 3\nrd\n party extensions (additional installers, extensions, guice modules).\n\n\n3\nrd\n party jar must contain services file:\n\n\nMETA-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle\n\n\n\n\n\nFile contain one or more (per line) GuiceyBundle implementations. E.g.\n\n\ncom.foo.Bundle1\ncom.foo.Bundle2\n\n\n\n\n\nThen Bundle1, Bundle2 would be loaded automatically on startup.\n\n\nCustomizing lookup mechanism\n\u00b6\n\n\nCustom bundle lookup must implement \nGuiceyBundleLookup\n interface:\n\n\npublic\n \nclass\n \nCustomBundleLookup\n \nimplements\n \nGuiceyBundleLookup\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nList\n<\nGuiceyBundle\n>\n \nlookup\n()\n \n{\n\n        \nList\n<\nGuiceyBundle\n>\n \nbundles\n \n=\n \nLists\n.\nnewArrayList\n();\n\n        \n...\n\n        \nreturn\n \nbundles\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nCustom lookup implementation may be registered through:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundleLookup\n(\nnew\n \nCustomBundleLookup\n())\n\n        \n.\nbuild\n()\n\n\n\n\n\n\nBut it's better to register it through default implementation \nDefaultBundleLookup\n, which performs composition \nof multiple lookup implementations and logs resolved bundles to console.\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundleLookup\n(\nnew\n \nDefaultBundleLookup\n().\naddLookup\n(\nnew\n \nCustomBundleLookup\n()))\n\n        \n.\nbuild\n()\n\n\n\n\n\n\nTo override list of default lookups:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundleLookup\n(\nnew\n \nDefaultBundleLookup\n(\nnew\n \nServiceLoaderBundleLookup\n(),\n \nnew\n \nCustomBundleLookup\n()))\n\n        \n.\nbuild\n()\n\n\n\n\n\n\nHere two lookup mechanisms registered (property lookup is not registered and will not be implicitly added).",
            "title": "Bundles (Guicey)"
        },
        {
            "location": "/guide/bundles/#guicey-bundles",
            "text": "By analogy with dropwizard bundles, guicey has it's own  GuiceyBundle . These bundles contains almost the same options as \nmain  GuiceBundle  builder. The main purpose is to group installers, extensions and guice modules related to specific \nfeature.  Guicey bundles are initialized during dropwizard  run  phase. All guice modules registered in bundles will also be checked if  dropwizard objects autowiring  required.  For example, custom integration with some scheduler framework will require installers to register tasks and guice module\nto configure framework. GuiceyBundle will allow reduce integration to just one bundle installation.  public   class   XLibIntegrationBundle   implements   GuiceyBundle   { \n\n     @Override \n     public   void   initialize ( final   GuiceyBootstrap   bootstrap )   { \n         bootstrap . installers ( \n                 XLibFeature1Installer . class , \n                 XLibFeature2Installer . class ,                 \n         ) \n         . modules ( new   XLibGuiceModule ()); \n     }  }  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundles ( new   XLibIntegrationBundle ()) \n         . enableAutoConfig ( \"package.to.scan\" ) \n         . build ()  );   Bundles may be used to group application features: e.g. ResourcesBundle, TasksBundle (for example, when auto-scan not enabled to decompose configuration).  Bundles are transitive - bundle can install other bundles. \nDuplicate bundles are detected using bundle type, so infinite configuration loops or duplicate configurations are not possible.   Warning  Be careful if bundle is parameterizable (requires constructor arguments). If two such bundles will be registered, only\nfirst registration will be actually used and other instance ignored. Note that application configurations (using main GuiceBundle methods) \nperformed before bundles processing and so bundle instance with correct parameters could be registered there.   Transitive bundles (or simply a lot of bundles) may cause confusion. Use  diagnostic info  to see how guicey was actually configured.",
            "title": "Guicey bundles"
        },
        {
            "location": "/guide/bundles/#predefined-bundles",
            "text": "Guicey ships with few predefined bundles.",
            "title": "Predefined bundles"
        },
        {
            "location": "/guide/bundles/#core-installers-bundle",
            "text": "Default installers are grouped into  CoreInstallersBundle . This bundle is always installed implicitly (so you always have default installers).\nIt may be disabled using  .noDefaultInstallers()  method.",
            "title": "Core installers bundle"
        },
        {
            "location": "/guide/bundles/#web-installers-bundle",
            "text": "WebInstallersBundle  provides installers for servlets, filters and listeners installation using servlet api annotations\n(@WebServlet, @WebFilter, @WebListener).   Bundle is not installed by default to avoid confusion. May be enabled using  .useWebInstallers() .   NOTE: If web installers used, then you may not need guice ServletModule support. To remove GuiceFilter registrations and ServletModule support use .noGuiceFilter() .",
            "title": "Web installers bundle"
        },
        {
            "location": "/guide/bundles/#hk-debug-bundle",
            "text": "HK2DebugBundle  is special debug bundle to check that beans properly instantiated by guice or HK \n(and no beans are instantiated by both).  Only beans installed by installers implementing  JerseyInstaller  ( ResourceInstaller ,  JerseyProviderInstaller ).\nAll beans must be created by guice and only beans annotated with  @HK2Managed  must be instantiated by HK.  Bundle may be used in tests. For example using  guicey.bundles  property (see bundles lookup below).  May be enabled by  .strictScopeControl()  shortcut method.",
            "title": "HK debug bundle"
        },
        {
            "location": "/guide/bundles/#diagnostic-bundle",
            "text": "Bundle renders collected guicey  diagnostic information .  Output is highly configurable, use:  DiagnosticBundle.builder()  to configure reporting (if required).  Bundle may be registered with  bundle lookup mechanism . For example:  PropertyBundleLookup . enableBundles ( DiagnosticBundle . class );   May be enabled by  .printDiagnosticInfo()  shortcut method.  Special shortcut  .printAvailableInstallers()  register diagnostic bundle configured for  showing only installers . Useful when you looking for available features.   Only one bundle instance accepted, both options can't be enabled at the same time.",
            "title": "Diagnostic bundle"
        },
        {
            "location": "/guide/bundles/#dropwizard-bundles-unification",
            "text": "Guicey bundles and dropwizard bundles may be unified providing single (standard) extension point for both \ndropwizard and guicey features.  Feature is disabled by default, to enable it use  .configureFromDropwizardBundles()  method.  bootstrap . addBundle ( new   XLibBundle ());  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . configureFromDropwizardBundles ( true ) \n         . build ()  );   where  public   class   XLibBundle   implements   Bundle ,   GuiceyBundle   { \n     public   void   initialize ( Bootstrap <?>   bootstrap )   {...} \n     public   void   initialize ( GuiceyBootstrap   bootstrap ){...} \n     public   void   run ( Environment   environment )   {...}  }   When active, all registered bundles are checked if they implement  GuiceyBundle .\nAlso, works with dropwizard  ConfiguredBundle .   Warning  Don't assume if guicey bundle's  initialize  method will be called before/after dropwizard bundle's  run  method. \nBoth are possible (it depends if bundle registered before or after GuiceBundle).",
            "title": "Dropwizard bundles unification"
        },
        {
            "location": "/guide/bundles/#bundle-lookup",
            "text": "Bundle lookup mechanism used to lookup guicey bundles in various sources. It may be used to activate specific bundles\nin tests (e.g. HK2DebugBundle) or to install 3 rd  party extensions from classpath.  Bundle lookup is equivalent to registering bundle directly using builder  bundles  method.  By default, 2 lookup mechanisms active. All found bundles are logged into console.\nDuplicate bundles are removed (using bundle class to detect duplicate).  To disable default lookups use  disableBundleLookup :  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . disableBundleLookup () \n         . build ()",
            "title": "Bundle lookup"
        },
        {
            "location": "/guide/bundles/#system-property-lookup",
            "text": "System property  guicey.bundles  could contain comma separated list of guicey bundle classes. These bundles \nmust have no-args constructor.  For example, activate HK debug bundle for tests:  java ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle  Alternatively, system property may be set in code:  PropertyBundleLookup . enableBundles ( HK2DebugBundle . class )",
            "title": "System property lookup"
        },
        {
            "location": "/guide/bundles/#service-loader-lookup",
            "text": "Using default java  ServiceLoader  \nmechanism, loads all GuiceyBundle services.  This is useful for automatically install 3 rd  party extensions (additional installers, extensions, guice modules).  3 rd  party jar must contain services file:  META-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle  File contain one or more (per line) GuiceyBundle implementations. E.g.  com.foo.Bundle1\ncom.foo.Bundle2  Then Bundle1, Bundle2 would be loaded automatically on startup.",
            "title": "Service loader lookup"
        },
        {
            "location": "/guide/bundles/#customizing-lookup-mechanism",
            "text": "Custom bundle lookup must implement  GuiceyBundleLookup  interface:  public   class   CustomBundleLookup   implements   GuiceyBundleLookup   { \n\n     @Override \n     public   List < GuiceyBundle >   lookup ()   { \n         List < GuiceyBundle >   bundles   =   Lists . newArrayList (); \n         ... \n         return   bundles ; \n     }  }   Custom lookup implementation may be registered through:  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundleLookup ( new   CustomBundleLookup ()) \n         . build ()   But it's better to register it through default implementation  DefaultBundleLookup , which performs composition \nof multiple lookup implementations and logs resolved bundles to console.  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundleLookup ( new   DefaultBundleLookup (). addLookup ( new   CustomBundleLookup ())) \n         . build ()   To override list of default lookups:  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundleLookup ( new   DefaultBundleLookup ( new   ServiceLoaderBundleLookup (),   new   CustomBundleLookup ())) \n         . build ()   Here two lookup mechanisms registered (property lookup is not registered and will not be implicitly added).",
            "title": "Customizing lookup mechanism"
        },
        {
            "location": "/guide/options/",
            "text": "Options\n\u00b6\n\n\nOptions are low level configurations. In contrast to dropwizard configuration (file), which is user specific,\noptions are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours.\n\n\nOptions are declared with enums. Enums used to naturally group options (also cause pretty reporting). \nEnums must implement Option interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum),\nbut provides required option info).\n\n\nGuicey use options to allow other part to know guice bundle configurations (configured packages to scan, search commands enabling etc) through \nGuiceyOptions\n enum\n(for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle).\nAnother use is in web installers to change default behaviour though \nInstallersOptions\n enum. \n\n\nCustom options may be defined for 3\nrd\n party bundle or even application. Options is a general mechanism providing configuration and access points with \nstandard reporting (part of diagnostic reporting). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize\napplication state in tests (just to name a few).\n\n\nUsage\n\u00b6\n\n\nOptions may be set only in main GuiceBundle using \n.option\n method. This is important to let configuration parts to see the same values.\nFor example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and,\nfor sure, this will eventually lead to inconsistent behaviour.\n\n\nOption could not be set to null. Option could be null only if it's default value is null and custom value not set.\nCustom option value is checked for compatibility with option type (from option definition) and error thrown if does not match.\nOf course, type checking is limited to top class and generics are ignored (so List\n could not be specified and so\ncan't be checked), but it's a compromise between complexity and easy of use (the same as Enum & Option pair).\n\n\nOptions could be accessed by:\n\n\n\n\nGuicey bundles using \nbootstrap.option()\n method\n\n\nInstaller by implementing \nWithOptions\n interface (or extend \nInstallerOptionsSupport\n)\n\n\nAny guice bean could inject \nOptions\n bean and use it to access options.\n\n\n\n\nGuicey tracks options definition and usage and report all used options as part of \ndiagnostic reporting\n.\nPay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options.\n\n\nActual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used.\nTry to consume options closer to actual usage to let user be aware if option not used with current configuration. For example,\nGuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used.\n\n\nCustom options\n\u00b6\n\n\nOptions must be enum and implement Option interface, like this:\n\n\nenum\n \nMyOptions\n \nimplements\n \nOption\n \n{\n\n\n    \nDoExtraWork\n(\nBoolean\n,\n \ntrue\n),\n\n    \nEnableDebug\n(\nBoolean\n,\n \nfalse\n),\n\n    \nInternalConfig\n(\nString\n[],\n \nnew\n \nString\n[]{\n\"one\"\n,\n \n\"two\"\n,\n \n\"three\"\n});\n\n\n    \nprivate\n \nClass\n \ntype\n\n    \nprivate\n \nObject\n \nvalue\n\n\n    \n// generic used only to check type - value correctness\n\n    \n<\nT\n>\n \nSampleOptions\n(\nClass\n<\nT\n>\n \ntype\n,\n \nT\n \nvalue\n)\n \n{\n\n        \nthis\n.\ntype\n \n=\n \ntype\n\n        \nthis\n.\nvalue\n \n=\n \nvalue\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nClass\n \ngetType\n()\n \n{\n\n        \nreturn\n \ntype\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nObject\n \ngetDefaultValue\n()\n \n{\n\n        \nreturn\n \nvalue\n\n    \n}\n\n\n}\n\n\n\n\n\n\nEach enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value.\nThis will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []).\n\n\nNow you can use option, for example, in bean:\n\n\nimport static\n \nMyOptions.DoExtraWork\n;\n\n\n\npublic\n \nclass\n \nMyBean\n \n{\n\n    \n@Inject\n \nOptions\n \noptions\n;\n\n\n    \npulic\n \nvoid\n \nsomeMethod\n()\n \n{\n\n        \n...\n \n        \nif\n \n(\noptions\n.\nget\n(\nDoExtraWork\n))\n \n{\n\n            \n// extra work impl\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTo provide custom option value:\n\n\n    \nGuiceBundle\n.\nbuilder\n()\n\n        \n.\noption\n(\nDoExtraWork\n,\n \nfalse\n)\n\n        \n...\n\n\n\n\n\n\nOptions lookup\n\u00b6\n\n\nThere is no lookup mechanism implementation, provided by default (for example, like \nbundles lookup mechanism\n)\nbecause it's hard to do universal implementation considering wide range of possible values.\n\n\nBut you can write your own lookup, simplified for your case.\n\n\nIf you do, you can use \n.options(Map<Enum, Object>)\n method to set resolved options (note that contract simplified for just\nEnum, excluding Option for simpler usage, but still only option enums must be provided).\n\n\n    \nGuiceBundle\n.\nbuilder\n()\n\n        \n.\noptions\n(\nnew\n \nMyOptionsLookup\n().\ngetOptions\n())\n\n        \n...\n\n\n\n\n\n\nSuch mechanism could be used, for example, to change application options in tests or to apply environment specific options.",
            "title": "Options"
        },
        {
            "location": "/guide/options/#options",
            "text": "Options are low level configurations. In contrast to dropwizard configuration (file), which is user specific,\noptions are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours.  Options are declared with enums. Enums used to naturally group options (also cause pretty reporting). \nEnums must implement Option interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum),\nbut provides required option info).  Guicey use options to allow other part to know guice bundle configurations (configured packages to scan, search commands enabling etc) through  GuiceyOptions  enum\n(for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle).\nAnother use is in web installers to change default behaviour though  InstallersOptions  enum.   Custom options may be defined for 3 rd  party bundle or even application. Options is a general mechanism providing configuration and access points with \nstandard reporting (part of diagnostic reporting). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize\napplication state in tests (just to name a few).",
            "title": "Options"
        },
        {
            "location": "/guide/options/#usage",
            "text": "Options may be set only in main GuiceBundle using  .option  method. This is important to let configuration parts to see the same values.\nFor example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and,\nfor sure, this will eventually lead to inconsistent behaviour.  Option could not be set to null. Option could be null only if it's default value is null and custom value not set.\nCustom option value is checked for compatibility with option type (from option definition) and error thrown if does not match.\nOf course, type checking is limited to top class and generics are ignored (so List  could not be specified and so\ncan't be checked), but it's a compromise between complexity and easy of use (the same as Enum & Option pair).  Options could be accessed by:   Guicey bundles using  bootstrap.option()  method  Installer by implementing  WithOptions  interface (or extend  InstallerOptionsSupport )  Any guice bean could inject  Options  bean and use it to access options.   Guicey tracks options definition and usage and report all used options as part of  diagnostic reporting .\nPay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options.  Actual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used.\nTry to consume options closer to actual usage to let user be aware if option not used with current configuration. For example,\nGuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used.",
            "title": "Usage"
        },
        {
            "location": "/guide/options/#custom-options",
            "text": "Options must be enum and implement Option interface, like this:  enum   MyOptions   implements   Option   { \n\n     DoExtraWork ( Boolean ,   true ), \n     EnableDebug ( Boolean ,   false ), \n     InternalConfig ( String [],   new   String []{ \"one\" ,   \"two\" ,   \"three\" }); \n\n     private   Class   type \n     private   Object   value \n\n     // generic used only to check type - value correctness \n     < T >   SampleOptions ( Class < T >   type ,   T   value )   { \n         this . type   =   type \n         this . value   =   value \n     } \n\n     @Override \n     public   Class   getType ()   { \n         return   type \n     } \n\n     @Override \n     public   Object   getDefaultValue ()   { \n         return   value \n     }  }   Each enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value.\nThis will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []).  Now you can use option, for example, in bean:  import static   MyOptions.DoExtraWork ;  public   class   MyBean   { \n     @Inject   Options   options ; \n\n     pulic   void   someMethod ()   { \n         ...  \n         if   ( options . get ( DoExtraWork ))   { \n             // extra work impl \n         } \n     }  }   To provide custom option value:       GuiceBundle . builder () \n         . option ( DoExtraWork ,   false ) \n         ...",
            "title": "Custom options"
        },
        {
            "location": "/guide/options/#options-lookup",
            "text": "There is no lookup mechanism implementation, provided by default (for example, like  bundles lookup mechanism )\nbecause it's hard to do universal implementation considering wide range of possible values.  But you can write your own lookup, simplified for your case.  If you do, you can use  .options(Map<Enum, Object>)  method to set resolved options (note that contract simplified for just\nEnum, excluding Option for simpler usage, but still only option enums must be provided).       GuiceBundle . builder () \n         . options ( new   MyOptionsLookup (). getOptions ()) \n         ...   Such mechanism could be used, for example, to change application options in tests or to apply environment specific options.",
            "title": "Options lookup"
        },
        {
            "location": "/guide/diagnostic/",
            "text": "Diagnostic info\n\u00b6\n\n\nDuring startup guicey records startup metrics and remembers all details of configuration process. \nAll this information is available through \nGuiceyConfigurationInfo\n bean in guice context.\n\n\nDiagnostic service\n\u00b6\n\n\nDefault diagnostic info rendering is provided to assist configuration problems resolution and better guicey internals understanding.\n\n\nThe simplest way to enable diagnostic reporting is using bundle \n.printDiagnosticInfo()\n option. \nThis registers \nDiagnosticBundle\n with default reporting configuration. \nBundle could be registered directly in order to customize output.\n\n\nWhen \n.printDiagnosticInfo()\n enabled, the following kind of logs will be printed after server startup:\n\n\nINFO  [2016-08-01 21:22:50,898] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Startup stats = \n\n    GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    \u2502   \n    \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms\n    \u2502   \n    \u251c\u2500\u2500 [1,3%] HK bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs\n    \u2502   \n    \u2514\u2500\u2500 [1,1%] remaining 5 ms\n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Options = \n\n    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]                 \n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN, GUICE_ENABLED\n\n\n    BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP\n\n\n    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n\n\n    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceSupportModule           (r.v.d.guice.module)       \n\nINFO  [2016-08-01 21:22:50,909] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceSupportModule           (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n    \u2502       \u2514\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     *IGNORED\n    \u2502   \n    \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n    \u2502   \u251c\u2500\u2500 extension  HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n    \u2502   \u2514\u2500\u2500 module     HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n    \u2502   \n    \u251c\u2500\u2500 DiagnosticBundle             (r.v.d.g.m.c.debug)        \n    \u2502   \u2514\u2500\u2500 module     DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n    \u2502   \n    \u251c\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     *IGNORED\n    \u2502   \u2514\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n    \u2502   \n    \u251c\u2500\u2500 BUNDLES LOOKUP\n    \u2502   \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        *IGNORED\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n    \u2502       \u2514\u2500\u2500 module     GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n    \u2502   \n    \u2514\u2500\u2500 CLASSPATH SCAN\n        \u2514\u2500\u2500 extension  FooResource                  (r.v.d.g.d.s.features)  \n\n\n\n\n\nDefault reporting contains 4 sections:\n\n\n\n\nHow guicey spent time\n\n\nWhat options used\n\n\nWhat was configured\n\n\nFrom where configuration items come from\n\n\n\n\nTimings\n\u00b6\n\n\nStartup timings\n\u00b6\n\n\n    GUICEY started in 453.3 ms\n\n\n\n\n\nOverall guicey time measured: GuiceBundle methods plus part of Hk configuration time (hk started after bundle).\nAll items below represent guicey time detalization. Items always detail time of direct parent.\n\n\nMost of this time actually spent on class loading. For example, report above represent \ntest\n direct execution. \nBut when this test executed as part of suit time become  \nGUICEY started in 52.95 ms\n because most classes were pre-loaded by other tests.\n\n\nClasspath scan\n\u00b6\n\n\n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n\n\n\n\n\nClasspath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions. \n\n\nscanned 5 classes\n means that 5 classed were found (overall) in configured packages. \nrecognized 4 classes\n Show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command).\n\n\nNOTE: classpath scan time will be obviously bigger for larger classes count. But most of this time are actually class loading time. If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time move to other some place (for example, to injector creation). \n\n\nCommands\n\u00b6\n\n\n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n\n\n\n\n\nCommands time includes time spent on commands search (in classes from classpath scan; if enabled .searchCommands()) and calling .injectMemebers on configured environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled)\n\n\nBundles\n\u00b6\n\n\n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n\n\n\n\n\nBundles time includes bundles lookup time (if not .disableBundleLookup()), dropwizard bunles lookup (if .configureFromDropwizardBundles()) and bundles execution.\n\n\n2 resolved in 8.149 ms\n indicated bundles resolved with guicey bundle lookup or from dropwizard bundles.\n\n6 processed\n - overall processed bundles (all registered bundles, including just resolved).\n\n\nInjector\n\u00b6\n\n\n    \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms\n\n\n\n\n\nAll installers and extensions operations (except jersey related features) performed inside of guice module and so included into overall injector creation time.\n\n\ninstallers prepared in 13.79 ms\n include installers search in classpath (if scan enabled), instantiation and preparing for usage (remove duplicates, sort).\n\n\nextensions recognized in 9.259 ms\n - all manually configured extensions and all classes from classpath scan (\nfrom 7 classes\n) are recognized by all registered installers (\nusing 11 installers\n) using installer match method. Recognized installers bound to guice context (or custom action performed for binding installers).\n\n\n3 extensions installed in 4.188 ms\n - all recognized extensions are installed with installers install methods.\n\n\n\n\nNote\n\n\nMost time of injector creation is internal guice logic. You can enable guice logs to see more details (see below)\n\n\n\n\nHK\n\u00b6\n\n\n    \u251c\u2500\u2500 [1,3%] HK bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs\n\n\n\n\n\nJersey starts after dropwizard bundles processing and so after GuiceBundle execution. This time is tracked as (overall) guicey time. Here guicey register required HK bindings and (some hk beans in guice) and executes jersey installers (installers implement JerseyInstaller) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires hk specific bindings).\n\n\nNote that installation time (\n2 jersey extensions installed in 660.9 \u03bcs\n) is so tiny just because empty resources (without methods) were used. In real application installation time will be bigger.\n\n\nRemaining\n\u00b6\n\n\n    \u2514\u2500\u2500 [1,1%] remaining 5 ms\n\n\n\n\n\nRepresent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown.\n\n\nUsed options\n\u00b6\n\n\nShows all set or requested (by application logic) options. If you use your own options here they will also be printed.\n\n\n    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]     \n\n\n\n\n\nUsed markers:\n* CUSTOM - option value set by user\n* NOT_USED - option was set by user but never used\n\n\nNot used marker just indicated that option is \"not yet\" used. Options may be consumed lazilly by application logic, so\nit is possible that its not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario).\n\n\nConfiguration diagnostic info\n\u00b6\n\n\nSection intended to compactly show all configuration (to quickly see what was configured).\n\n\nThis and the next sections used condensed package notion:\n\n\nCoreInstallersBundle         (r.v.d.g.m.installer)    \n\n\n\n\n\nAssumed that all classes in application will be uniquely identifiable by name and package info shown just to be able to \nunderstand exact class location. Logback shrinker used.\n\n\nReport also indicates duplicate registrations by REG(N) marker, where N - amount of installations \n(ignored installations will be visible in configuration tree). Counted:\n\n\n\n\nitem registration in different places (e.g. different bundles)\n\n\nduplicate registrations in simgle place (e.g. \n.extensions(MyExt.class, MyExt.class)\n)\n\n\n\n\nGeneral\n\u00b6\n\n\nAll configuration items (commands, modules, installers, extension, bundles) are identified by class. Duplicate entities are not allowed and simply ignored.\n\n\nFor example, if extension registered manually and by classpath scan then it will be registered once, but internally guicey will remember both configuration sources.\n\n\nIn contrast to other items, bundles and modules are registered by instance, but still uniqueness is checked by type: only first instance registered and other instances considered as duplicate.\n\n\nCommands\n\u00b6\n\n\n    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN,GUICE_ENABLED\n\n\n\n\n\nShows commands resolved with classpath scan (enabled with .searchCommands()).\n\n\nThe following markers used:\n\n\n\n\nSCAN - item from classpath scan (always)\n\n\nGUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts)\n\n\n\n\nBundles\n\u00b6\n\n\n    BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP\n\n\n\n\n\nAll registered bundles are shown as a tree (to indicate transitive bundles).\n\n\nThe following markers used:\n\n\n\n\nLOOKUP - bundle resolved with bundle lookup mechanism\n\n\nDW - bundle recognized from registered dropwizard bundle\n\n\n\n\nInstallers and extensions\n\u00b6\n\n\n    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n\n\n\n\n\nShows used installers (only installers which install extensions) and installed extensions. \n\n\nBoth installers and extensions are shown in the processing order (sorted according to @Order annotations).\n\n\nThe following markers used:\n\n\n\n\nSCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan)\n\n\nLAZY - extensions annotated with @LazyBinding\n\n\nHK - extension annotated with @HK2Managed\n\n\n\n\nModules\n\u00b6\n\n\n    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceSupportModule           (r.v.d.guice.module)  \n\n\n\n\n\nAll registered guice modules.\n\n\nConfiguration context tree\n\u00b6\n\n\nConfiguration tree is useful to understand from where configuration items come from.\n\n\nInstaller disables are shown like:\n\n\n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature) \n\n\n\n\n\nDuplicate registrations (ignored by guicey) are shown like:\n\n\n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n\n\n\n\n\nIf number in configuration report (e.g.REG(3)) doesn't match registration appearances, then item registered\nmultiple times in one of this places.\n\n\nNote that CoreInstallersBundle are always below all other bundles. This is because it always registered last \n(to be able to disable it's registration). It doesn't affect anything other than reporting (because bundles order does \nnot change anything except this tree).\n\n\nRe-using\n\u00b6\n\n\nDiagnostic info rendering may be used for custom rendering (showing in web page or some other staff).\nRendering is performed with 3 beans, available for injection (when bundle registered):\n\n\n\n\nStatsRenderer\n\n\nOptionsRenderer\n\n\nDiagnosticRenderer\n\n\nContextTreeRenderer\n \n\n\n\n\nInstallers mode\n\u00b6\n\n\nThere is a special option in GuiceBundle \n.printAvailableInstallers()\n for printing only installers information. \nIt also use DiagnosticBundle, but with different configuration. \n\n\n\n\nWarning\n\n\nBoth options can't be used together (but it should never be required as they serve different purposes).\n\n\n\n\nExample output:\n\n\nINFO  [2016-08-22 00:49:33,557] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    INSTALLERS in processing order = \n        lifecycle            (r.v.d.g.m.i.f.LifeCycleInstaller)     \n        managed              (r.v.d.g.m.i.feature.ManagedInstaller) \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) \n        jerseyprovider       (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n        eagersingleton       (r.v.d.g.m.i.f.e.EagerSingletonInstaller) \n        healthcheck          (r.v.d.g.m.i.f.h.HealthCheckInstaller) \n        task                 (r.v.d.g.m.i.feature.TaskInstaller)    \n        plugin               (r.v.d.g.m.i.f.plugin.PluginInstaller) \n        webservlet           (r.v.d.g.m.i.f.w.WebServletInstaller)  \n        webfilter            (r.v.d.g.m.i.f.web.WebFilterInstaller) \n        weblistener          (r.v.d.g.m.i.f.w.l.WebListenerInstaller) \n\nINFO  [2016-08-22 00:49:33,563] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u2502   \n    \u251c\u2500\u2500 WebInstallersBundle          (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  WebFilterInstaller           (r.v.d.g.m.i.f.web)        \n    \u2502   \u251c\u2500\u2500 installer  WebServletInstaller          (r.v.d.g.m.i.f.web)        \n    \u2502   \u2514\u2500\u2500 installer  WebListenerInstaller         (r.v.d.g.m.i.f.w.listener) \n    \u2502   \n    \u2514\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n        \u251c\u2500\u2500 installer  LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  ManagedInstaller             (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  JerseyProviderInstaller      (r.v.d.g.m.i.f.j.provider) \n        \u251c\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  EagerSingletonInstaller      (r.v.d.g.m.i.f.eager)      \n        \u251c\u2500\u2500 installer  HealthCheckInstaller         (r.v.d.g.m.i.f.health)     \n        \u251c\u2500\u2500 installer  TaskInstaller                (r.v.d.g.m.i.feature)      \n        \u2514\u2500\u2500 installer  PluginInstaller              (r.v.d.g.m.i.f.plugin)     \n\n\n\n\n\nComparing to complete diagnostic, it shows all installers (even not used). In diagnostic reporting not used installers are hidden, because usually it means they are not needed.\n\n\nGuice injector creation timings\n\u00b6\n\n\nYou will see in guicey timings that almost all time spent creating guice injector. \nTo see some guice internal timings enable guice debug logs:\n\n\nlogging:\n  loggers:\n    com.google.inject.internal.util: DEBUG\n\n\n\n\n\nLogs will be something like this:\n\n\nDEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Module execution: 272ms\nDEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Interceptors creation: 1ms\nDEBUG [2016-08-03 21:09:45,965] com.google.inject.internal.util.Stopwatch: TypeListeners & ProvisionListener creation: 2ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Scopes creation: 1ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Converters creation: 0ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Binding creation: 26ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Module annotated method scanners creation: 0ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Private environment creation: 1ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Injector construction: 0ms\nDEBUG [2016-08-03 21:09:46,170] com.google.inject.internal.util.Stopwatch: Binding initialization: 177ms\nDEBUG [2016-08-03 21:09:46,171] com.google.inject.internal.util.Stopwatch: Binding indexing: 1ms\nDEBUG [2016-08-03 21:09:46,172] com.google.inject.internal.util.Stopwatch: Collecting injection requests: 1ms\nDEBUG [2016-08-03 21:09:46,179] com.google.inject.internal.util.Stopwatch: Binding validation: 7ms\nDEBUG [2016-08-03 21:09:46,183] com.google.inject.internal.util.Stopwatch: Static validation: 4ms\nDEBUG [2016-08-03 21:09:46,191] com.google.inject.internal.util.Stopwatch: Instance member validation: 8ms\nDEBUG [2016-08-03 21:09:46,192] com.google.inject.internal.util.Stopwatch: Provider verification: 1ms\nDEBUG [2016-08-03 21:09:46,201] com.google.inject.internal.util.Stopwatch: Static member injection: 9ms\nDEBUG [2016-08-03 21:09:46,204] com.google.inject.internal.util.Stopwatch: Instance injection: 3ms\nDEBUG [2016-08-03 21:09:46,427] com.google.inject.internal.util.Stopwatch: Preloading singletons: 223ms\n\n\n\n\n\n\n\nNote\n\n\n'Preloading singletons' line will be logged \nlong after\n other guice log messages, so search it at the end of your startup log.",
            "title": "Diagnostic"
        },
        {
            "location": "/guide/diagnostic/#diagnostic-info",
            "text": "During startup guicey records startup metrics and remembers all details of configuration process. \nAll this information is available through  GuiceyConfigurationInfo  bean in guice context.",
            "title": "Diagnostic info"
        },
        {
            "location": "/guide/diagnostic/#diagnostic-service",
            "text": "Default diagnostic info rendering is provided to assist configuration problems resolution and better guicey internals understanding.  The simplest way to enable diagnostic reporting is using bundle  .printDiagnosticInfo()  option. \nThis registers  DiagnosticBundle  with default reporting configuration. \nBundle could be registered directly in order to customize output.  When  .printDiagnosticInfo()  enabled, the following kind of logs will be printed after server startup:  INFO  [2016-08-01 21:22:50,898] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Startup stats = \n\n    GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    \u2502   \n    \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms\n    \u2502   \n    \u251c\u2500\u2500 [1,3%] HK bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs\n    \u2502   \n    \u2514\u2500\u2500 [1,1%] remaining 5 ms\n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Options = \n\n    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]                 \n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN, GUICE_ENABLED\n\n\n    BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP\n\n\n    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n\n\n    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceSupportModule           (r.v.d.guice.module)       \n\nINFO  [2016-08-01 21:22:50,909] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceSupportModule           (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n    \u2502       \u2514\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     *IGNORED\n    \u2502   \n    \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n    \u2502   \u251c\u2500\u2500 extension  HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n    \u2502   \u2514\u2500\u2500 module     HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n    \u2502   \n    \u251c\u2500\u2500 DiagnosticBundle             (r.v.d.g.m.c.debug)        \n    \u2502   \u2514\u2500\u2500 module     DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n    \u2502   \n    \u251c\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     *IGNORED\n    \u2502   \u2514\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n    \u2502   \n    \u251c\u2500\u2500 BUNDLES LOOKUP\n    \u2502   \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        *IGNORED\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n    \u2502       \u2514\u2500\u2500 module     GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n    \u2502   \n    \u2514\u2500\u2500 CLASSPATH SCAN\n        \u2514\u2500\u2500 extension  FooResource                  (r.v.d.g.d.s.features)    Default reporting contains 4 sections:   How guicey spent time  What options used  What was configured  From where configuration items come from",
            "title": "Diagnostic service"
        },
        {
            "location": "/guide/diagnostic/#timings",
            "text": "",
            "title": "Timings"
        },
        {
            "location": "/guide/diagnostic/#startup-timings",
            "text": "GUICEY started in 453.3 ms  Overall guicey time measured: GuiceBundle methods plus part of Hk configuration time (hk started after bundle).\nAll items below represent guicey time detalization. Items always detail time of direct parent.  Most of this time actually spent on class loading. For example, report above represent  test  direct execution. \nBut when this test executed as part of suit time become   GUICEY started in 52.95 ms  because most classes were pre-loaded by other tests.",
            "title": "Startup timings"
        },
        {
            "location": "/guide/diagnostic/#classpath-scan",
            "text": "\u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)  Classpath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions.   scanned 5 classes  means that 5 classed were found (overall) in configured packages.  recognized 4 classes  Show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command).  NOTE: classpath scan time will be obviously bigger for larger classes count. But most of this time are actually class loading time. If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time move to other some place (for example, to injector creation).",
            "title": "Classpath scan"
        },
        {
            "location": "/guide/diagnostic/#commands",
            "text": "\u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands  Commands time includes time spent on commands search (in classes from classpath scan; if enabled .searchCommands()) and calling .injectMemebers on configured environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled)",
            "title": "Commands"
        },
        {
            "location": "/guide/diagnostic/#bundles",
            "text": "\u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed  Bundles time includes bundles lookup time (if not .disableBundleLookup()), dropwizard bunles lookup (if .configureFromDropwizardBundles()) and bundles execution.  2 resolved in 8.149 ms  indicated bundles resolved with guicey bundle lookup or from dropwizard bundles. 6 processed  - overall processed bundles (all registered bundles, including just resolved).",
            "title": "Bundles"
        },
        {
            "location": "/guide/diagnostic/#injector",
            "text": "\u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms  All installers and extensions operations (except jersey related features) performed inside of guice module and so included into overall injector creation time.  installers prepared in 13.79 ms  include installers search in classpath (if scan enabled), instantiation and preparing for usage (remove duplicates, sort).  extensions recognized in 9.259 ms  - all manually configured extensions and all classes from classpath scan ( from 7 classes ) are recognized by all registered installers ( using 11 installers ) using installer match method. Recognized installers bound to guice context (or custom action performed for binding installers).  3 extensions installed in 4.188 ms  - all recognized extensions are installed with installers install methods.   Note  Most time of injector creation is internal guice logic. You can enable guice logs to see more details (see below)",
            "title": "Injector"
        },
        {
            "location": "/guide/diagnostic/#hk",
            "text": "\u251c\u2500\u2500 [1,3%] HK bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs  Jersey starts after dropwizard bundles processing and so after GuiceBundle execution. This time is tracked as (overall) guicey time. Here guicey register required HK bindings and (some hk beans in guice) and executes jersey installers (installers implement JerseyInstaller) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires hk specific bindings).  Note that installation time ( 2 jersey extensions installed in 660.9 \u03bcs ) is so tiny just because empty resources (without methods) were used. In real application installation time will be bigger.",
            "title": "HK"
        },
        {
            "location": "/guide/diagnostic/#remaining",
            "text": "\u2514\u2500\u2500 [1,1%] remaining 5 ms  Represent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown.",
            "title": "Remaining"
        },
        {
            "location": "/guide/diagnostic/#used-options",
            "text": "Shows all set or requested (by application logic) options. If you use your own options here they will also be printed.      Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]       Used markers:\n* CUSTOM - option value set by user\n* NOT_USED - option was set by user but never used  Not used marker just indicated that option is \"not yet\" used. Options may be consumed lazilly by application logic, so\nit is possible that its not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario).",
            "title": "Used options"
        },
        {
            "location": "/guide/diagnostic/#configuration-diagnostic-info",
            "text": "Section intended to compactly show all configuration (to quickly see what was configured).  This and the next sections used condensed package notion:  CoreInstallersBundle         (r.v.d.g.m.installer)      Assumed that all classes in application will be uniquely identifiable by name and package info shown just to be able to \nunderstand exact class location. Logback shrinker used.  Report also indicates duplicate registrations by REG(N) marker, where N - amount of installations \n(ignored installations will be visible in configuration tree). Counted:   item registration in different places (e.g. different bundles)  duplicate registrations in simgle place (e.g.  .extensions(MyExt.class, MyExt.class) )",
            "title": "Configuration diagnostic info"
        },
        {
            "location": "/guide/diagnostic/#general",
            "text": "All configuration items (commands, modules, installers, extension, bundles) are identified by class. Duplicate entities are not allowed and simply ignored.  For example, if extension registered manually and by classpath scan then it will be registered once, but internally guicey will remember both configuration sources.  In contrast to other items, bundles and modules are registered by instance, but still uniqueness is checked by type: only first instance registered and other instances considered as duplicate.",
            "title": "General"
        },
        {
            "location": "/guide/diagnostic/#commands_1",
            "text": "COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN,GUICE_ENABLED  Shows commands resolved with classpath scan (enabled with .searchCommands()).  The following markers used:   SCAN - item from classpath scan (always)  GUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts)",
            "title": "Commands"
        },
        {
            "location": "/guide/diagnostic/#bundles_1",
            "text": "BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP  All registered bundles are shown as a tree (to indicate transitive bundles).  The following markers used:   LOOKUP - bundle resolved with bundle lookup mechanism  DW - bundle recognized from registered dropwizard bundle",
            "title": "Bundles"
        },
        {
            "location": "/guide/diagnostic/#installers-and-extensions",
            "text": "INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN  Shows used installers (only installers which install extensions) and installed extensions.   Both installers and extensions are shown in the processing order (sorted according to @Order annotations).  The following markers used:   SCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan)  LAZY - extensions annotated with @LazyBinding  HK - extension annotated with @HK2Managed",
            "title": "Installers and extensions"
        },
        {
            "location": "/guide/diagnostic/#modules",
            "text": "GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceSupportModule           (r.v.d.guice.module)    All registered guice modules.",
            "title": "Modules"
        },
        {
            "location": "/guide/diagnostic/#configuration-context-tree",
            "text": "Configuration tree is useful to understand from where configuration items come from.  Installer disables are shown like:      \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)   Duplicate registrations (ignored by guicey) are shown like:      \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED  If number in configuration report (e.g.REG(3)) doesn't match registration appearances, then item registered\nmultiple times in one of this places.  Note that CoreInstallersBundle are always below all other bundles. This is because it always registered last \n(to be able to disable it's registration). It doesn't affect anything other than reporting (because bundles order does \nnot change anything except this tree).",
            "title": "Configuration context tree"
        },
        {
            "location": "/guide/diagnostic/#re-using",
            "text": "Diagnostic info rendering may be used for custom rendering (showing in web page or some other staff).\nRendering is performed with 3 beans, available for injection (when bundle registered):   StatsRenderer  OptionsRenderer  DiagnosticRenderer  ContextTreeRenderer",
            "title": "Re-using"
        },
        {
            "location": "/guide/diagnostic/#installers-mode",
            "text": "There is a special option in GuiceBundle  .printAvailableInstallers()  for printing only installers information. \nIt also use DiagnosticBundle, but with different configuration.    Warning  Both options can't be used together (but it should never be required as they serve different purposes).   Example output:  INFO  [2016-08-22 00:49:33,557] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    INSTALLERS in processing order = \n        lifecycle            (r.v.d.g.m.i.f.LifeCycleInstaller)     \n        managed              (r.v.d.g.m.i.feature.ManagedInstaller) \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) \n        jerseyprovider       (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n        eagersingleton       (r.v.d.g.m.i.f.e.EagerSingletonInstaller) \n        healthcheck          (r.v.d.g.m.i.f.h.HealthCheckInstaller) \n        task                 (r.v.d.g.m.i.feature.TaskInstaller)    \n        plugin               (r.v.d.g.m.i.f.plugin.PluginInstaller) \n        webservlet           (r.v.d.g.m.i.f.w.WebServletInstaller)  \n        webfilter            (r.v.d.g.m.i.f.web.WebFilterInstaller) \n        weblistener          (r.v.d.g.m.i.f.w.l.WebListenerInstaller) \n\nINFO  [2016-08-22 00:49:33,563] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u2502   \n    \u251c\u2500\u2500 WebInstallersBundle          (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  WebFilterInstaller           (r.v.d.g.m.i.f.web)        \n    \u2502   \u251c\u2500\u2500 installer  WebServletInstaller          (r.v.d.g.m.i.f.web)        \n    \u2502   \u2514\u2500\u2500 installer  WebListenerInstaller         (r.v.d.g.m.i.f.w.listener) \n    \u2502   \n    \u2514\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n        \u251c\u2500\u2500 installer  LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  ManagedInstaller             (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  JerseyProviderInstaller      (r.v.d.g.m.i.f.j.provider) \n        \u251c\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  EagerSingletonInstaller      (r.v.d.g.m.i.f.eager)      \n        \u251c\u2500\u2500 installer  HealthCheckInstaller         (r.v.d.g.m.i.f.health)     \n        \u251c\u2500\u2500 installer  TaskInstaller                (r.v.d.g.m.i.feature)      \n        \u2514\u2500\u2500 installer  PluginInstaller              (r.v.d.g.m.i.f.plugin)       Comparing to complete diagnostic, it shows all installers (even not used). In diagnostic reporting not used installers are hidden, because usually it means they are not needed.",
            "title": "Installers mode"
        },
        {
            "location": "/guide/diagnostic/#guice-injector-creation-timings",
            "text": "You will see in guicey timings that almost all time spent creating guice injector. \nTo see some guice internal timings enable guice debug logs:  logging:\n  loggers:\n    com.google.inject.internal.util: DEBUG  Logs will be something like this:  DEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Module execution: 272ms\nDEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Interceptors creation: 1ms\nDEBUG [2016-08-03 21:09:45,965] com.google.inject.internal.util.Stopwatch: TypeListeners & ProvisionListener creation: 2ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Scopes creation: 1ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Converters creation: 0ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Binding creation: 26ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Module annotated method scanners creation: 0ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Private environment creation: 1ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Injector construction: 0ms\nDEBUG [2016-08-03 21:09:46,170] com.google.inject.internal.util.Stopwatch: Binding initialization: 177ms\nDEBUG [2016-08-03 21:09:46,171] com.google.inject.internal.util.Stopwatch: Binding indexing: 1ms\nDEBUG [2016-08-03 21:09:46,172] com.google.inject.internal.util.Stopwatch: Collecting injection requests: 1ms\nDEBUG [2016-08-03 21:09:46,179] com.google.inject.internal.util.Stopwatch: Binding validation: 7ms\nDEBUG [2016-08-03 21:09:46,183] com.google.inject.internal.util.Stopwatch: Static validation: 4ms\nDEBUG [2016-08-03 21:09:46,191] com.google.inject.internal.util.Stopwatch: Instance member validation: 8ms\nDEBUG [2016-08-03 21:09:46,192] com.google.inject.internal.util.Stopwatch: Provider verification: 1ms\nDEBUG [2016-08-03 21:09:46,201] com.google.inject.internal.util.Stopwatch: Static member injection: 9ms\nDEBUG [2016-08-03 21:09:46,204] com.google.inject.internal.util.Stopwatch: Instance injection: 3ms\nDEBUG [2016-08-03 21:09:46,427] com.google.inject.internal.util.Stopwatch: Preloading singletons: 223ms   Note  'Preloading singletons' line will be logged  long after  other guice log messages, so search it at the end of your startup log.",
            "title": "Guice injector creation timings"
        },
        {
            "location": "/guide/commands/",
            "text": "Dropwizard commands support\n\u00b6\n\n\nGuice injections\n\u00b6\n\n\nGuicey calls \ninjector.injectMembers(command)\n for all registered \nEnvironmentCommand\n's, so you can inject guice beans directly:\n\n\npublic\n \nclass\n \nMyCommand\n \nextends\n \nEnvironmentCommand\n<\nMyConfiguration\n>\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nmyservice\n;\n\n\n    \npublic\n \nMyCommand\n(\nApplication\n \napplication\n)\n \n{\n\n        \nsuper\n(\napplication\n,\n \n\"mycli\"\n,\n \n\"my super useful cli\"\n);\n\n    \n}\n\n\n    \n@Override\n\n        \nprotected\n \nvoid\n \nrun\n(\nEnvironment\n \nenvironment\n,\n \n                             \nNamespace\n \nnamespace\n,\n \n                             \nMyConfiguration\n \nconfiguration\n)\n \nthrows\n \nException\n \n{\n \n            \nmyservice\n.\ndoSomething\n();\n        \n        \n}\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\nIt doesn't matter if command was registered manually, by some bundle or with commands search (see below).\n\n\n\n\n\n\nWarning\n\n\nYou can use guice injections only in \nEnvironmentCommand\n's because only these commands start bundles (and so launch guice context creation).\n\n\n\n\nAutomatic installation\n\u00b6\n\n\nAutomatic scan for commands is disabled by default. It could be enabled by: \n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nenableAutoConfig\n(\n\"package.to.scan\"\n)\n\n    \n.\nsearchCommands\n()\n\n\n\n\n\n\nWhen enabled, all classes extending \nCommand\n are instantiated using default constructor and registered in dropwizard bootstrap object. \n\n\nSimple commands\n\u00b6\n\n\nFor example, if command below would be inside scanned package, then guicey will automatically register it.\n\n\npublic\n \nclass\n \nMyCommand\n \nextends\n \nCommand\n \n{\n\n\n    \npublic\n \nMyCommand\n()\n \n{\n\n        \nsuper\n(\n\"hello\"\n,\n \n\"Prints a greeting\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nBootstrap\n<?>\n \nbootstrap\n,\n \nNamespace\n \nnamespace\n)\n \nthrows\n \nException\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\"Hello world\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nEnvironment commands\n\u00b6\n\n\n\n\nImportant\n\n\nEnvironmentCommand\n must have constructor with \nApplication\n argument.\n\n\n\n\npublic\n \nclass\n \nSyncCommand\n \nextends\n \nEnvironmentCommand\n<\nAppConfiguration\n>\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nRemoteSynchronizer\n \nsynchronizer\n;\n\n    \n@Inject\n\n    \nprivate\n \nDbManager\n \nmanager\n;\n\n\n    \npublic\n \nSyncCommand\n(\nApplication\n<\nAppConfiguration\n>\n \napplication\n)\n \n{\n\n        \nsuper\n(\napplication\n,\n \n\"sync\"\n,\n \n\"Perform remote synchronization\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nrun\n(\nEnvironment\n \nenvironment\n,\n \n                        \nNamespace\n \nnamespace\n,\n \n                        \nAppConfiguration\n \nconfiguration\n)\n \nthrows\n \nException\n \n{\n\n        \nmanager\n.\nstart\n();\n\n        \ntry\n \n{\n\n            \nsynchronizer\n.\nsynchronize\n();\n\n        \n}\n \nfinally\n \n{\n\n            \nmanager\n.\nstop\n();\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThis example shows workaround for managed initialization in commnads: \nDbManager\n is some \nManaged\n bean which would run automatically \nin server mode. But commands never call managed objects, so we have to manually start and stop them.",
            "title": "Commands"
        },
        {
            "location": "/guide/commands/#dropwizard-commands-support",
            "text": "",
            "title": "Dropwizard commands support"
        },
        {
            "location": "/guide/commands/#guice-injections",
            "text": "Guicey calls  injector.injectMembers(command)  for all registered  EnvironmentCommand 's, so you can inject guice beans directly:  public   class   MyCommand   extends   EnvironmentCommand < MyConfiguration >   { \n\n     @Inject \n     private   MyService   myservice ; \n\n     public   MyCommand ( Application   application )   { \n         super ( application ,   \"mycli\" ,   \"my super useful cli\" ); \n     } \n\n     @Override \n         protected   void   run ( Environment   environment ,  \n                              Namespace   namespace ,  \n                              MyConfiguration   configuration )   throws   Exception   {  \n             myservice . doSomething ();         \n         }  }    Note  It doesn't matter if command was registered manually, by some bundle or with commands search (see below).    Warning  You can use guice injections only in  EnvironmentCommand 's because only these commands start bundles (and so launch guice context creation).",
            "title": "Guice injections"
        },
        {
            "location": "/guide/commands/#automatic-installation",
            "text": "Automatic scan for commands is disabled by default. It could be enabled by:   GuiceBundle . builder () \n     . enableAutoConfig ( \"package.to.scan\" ) \n     . searchCommands ()   When enabled, all classes extending  Command  are instantiated using default constructor and registered in dropwizard bootstrap object.",
            "title": "Automatic installation"
        },
        {
            "location": "/guide/commands/#simple-commands",
            "text": "For example, if command below would be inside scanned package, then guicey will automatically register it.  public   class   MyCommand   extends   Command   { \n\n     public   MyCommand ()   { \n         super ( \"hello\" ,   \"Prints a greeting\" ); \n     } \n\n     @Override \n     public   void   run ( Bootstrap <?>   bootstrap ,   Namespace   namespace )   throws   Exception   { \n         System . out . println ( \"Hello world\" ); \n     }  }",
            "title": "Simple commands"
        },
        {
            "location": "/guide/commands/#environment-commands",
            "text": "Important  EnvironmentCommand  must have constructor with  Application  argument.   public   class   SyncCommand   extends   EnvironmentCommand < AppConfiguration >   { \n\n     @Inject \n     private   RemoteSynchronizer   synchronizer ; \n     @Inject \n     private   DbManager   manager ; \n\n     public   SyncCommand ( Application < AppConfiguration >   application )   { \n         super ( application ,   \"sync\" ,   \"Perform remote synchronization\" ); \n     } \n\n     @Override \n     protected   void   run ( Environment   environment ,  \n                         Namespace   namespace ,  \n                         AppConfiguration   configuration )   throws   Exception   { \n         manager . start (); \n         try   { \n             synchronizer . synchronize (); \n         }   finally   { \n             manager . stop (); \n         } \n     }  }   This example shows workaround for managed initialization in commnads:  DbManager  is some  Managed  bean which would run automatically \nin server mode. But commands never call managed objects, so we have to manually start and stop them.",
            "title": "Environment commands"
        },
        {
            "location": "/guide/web/",
            "text": "Web features\n\u00b6\n\n\nGuice ServletModule support\n\u00b6\n\n\nBy default, GuiceFilter is registered for both application and admin contexts. And so request and session scopes will be \nbe available in both contexts. Also it makes injection of request and response objects available with provider (in any bean).\n\n\nTo register servlets and filters for main context use \nServletModule\n, e.g.\n\n\npublic\n \nclass\n \nWebModule\n \nextends\n \nServletModule\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigureServlets\n()\n \n{\n\n        \nfilter\n(\n\"/*\"\n).\nthrough\n(\nMyFilter\n.\nclass\n)\n\n        \nserve\n(\n\"/myservlet\"\n).\nwith\n(\nMyServlet\n.\nclass\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRequest scoped beans\n\u00b6\n\n\nYou can use request scoped beans in both main and admin contexts. \n\n\n@RequestScoped\n\n\npublic\n \nclass\n \nMyRequestScopedBean\n \n{\n \n...\n \n}\n\n\n\n\n\n\nTo obtain bean reference use provider:\n\n\nProvider\n<\nMyRequestScopedBean\n>\n \nmyBeanProvider\n;\n\n\n\n\n\n\nYou can inject request and response objects in any bean:\n\n\nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n\n\nProvider\n<\nHttpServletResponse\n>\n \nresponseProvider\n\n\n\n\n\n\nLimitations\n\u00b6\n\n\nBy default, GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types use option:\n\n\n    \n.\noption\n(\nGuiceyOptions\n.\nGuiceFilterRegistration\n,\n \nEnumSet\n.\nof\n(\nREQUEST\n,\n \nFORWARD\n))\n\n\n\n\n\n\nNote that async servlets and filters can't be used with guice servlet module (and so it is impossible to register GuiceFilter for ASYNC type). \nUse web installers for such cases. \n\n\nGuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and there may be problems combining servlets from ServletModule\nand filters in main scope.\n\n\nDisable ServletModule support\n\u00b6\n\n\nIf you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support:\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nnoGuiceFilter\n()\n\n\n\n\n\n\nIt will:\n\n\n\n\nAvoid registration of \nGuiceFilter\n in both contexts\n\n\nRemove request and session guice scopes support (because no ServletModule registered)\n\n\nPrevent installation of any \nServletModule\n (error will be thrown indicating duplicate binding)\n\n\nHttpServletRequest\n and \nHttpServletResponse\n still may be injected in resources with \nProvider\n \n(but it will not be possible to use such injections in servlets, filters or any other place)\n\n\n\n\nDisabling saves about ~50ms of startup time. \n\n\nWeb installers\n\u00b6\n\n\nServlet api 3.0 provides \n@WebServlet\n, \n@WebFilter\n and \n@WebListener\n annotations, but they are not recognized in dropwizard\n(because dropwizard does not depend on jersey-annotations module). Web installers recognize this annotations and register guice-managed filters, servlets and listeners \ninstances.\n\n\nWeb installers are disabled by default. To eable:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nuseWebInstallers\n()\n\n\n\n\n\n\nIt will register \nWebInstallersBundle\n.\n\n\n\n\nWeb installers are not enabled by default, because dropwizard is primarily rest oriented framework and you may not use custom servlets and filters at all\n(so no need to spent time trying to recognize them). Moreover, using standard servlet api annotations may confuse users and so \nit must be user decision to enable such support. Other developers should be guided bu option name and its javadoc (again to avoid confusion, no matter that\nit will work exactly as expected)\n\n\n\n\nDifferences with GuiceServlet module\n\u00b6\n\n\nThere is a difference between using web installers and registering servlets and filters with \nguice servlet module\n.\nGuice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\nWeb installers use guice only for filter or servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).  \n\n\nIn many cases, annotations are more convenient way to declare servlet or filter registration comparing to servlet module. \n\n\n\n\nTip\n\n\nUsing annotations you can register async \nservlets\n and \nfilters\n (with annotations asyncSupported=true option).\nIn contrast, it is impossible to register async with guice servlet module.\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, web installers (servlet, filter, listener) target application context. If you want to install into admin context then use \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextneds\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\n\nWill install servlet in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextneds\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\n\nIn example above, servlet registered in both contexts.",
            "title": "Web"
        },
        {
            "location": "/guide/web/#web-features",
            "text": "",
            "title": "Web features"
        },
        {
            "location": "/guide/web/#guice-servletmodule-support",
            "text": "By default, GuiceFilter is registered for both application and admin contexts. And so request and session scopes will be \nbe available in both contexts. Also it makes injection of request and response objects available with provider (in any bean).  To register servlets and filters for main context use  ServletModule , e.g.  public   class   WebModule   extends   ServletModule   { \n\n     @Override \n     protected   void   configureServlets ()   { \n         filter ( \"/*\" ). through ( MyFilter . class ) \n         serve ( \"/myservlet\" ). with ( MyServlet . class ) \n     }  }",
            "title": "Guice ServletModule support"
        },
        {
            "location": "/guide/web/#request-scoped-beans",
            "text": "You can use request scoped beans in both main and admin contexts.   @RequestScoped  public   class   MyRequestScopedBean   {   ...   }   To obtain bean reference use provider:  Provider < MyRequestScopedBean >   myBeanProvider ;   You can inject request and response objects in any bean:  Provider < HttpServletRequest >   requestProvider  Provider < HttpServletResponse >   responseProvider",
            "title": "Request scoped beans"
        },
        {
            "location": "/guide/web/#limitations",
            "text": "By default, GuiceFilter is registered with REQUEST dispatcher type. If you need to use other types use option:       . option ( GuiceyOptions . GuiceFilterRegistration ,   EnumSet . of ( REQUEST ,   FORWARD ))   Note that async servlets and filters can't be used with guice servlet module (and so it is impossible to register GuiceFilter for ASYNC type). \nUse web installers for such cases.   GuiceFilter dispatch all requests for filters and servlets registered by ServletModule internally and there may be problems combining servlets from ServletModule\nand filters in main scope.",
            "title": "Limitations"
        },
        {
            "location": "/guide/web/#disable-servletmodule-support",
            "text": "If you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support: GuiceBundle . builder () \n     . noGuiceFilter ()    It will:   Avoid registration of  GuiceFilter  in both contexts  Remove request and session guice scopes support (because no ServletModule registered)  Prevent installation of any  ServletModule  (error will be thrown indicating duplicate binding)  HttpServletRequest  and  HttpServletResponse  still may be injected in resources with  Provider  \n(but it will not be possible to use such injections in servlets, filters or any other place)   Disabling saves about ~50ms of startup time.",
            "title": "Disable ServletModule support"
        },
        {
            "location": "/guide/web/#web-installers",
            "text": "Servlet api 3.0 provides  @WebServlet ,  @WebFilter  and  @WebListener  annotations, but they are not recognized in dropwizard\n(because dropwizard does not depend on jersey-annotations module). Web installers recognize this annotations and register guice-managed filters, servlets and listeners \ninstances.  Web installers are disabled by default. To eable:  GuiceBundle . builder () \n     . useWebInstallers ()   It will register  WebInstallersBundle .   Web installers are not enabled by default, because dropwizard is primarily rest oriented framework and you may not use custom servlets and filters at all\n(so no need to spent time trying to recognize them). Moreover, using standard servlet api annotations may confuse users and so \nit must be user decision to enable such support. Other developers should be guided bu option name and its javadoc (again to avoid confusion, no matter that\nit will work exactly as expected)",
            "title": "Web installers"
        },
        {
            "location": "/guide/web/#differences-with-guiceservlet-module",
            "text": "There is a difference between using web installers and registering servlets and filters with  guice servlet module .\nGuice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\nWeb installers use guice only for filter or servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).    In many cases, annotations are more convenient way to declare servlet or filter registration comparing to servlet module.    Tip  Using annotations you can register async  servlets  and  filters  (with annotations asyncSupported=true option).\nIn contrast, it is impossible to register async with guice servlet module.",
            "title": "Differences with GuiceServlet module"
        },
        {
            "location": "/guide/web/#admin-context",
            "text": "By default, web installers (servlet, filter, listener) target application context. If you want to install into admin context then use  @AdminContext  annotation.  For example:   @AdminContext  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extneds   HttpServlet   {   ...   }   Will install servlet in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extneds   HttpServlet   {   ...   }   In example above, servlet registered in both contexts.",
            "title": "Admin context"
        },
        {
            "location": "/guide/test/",
            "text": "Testing\n\u00b6\n\n\nTest support require \nio.dropwizard:dropwizard-testing:1.0.6\n dependency.\n\n\nJunit\n\u00b6\n\n\nTesting core logic\n\u00b6\n\n\nFor integration testing of guice specific logic you can use \nGuiceyAppRule\n. It works almost like \n\nDropwizardAppRule\n,\nbut doesn't start jetty (and so jersey and guice web modules will not be initialized). \nManaged and lifecycle objects supported.\n\n\npublic\n \nclass\n \nMyTest\n \n{\n\n\n    \n@Rule\n\n    \nGuiceyAppRule\n<\nMyConfiguration\n>\n \nRULE\n \n=\n \nnew\n \nGuiceyAppRule\n<>(\nMyApplication\n.\nclass\n,\n \n\"path/to/configuration.yaml\"\n)\n\n\n    \npublic\n \nvoid\n \ntestSomething\n()\n \n{\n\n        \nRULE\n.\ngetBean\n(\nMyService\n.\nclass\n).\ndoSomething\n();\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs with dropwizard rule, configuration is optional\n\n\nnew\n \nGuiceyAppRule\n<>(\nMyApplication\n.\nclass\n,\n \nnull\n)\n\n\n\n\n\n\nTesting web logic\n\u00b6\n\n\nFor web component tests (servlets, filters, resources) use \n\nDropwizardAppRule\n.\n\n\nTo access guice beans use injector lookup:\n\n\nInjectorLookup\n.\ngetInjector\n(\nRULE\n.\ngetApplication\n()).\ngetBean\n(\nMyService\n.\nclass\n);\n\n\n\n\n\n\nSpock\n\u00b6\n\n\nIf you use \nspock framework\n you can use spock specific extensions:\n\n\n\n\n@UseGuiceyApp\n - internally use \nGuiceyAppRule\n\n\n@UseDropwizardApp\n - internally use \nDropwizardAppRule\n\n\n\n\nBoth extensions allows using injections directly in specifications (like spock-guice).\n\n\n@UseGuiceyApp\n\u00b6\n\n\n@UseGuiceyApp\n runs all guice logic without starting jetty (so resources, servlets and filters are not available).\nManaged objects are handled correctly.\n\n\n@UseGuiceyApp\n(\nMyApplication\n)\n\n\nclass\n \nAutoScanModeTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n@Inject\n \nMyService\n \nservice\n\n\n    \ndef\n \n\"My service test\"\n \n{\n\n        \nwhen:\n \n'calling service'\n\n        \ndef\n \nres\n \n=\n \nservice\n.\ngetSmth\n()\n\n        \nthen:\n \n'correct result returned'\n\n        \nres\n \n==\n \n'hello'\n\n    \n}\n\n\n\n\n\n\nAnnotation allows you to configure the same things as rules does: application class, configuration file (optional),\nconfiguration overrides.\n\n\n@UseGuiceyApp\n(\nvalue\n \n=\n \nMyApplication\n,\n\n    \nconfig\n \n=\n \n'path/to/my/config.yml'\n,\n\n    \nconfigOverride\n \n=\n \n[\n\n            \n@ConfigOverride\n(\nkey\n \n=\n \n\"foo\"\n,\n \nvalue\n \n=\n \n\"2\"\n),\n\n            \n@ConfigOverride\n(\nkey\n \n=\n \n\"bar\"\n,\n \nvalue\n \n=\n \n\"12\"\n)\n\n    \n])\n\n\nclass\n \nConfigOverrideTest\n \nextends\n \nSpecification\n \n{\n\n\n\n\n\n\nAs with rules, \nconfigOverride\n may be used without setting config file (simply to fill some configurations)\n\n\n@UseDropwizardApp\n\u00b6\n\n\n@UseDropwizardApp\n is useful for complete integration testing (when web part is required):\n\n\n@UseDropwizardApp\n(\nMyApplication\n)\n\n\nclass\n \nWebModuleTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n@Inject\n \nMyService\n \nservice\n\n\n    \ndef\n \n\"Check web bindings\"\n()\n \n{\n\n\n        \nwhen:\n \n\"calling filter\"\n\n        \ndef\n \nres\n \n=\n \nnew\n \nURL\n(\n\"http://localhost:8080/dummyFilter\"\n).\ngetText\n()\n\n        \nthen:\n \n\"filter active\"\n\n        \nres\n \n==\n \n'Sample filter and service called'\n\n        \nservice\n.\nisCalled\n()\n\n\n\n\n\n\nAnnotation supports the same configuration options as \n@UseGuiceyApp\n (see above)\n\n\nSpock extensions details\n\u00b6\n\n\nExtensions follow spock-guice style - application started once for all tests in class. It's the same as using rule with\n\n@ClassRule\n annotation. Rules may be used with spock too (the same way as in junit), but don't mix them with\nannotation extensions.\n\n\nThere are two limitations comparing to rules:\n\n\n\n\nApplication can't be created for each test separately (like with \n@Rule\n annotation). This is because of \n@Shared\n instances support.\n\n\nYou can't customize application creation: application class must have no-args constructor (with rules you can extend rule class\nand override \nnewApplication\n method). But this should be rare requirement.\n\n\n\n\n\n\nAll guicey tests use spock, so you can see extensions usage examples there.\n\n\n\n\nTo better understand injection scopes look the following test:\n\n\n@UseGuiceyApp\n(\nAutoScanApplication\n)\n\n\nclass\n \nInjectionTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n// instance remain the same between tests\n\n    \n@Shared\n \n@Inject\n \nTestBean\n \nsharedBean\n\n\n    \n// new instance injected on each test\n\n    \n@Inject\n \nTestBean\n \nbean\n\n\n    \n// the same context used for all tests (in class), so the same bean instance inserted before each test\n\n    \n@Inject\n \nTestSingletonBean\n \nsingletonBean\n\n\n    \ndef\n \n\"Check injection types\"\n()\n \n{\n\n        \nwhen:\n \n\"changing state of injected beans\"\n\n        \nsharedBean\n.\nvalue\n \n=\n \n10\n\n        \nbean\n.\nvalue\n \n=\n \n5\n\n        \nsingletonBean\n.\nvalue\n \n=\n \n15\n\n\n        \nthen:\n \n\"instances are different\"\n\n        \nsharedBean\n.\nvalue\n \n==\n \n10\n\n        \nbean\n.\nvalue\n \n==\n \n5\n\n        \nsingletonBean\n.\nvalue\n \n==\n \n15\n\n\n    \n}\n\n\n    \ndef\n \n\"Check shared state\"\n()\n \n{\n\n\n        \nexpect:\n \n\"shared bean instance is the same, whereas other one re-injected\"\n\n        \nsharedBean\n.\nvalue\n \n==\n \n10\n\n        \nbean\n.\nvalue\n \n==\n \n0\n\n        \nsingletonBean\n.\nvalue\n \n==\n \n15\n \n// the same instance was set before second test\n\n    \n}\n\n\n    \n// bean is in prototype scope\n\n    \nstatic\n \nclass\n \nTestBean\n \n{\n\n        \nint\n \nvalue\n\n    \n}\n\n\n    \n@Singleton\n\n    \nstatic\n \nclass\n \nTestSingletonBean\n \n{\n\n        \nint\n \nvalue\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOverriding beans\n\u00b6\n\n\nThere is no direct support for bean overrides yet (it is planned), but you can use the following approach.\n\n\nFirst, prepare custom \ninjector factory\n:\n\n\npublic\n \nclass\n \nCustomInjectorFactory\n \nimplements\n \nInjectorFactory\n \n{\n\n     \nprivate\n \nstatic\n \nThreadLocal\n<\nModules\n[]>\n \nmodules\n \n=\n \nnew\n \nThreadLocal\n<>();\n\n\n     \n@Override\n\n     \npublic\n \nInjector\n \ncreateInjector\n(\nStage\n \nstage\n,\n \nIterable\n<\nModule\n>\n \nmodules\n)\n \n{\n\n          \nModules\n[]\n \ncustomModules\n \n=\n \nmodules\n.\nget\n();\n\n          \nmodules\n.\nremove\n();\n\n          \nreturn\n \nGuice\n.\ncreateInjector\n(\nstage\n,\n \ncustomModules\n \n==\n \nnull\n \n?\n \nmodules\n \n                               \n:\n \nLists\n.\nnewArrayList\n(\nModules\n.\noverride\n(\nmodules\n).\nwith\n(\ncustomModules\n))\n \n)\n \n     \n}\n\n\n     \npublic\n \nstatic\n \nvoid\n \noverride\n(\nModule\n...\n \nmodules\n)\n \n{\n\n          \ncustomModules\n.\nset\n(\nmodules\n);\n\n     \n}\n\n\n     \npublic\n \nstatic\n \nvoid\n \nclear\n()\n \n{\n\n         \ncustomModules\n.\nremove\n();\n\n     \n}\n\n\n}\n\n\n\n\n\n\nIt allows using guice \nModule.overrides()\n for bindings substitution.\n\n\nRegister factory in guice bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\ninjectorFactory\n(\nnew\n \nCustomInjectorFactory\n())\n\n\n\n\n\n\nGuice Module.overrides forcefully override (substitute) all bindings from override modules.\nSo all modules in your application remain the same but you can create new test modules\nwith test specific replacements.\n\n\nFor example, suppose we have some service \nCustomerService\n and it's implementation, defined in appllication\n\nCustomerServiceImpl\n. To override it we prepare new test module:\n\n\npublic\n \nclass\n \nTestModule\n \nextends\n \nAbstractModule\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nbind\n(\nCustomerService\n.\nclass\n).\nto\n(\nTestCustomerServiceImpl\n.\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow register overriding module:\n\n\nCustomInjectorFactory\n.\noverride\n(\nnew\n \nTestModule\n());\n\n\n\n\n\n\n\n\nWarning\n\n\nOverriding modules registration must be performed before guicey start.\n\n\n\n\nAfter startup, application will use overridden customer service version.\n\n\nOf course this approach is far from ideal, but it's the best option for now.\n\n\n\n\nNote\n\n\nThread local is used to hold overriding modules to allow concurrent tests run.\nThis mean you have to manually clean state after each test to avoid side effects: \n\nCustomInjectorFactory\n.\nclear\n()\n (of course, if overriding is not used for all tests)",
            "title": "Test"
        },
        {
            "location": "/guide/test/#testing",
            "text": "Test support require  io.dropwizard:dropwizard-testing:1.0.6  dependency.",
            "title": "Testing"
        },
        {
            "location": "/guide/test/#junit",
            "text": "",
            "title": "Junit"
        },
        {
            "location": "/guide/test/#testing-core-logic",
            "text": "For integration testing of guice specific logic you can use  GuiceyAppRule . It works almost like  DropwizardAppRule ,\nbut doesn't start jetty (and so jersey and guice web modules will not be initialized). \nManaged and lifecycle objects supported.  public   class   MyTest   { \n\n     @Rule \n     GuiceyAppRule < MyConfiguration >   RULE   =   new   GuiceyAppRule <>( MyApplication . class ,   \"path/to/configuration.yaml\" ) \n\n     public   void   testSomething ()   { \n         RULE . getBean ( MyService . class ). doSomething (); \n         ... \n     }  }   As with dropwizard rule, configuration is optional  new   GuiceyAppRule <>( MyApplication . class ,   null )",
            "title": "Testing core logic"
        },
        {
            "location": "/guide/test/#testing-web-logic",
            "text": "For web component tests (servlets, filters, resources) use  DropwizardAppRule .  To access guice beans use injector lookup:  InjectorLookup . getInjector ( RULE . getApplication ()). getBean ( MyService . class );",
            "title": "Testing web logic"
        },
        {
            "location": "/guide/test/#spock",
            "text": "If you use  spock framework  you can use spock specific extensions:   @UseGuiceyApp  - internally use  GuiceyAppRule  @UseDropwizardApp  - internally use  DropwizardAppRule   Both extensions allows using injections directly in specifications (like spock-guice).",
            "title": "Spock"
        },
        {
            "location": "/guide/test/#useguiceyapp",
            "text": "@UseGuiceyApp  runs all guice logic without starting jetty (so resources, servlets and filters are not available).\nManaged objects are handled correctly.  @UseGuiceyApp ( MyApplication )  class   AutoScanModeTest   extends   Specification   { \n\n     @Inject   MyService   service \n\n     def   \"My service test\"   { \n         when:   'calling service' \n         def   res   =   service . getSmth () \n         then:   'correct result returned' \n         res   ==   'hello' \n     }   Annotation allows you to configure the same things as rules does: application class, configuration file (optional),\nconfiguration overrides.  @UseGuiceyApp ( value   =   MyApplication , \n     config   =   'path/to/my/config.yml' , \n     configOverride   =   [ \n             @ConfigOverride ( key   =   \"foo\" ,   value   =   \"2\" ), \n             @ConfigOverride ( key   =   \"bar\" ,   value   =   \"12\" ) \n     ])  class   ConfigOverrideTest   extends   Specification   {   As with rules,  configOverride  may be used without setting config file (simply to fill some configurations)",
            "title": "@UseGuiceyApp"
        },
        {
            "location": "/guide/test/#usedropwizardapp",
            "text": "@UseDropwizardApp  is useful for complete integration testing (when web part is required):  @UseDropwizardApp ( MyApplication )  class   WebModuleTest   extends   Specification   { \n\n     @Inject   MyService   service \n\n     def   \"Check web bindings\" ()   { \n\n         when:   \"calling filter\" \n         def   res   =   new   URL ( \"http://localhost:8080/dummyFilter\" ). getText () \n         then:   \"filter active\" \n         res   ==   'Sample filter and service called' \n         service . isCalled ()   Annotation supports the same configuration options as  @UseGuiceyApp  (see above)",
            "title": "@UseDropwizardApp"
        },
        {
            "location": "/guide/test/#spock-extensions-details",
            "text": "Extensions follow spock-guice style - application started once for all tests in class. It's the same as using rule with @ClassRule  annotation. Rules may be used with spock too (the same way as in junit), but don't mix them with\nannotation extensions.  There are two limitations comparing to rules:   Application can't be created for each test separately (like with  @Rule  annotation). This is because of  @Shared  instances support.  You can't customize application creation: application class must have no-args constructor (with rules you can extend rule class\nand override  newApplication  method). But this should be rare requirement.    All guicey tests use spock, so you can see extensions usage examples there.   To better understand injection scopes look the following test:  @UseGuiceyApp ( AutoScanApplication )  class   InjectionTest   extends   Specification   { \n\n     // instance remain the same between tests \n     @Shared   @Inject   TestBean   sharedBean \n\n     // new instance injected on each test \n     @Inject   TestBean   bean \n\n     // the same context used for all tests (in class), so the same bean instance inserted before each test \n     @Inject   TestSingletonBean   singletonBean \n\n     def   \"Check injection types\" ()   { \n         when:   \"changing state of injected beans\" \n         sharedBean . value   =   10 \n         bean . value   =   5 \n         singletonBean . value   =   15 \n\n         then:   \"instances are different\" \n         sharedBean . value   ==   10 \n         bean . value   ==   5 \n         singletonBean . value   ==   15 \n\n     } \n\n     def   \"Check shared state\" ()   { \n\n         expect:   \"shared bean instance is the same, whereas other one re-injected\" \n         sharedBean . value   ==   10 \n         bean . value   ==   0 \n         singletonBean . value   ==   15   // the same instance was set before second test \n     } \n\n     // bean is in prototype scope \n     static   class   TestBean   { \n         int   value \n     } \n\n     @Singleton \n     static   class   TestSingletonBean   { \n         int   value \n     }  }",
            "title": "Spock extensions details"
        },
        {
            "location": "/guide/test/#overriding-beans",
            "text": "There is no direct support for bean overrides yet (it is planned), but you can use the following approach.  First, prepare custom  injector factory :  public   class   CustomInjectorFactory   implements   InjectorFactory   { \n      private   static   ThreadLocal < Modules []>   modules   =   new   ThreadLocal <>(); \n\n      @Override \n      public   Injector   createInjector ( Stage   stage ,   Iterable < Module >   modules )   { \n           Modules []   customModules   =   modules . get (); \n           modules . remove (); \n           return   Guice . createInjector ( stage ,   customModules   ==   null   ?   modules  \n                                :   Lists . newArrayList ( Modules . override ( modules ). with ( customModules ))   )  \n      } \n\n      public   static   void   override ( Module ...   modules )   { \n           customModules . set ( modules ); \n      } \n\n      public   static   void   clear ()   { \n          customModules . remove (); \n      }  }   It allows using guice  Module.overrides()  for bindings substitution.  Register factory in guice bundle:  GuiceBundle . builder () \n     . injectorFactory ( new   CustomInjectorFactory ())   Guice Module.overrides forcefully override (substitute) all bindings from override modules.\nSo all modules in your application remain the same but you can create new test modules\nwith test specific replacements.  For example, suppose we have some service  CustomerService  and it's implementation, defined in appllication CustomerServiceImpl . To override it we prepare new test module:  public   class   TestModule   extends   AbstractModule   { \n     @Override \n     protected   void   configure ()   { \n         bind ( CustomerService . class ). to ( TestCustomerServiceImpl . class ); \n     }  }   Now register overriding module:  CustomInjectorFactory . override ( new   TestModule ());    Warning  Overriding modules registration must be performed before guicey start.   After startup, application will use overridden customer service version.  Of course this approach is far from ideal, but it's the best option for now.   Note  Thread local is used to hold overriding modules to allow concurrent tests run.\nThis mean you have to manually clean state after each test to avoid side effects:  CustomInjectorFactory . clear ()  (of course, if overriding is not used for all tests)",
            "title": "Overriding beans"
        },
        {
            "location": "/installers/resource/",
            "text": "Resource installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nResourceInstaller\n\n\n\n\nInstalls \nrest resources\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with jax-rs \n@Path\n annotation and register them as rest resources.\nGuice will manage resource creation, so you may think of it as usual guice bean.\n\n\n@Path\n(\n\"/res\"\n)\n\n\n@Produces\n(\n'\napplication\n/\njson\n'\n)\n\n\nclass\n \nSampleResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/sample\"\n)\n\n    \npublic\n \nResponse\n \nsample\n()\n \n{\n\n        \nreturn\n \nResponse\n.\nok\n(\nservice\n.\nresult\n()).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nResources registered as \nsingletons\n, even if guice bean scope isn't set.    \n\n\n\n\nInterface recognition\n\u00b6\n\n\nClass will also be recognized if \n@Path\n annotation found on directly implemented interface.\n\n\n@Path\n(\n\"/res\"\n)\n\n\n@Produces\n(\n'\napplication\n/\njson\n'\n)\n\n\ninterface\n \nResourceContract\n \n{\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/sample\"\n)\n\n    \nString\n \nlatest\n();\n\n\n}\n\n\n\nclass\n \nSampleResource\n \nimplements\n \nResourceContract\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \n@Override\n\n    \npublic\n \nResponse\n \nsample\n()\n \n{\n\n        \nreturn\n \nResponse\n.\nok\n(\nservice\n.\nresult\n()).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAnnotations on interfaces are useful for \njersey client proxies\n  \n\n\nClient\n \nclient\n \n=\n \nClientBuilder\n.\nnewClient\n();\n\n\nResourceContract\n \nresource\n \n=\n \nWebResourceFactory\n\n    \n.\nnewResource\n(\nResourceContract\n.\nclass\n,\n \nclient\n.\ntarget\n(\n\"http://localhost:8080/\"\n));\n\n\n\n// call sample method on remote resource http://localhost:8080/res/sample\n\n\nString\n \nresult\n \n=\n \nresource\n.\nsample\n();\n\n\n\n\n\n\n\n\nJersey client proxies requires extra dependency \norg.glassfish.jersey.ext:jersey-proxy-client\n\n\n\n\nRequest scope bindings\n\u00b6\n\n\nIf you need request scoped objects, use \nProvider\n:\n\n\nclass\n \nSampleResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/sample\"\n)\n\n    \npublic\n \nResponse\n \nsample\n()\n \n{\n\n        \nHttpServletRequest\n \nrequest\n \n=\n \nrequestProvider\n.\nget\n();\n\n        \n...\n\n    \n}\n\n\n\n\n\n\n// todo link to jersey binidngs\n\n\n@Context usage\n\u00b6\n\n\n@Context\n annotation usage is a common point of confusion. You can't use it for class fields: \n\n\n\n\nthis will not work\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@Context\n \nUriInfo\n \ninfo\n;\n\n\n}\n\n\n\n\n\n\n\n\nUse provider instead:\n\n\n\n\ncorrect way\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@Inject\n \nProvider\n<\nUriInfo\n>\n \ninfoProvider\n;\n\n\n}\n\n\n\n\n\n\n\n\nBut, you can use \n@Context\n on method parameters:\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@GET\n\n    \npublic\n \nResponse\n \nget\n(\n@Context\n \nUriInfo\n \ninfo\n)\n \n{\n \n...\n \n}\n\n\n}\n\n\n\n\n\n\nHK2 managed resource\n\u00b6\n\n\nIf resource class is annotated with \n@HK2Managed\n then jersey HK container will manage bean creation instead of guice. \nInjection of guice managed beans will still be possible via registered \nhk2-guice-bridge\n,\nbut guice aop features will not work.\n\n\n@Path\n(\n\"/res\"\n)\n\n\n@Produces\n(\n'\napplication\n/\njson\n'\n)\n\n\n@HK2Managed\n\n\nclass\n \nSampleResource\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\n\n@Context\n annotation on field will work on hk managed bean:\n\n@Path\n()\n\n\n@HK2Managed\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@Context\n \nUriInfo\n \ninfo\n;\n\n\n}",
            "title": "Resource"
        },
        {
            "location": "/installers/resource/#resource-installer",
            "text": "CoreInstallersBundle /  ResourceInstaller   Installs  rest resources .",
            "title": "Resource installer"
        },
        {
            "location": "/installers/resource/#recognition",
            "text": "Detects classes annotated with jax-rs  @Path  annotation and register them as rest resources.\nGuice will manage resource creation, so you may think of it as usual guice bean.  @Path ( \"/res\" )  @Produces ( ' application / json ' )  class   SampleResource   { \n\n     @Inject \n     private   MyService   service ; \n\n     @GET \n     @Path ( \"/sample\" ) \n     public   Response   sample ()   { \n         return   Response . ok ( service . result ()). build (); \n     }  }    Resources registered as  singletons , even if guice bean scope isn't set.",
            "title": "Recognition"
        },
        {
            "location": "/installers/resource/#interface-recognition",
            "text": "Class will also be recognized if  @Path  annotation found on directly implemented interface.  @Path ( \"/res\" )  @Produces ( ' application / json ' )  interface   ResourceContract   { \n\n     @GET \n     @Path ( \"/sample\" ) \n     String   latest ();  }  class   SampleResource   implements   ResourceContract   { \n\n     @Inject \n     private   MyService   service ; \n\n     @Override \n     public   Response   sample ()   { \n         return   Response . ok ( service . result ()). build (); \n     }  }   Annotations on interfaces are useful for  jersey client proxies     Client   client   =   ClientBuilder . newClient ();  ResourceContract   resource   =   WebResourceFactory \n     . newResource ( ResourceContract . class ,   client . target ( \"http://localhost:8080/\" ));  // call sample method on remote resource http://localhost:8080/res/sample  String   result   =   resource . sample ();    Jersey client proxies requires extra dependency  org.glassfish.jersey.ext:jersey-proxy-client",
            "title": "Interface recognition"
        },
        {
            "location": "/installers/resource/#request-scope-bindings",
            "text": "If you need request scoped objects, use  Provider :  class   SampleResource   { \n\n     @Inject \n     private   Provider < HttpServletRequest >   requestProvider ; \n\n     @GET \n     @Path ( \"/sample\" ) \n     public   Response   sample ()   { \n         HttpServletRequest   request   =   requestProvider . get (); \n         ... \n     }   // todo link to jersey binidngs",
            "title": "Request scope bindings"
        },
        {
            "location": "/installers/resource/#context-usage",
            "text": "@Context  annotation usage is a common point of confusion. You can't use it for class fields:    this will not work  public   class   MyResource   { \n     @Context   UriInfo   info ;  }    Use provider instead:   correct way  public   class   MyResource   { \n     @Inject   Provider < UriInfo >   infoProvider ;  }    But, you can use  @Context  on method parameters:  public   class   MyResource   { \n     @GET \n     public   Response   get ( @Context   UriInfo   info )   {   ...   }  }",
            "title": "@Context usage"
        },
        {
            "location": "/installers/resource/#hk2-managed-resource",
            "text": "If resource class is annotated with  @HK2Managed  then jersey HK container will manage bean creation instead of guice. \nInjection of guice managed beans will still be possible via registered  hk2-guice-bridge ,\nbut guice aop features will not work.  @Path ( \"/res\" )  @Produces ( ' application / json ' )  @HK2Managed  class   SampleResource   { \n     ...  }    @Context  annotation on field will work on hk managed bean: @Path ()  @HK2Managed  public   class   MyResource   { \n     @Context   UriInfo   info ;  }",
            "title": "HK2 managed resource"
        },
        {
            "location": "/installers/task/",
            "text": "Task installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nTaskInstaller\n        \n\n\n\n\nInstalls \ndropwizard tasks\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes extending dropwizard \nTask\n and register their instances in environment.\n\n\npublic\n \nclass\n \nMyTask\n \nextends\n \nTask\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \npublic\n \nTruncateDatabaseTask\n()\n \n{\n\n        \nsuper\n(\n\"mytask\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nexecute\n(\nImmutableMultimap\n<\nString\n,\n \nString\n>\n \nparameters\n,\n \nPrintWriter\n \noutput\n)\n \nthrows\n \nException\n \n{\n\n        \nservice\n.\ndoSomething\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTask can be triggered with: \nhttp://localhost:8081/tasks/mytask",
            "title": "Task"
        },
        {
            "location": "/installers/task/#task-installer",
            "text": "CoreInstallersBundle /  TaskInstaller            Installs  dropwizard tasks .",
            "title": "Task installer"
        },
        {
            "location": "/installers/task/#recognition",
            "text": "Detects classes extending dropwizard  Task  and register their instances in environment.  public   class   MyTask   extends   Task   { \n\n     @Inject \n     private   MyService   service ; \n\n     public   TruncateDatabaseTask ()   { \n         super ( \"mytask\" ); \n     } \n\n     @Override \n     public   void   execute ( ImmutableMultimap < String ,   String >   parameters ,   PrintWriter   output )   throws   Exception   { \n         service . doSomething (); \n     }  }   Task can be triggered with:  http://localhost:8081/tasks/mytask",
            "title": "Recognition"
        },
        {
            "location": "/installers/managed/",
            "text": "Managed installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nManagedInstaller\n        \n\n\n\n\nInstalls \ndropwizard managed objects\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes implementing dropwizard \nManaged\n and register their instances in environment.\n\n\npublic\n \nclass\n \nMyService\n \nimplements\n \nManaged\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n        \n...\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstop\n()\n \nthrows\n \nException\n \n{\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIt is perfect for implementing guice \nservice lifecycle\n.\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order managed objects.\n\n@Order\n(\n10\n)\n\n\npublic\n \nclass\n \nMyService\n \nimplements\n \nManaged",
            "title": "Managed"
        },
        {
            "location": "/installers/managed/#managed-installer",
            "text": "CoreInstallersBundle /  ManagedInstaller            Installs  dropwizard managed objects .",
            "title": "Managed installer"
        },
        {
            "location": "/installers/managed/#recognition",
            "text": "Detects classes implementing dropwizard  Managed  and register their instances in environment.  public   class   MyService   implements   Managed   { \n\n     @Override \n     public   void   start ()   throws   Exception   { \n         ... \n     } \n\n     @Override \n     public   void   stop ()   throws   Exception   { \n         ... \n     }  }   It is perfect for implementing guice  service lifecycle .   Tip  Use guicey  @Order  annotation to order managed objects. @Order ( 10 )  public   class   MyService   implements   Managed",
            "title": "Recognition"
        },
        {
            "location": "/installers/lifecycle/",
            "text": "Lifecycle installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nLifeCycleInstaller\n        \n\n\n\n\nInstalls \njetty LifeCycle\n implementations.\n\n\nRecognition\n\u00b6\n\n\nDetects classes implementing jetty \nLifeCycle\n interface and register their instances in environment.\n\n\npublic\n \nclass\n \nMyCycle\n \nimplements\n \nLifeCycle\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\nIn most cases it's better to use \nmanaged object\n instead of implementing lifecycle.\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order managed objects.  \n\n\n@Order\n(\n10\n)\n\n\npublic\n \nclass\n \nMyCycle\n \nimplements\n \nLifeCycle",
            "title": "Lifecycle"
        },
        {
            "location": "/installers/lifecycle/#lifecycle-installer",
            "text": "CoreInstallersBundle /  LifeCycleInstaller            Installs  jetty LifeCycle  implementations.",
            "title": "Lifecycle installer"
        },
        {
            "location": "/installers/lifecycle/#recognition",
            "text": "Detects classes implementing jetty  LifeCycle  interface and register their instances in environment.  public   class   MyCycle   implements   LifeCycle   { \n     ...  }   In most cases it's better to use  managed object  instead of implementing lifecycle.   Tip  Use guicey  @Order  annotation to order managed objects.    @Order ( 10 )  public   class   MyCycle   implements   LifeCycle",
            "title": "Recognition"
        },
        {
            "location": "/installers/healthcheck/",
            "text": "Health check installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nHealthCheckInstaller\n        \n\n\n\n\nInstalls \ndropwizard health check\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes extending guicey \nNamedHealthCheck\n and register their instances in environment.\nCustom base class is required, because default \nHealthCheck\n did not provide check name, which is required for registration.\n\n\npublic\n \nclass\n \nMyHealthCheck\n \nextends\n \nNamedHealthCheck\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \n@Override\n\n    \nprotected\n \nResult\n \ncheck\n()\n \nthrows\n \nException\n \n{\n\n        \nif\n \n(\nservice\n.\nisOk\n())\n \n{\n\n            \nreturn\n \nResult\n.\nhealthy\n();\n\n        \n}\n \nelse\n \n{\n\n            \nreturn\n \nResult\n.\nunhealthy\n(\n\"Service is not ok\"\n);\n\n        \n}\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nString\n \ngetName\n()\n \n{\n\n        \nreturn\n \n\"my-service\"\n;\n\n    \n}\n\n\n}",
            "title": "Health check"
        },
        {
            "location": "/installers/healthcheck/#health-check-installer",
            "text": "CoreInstallersBundle /  HealthCheckInstaller            Installs  dropwizard health check .",
            "title": "Health check installer"
        },
        {
            "location": "/installers/healthcheck/#recognition",
            "text": "Detects classes extending guicey  NamedHealthCheck  and register their instances in environment.\nCustom base class is required, because default  HealthCheck  did not provide check name, which is required for registration.  public   class   MyHealthCheck   extends   NamedHealthCheck   { \n\n     @Inject \n     private   MyService   service ; \n\n     @Override \n     protected   Result   check ()   throws   Exception   { \n         if   ( service . isOk ())   { \n             return   Result . healthy (); \n         }   else   { \n             return   Result . unhealthy ( \"Service is not ok\" ); \n         } \n     } \n\n     @Override \n     public   String   getName ()   { \n         return   \"my-service\" ; \n     }  }",
            "title": "Recognition"
        },
        {
            "location": "/installers/jersey-ext/",
            "text": "Jersey extension installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nJerseyProviderInstaller\n        \n\n\n\n\nInstalls various jersey extensions, usually annotated with jersey \n@Provider\n annotation and installed via \nenvironment\n.\njersey\n().\nregister\n()\n:\n\n\nFactory, ExceptionMapper, ValueFactoryProvider, InjectionResolver, \nParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, \nReaderInterceptor, WriterInterceptor, ContainerRequestFilter, \nContainerResponseFilter, DynamicFeature, ApplicationEventListener\n\n\n\n\n\nRecognition\n\u00b6\n\n\nDetects  classes annotated with jersey \n@javax.ws.rs.ext.Provider\n annotation and register their instances in jersey.\n\n\n\n\nExtensions registered as \nsingletons\n, even if guice bean scope isn't set.  \n\n\n\n\nDue to specifics of HK integration (TODO link), you may need to use:\n\n\n\n\n@HK2Managed\n to delegate bean creation to HK\n\n\n@LazyBinding\n to delay bean creation to time when all dependencies will be available \n\n\njavax.inject.Provider\n as universal workaround (to wrap not immediately available dependency).\n\n\n\n\nFactory\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\nhk2\n.\napi\n.\nFactory\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nAuthFactory\n \nimplements\n \nFactory\n<\nUser\n>{\n\n\n    \n@Override\n\n    \npublic\n \nUser\n \nprovide\n()\n \n{\n\n        \nreturn\n \nnew\n \nUser\n();\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndispose\n(\nUser\n \ninstance\n)\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nFactories in essence are very like guice (or javax.inject) providers (\nProvider\n).\n\n\n\n\nExample of using jersey abstract class instead of direct implementation:\n\n\n@Provider\n\n\npublic\n \nclass\n \nLocaleInjectableProvider\n \nextends\n \nAbstractContainerRequestValueFactory\n<\nLocale\n>\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \njavax\n.\ninject\n.\nProvider\n<\nHttpHeaders\n>\n \nrequest\n;\n\n\n    \n@Override\n\n    \npublic\n \nLocale\n \nprovide\n()\n \n{\n\n        \nfinal\n \nList\n<\nLocale\n>\n \nlocales\n \n=\n \nrequest\n.\nget\n().\ngetAcceptableLanguages\n();\n\n        \nreturn\n \nlocales\n.\nisEmpty\n()\n \n?\n \nLocale\n.\nUS\n \n:\n \nlocales\n.\nget\n(\n0\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nExceptionMapper\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nExceptionMapper\n (or extending abstract class implementing it). \nUseful for \nerror handling customization\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nDummyExceptionMapper\n \nimplements\n \nExceptionMapper\n<\nRuntimeException\n>\n \n{\n\n\n    \nprivate\n \nfinal\n \nLogger\n \nlogger\n \n=\n \nLoggerFactory\n.\ngetLogger\n(\nDummyExceptionMapper\n.\nclass\n);\n\n\n    \n@Override\n\n    \npublic\n \nResponse\n \ntoResponse\n(\nRuntimeException\n \ne\n)\n \n{\n\n        \nlogger\n.\ndebug\n(\n\"Problem while executing\"\n,\n \ne\n);\n\n        \nreturn\n \nResponse\n.\nstatus\n(\nResponse\n.\nStatus\n.\nBAD_REQUEST\n)\n\n                \n.\ntype\n(\nMediaType\n.\nTEXT_PLAIN\n)\n\n                \n.\nentity\n(\ne\n.\ngetMessage\n())\n\n                \n.\nbuild\n();\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\nValueFactoryProvider\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\njersey\n.\nserver\n.\nspi\n.\ninternal\n.\nValueFactoryProvider\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\n@LazyBinding\n \n\npublic\n \nclass\n \nAuthFactoryProvider\n \nextends\n \nAbstractValueFactoryProvider\n \n{\n\n\n    \nprivate\n \nfinal\n \nFactory\n<\nUser\n>\n \nauthFactory\n;\n\n\n    \n@Inject\n\n    \npublic\n \nAuthFactoryProvider\n(\nfinal\n \nMultivaluedParameterExtractorProvider\n \nextractorProvider\n,\n\n                               \nfinal\n \nAuthFactory\n \nfactory\n,\n \n                               \nfinal\n \nServiceLocator\n \ninjector\n)\n \n{\n\n        \nsuper\n(\nextractorProvider\n,\n \ninjector\n,\n \nParameter\n.\nSource\n.\nUNKNOWN\n);\n\n        \nthis\n.\nauthFactory\n \n=\n \nfactory\n;\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nFactory\n<?>\n \ncreateValueFactory\n(\nParameter\n \nparameter\n)\n \n{\n\n        \nfinal\n \nAuth\n \nauth\n \n=\n \nparameter\n.\ngetAnnotation\n(\nAuth\n.\nclass\n);\n\n        \nreturn\n \nauth\n \n!=\n \nnull\n \n?\n \nauthFactory\n \n:\n \nnull\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\n@LazyBinding\n was used to delay provider creation because required dependency \nMultivaluedParameterExtractorProvider\n\n(by super class) will be available only after HK context creation (which is created after guice context). \nAnother option could be using \n@HK2Managed\n (instead of lazy) which will delegate bean creation to hk.\n\n\n\n\nInjectionResolver\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\nhk2\n.\napi\n.\nInjectionResolver\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\n@LazyBinding\n\n\npublic\n \nclass\n \nAuthInjectionResolver\n \nextends\n \nParamInjectionResolver\n<\nAuth\n>\n \n{\n\n\n    \npublic\n \nAuthInjectionResolver\n()\n \n{\n\n        \nsuper\n(\nAuthFactoryProvider\n.\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\n@LazyBinding\n was used to delay provider creation because super class will require hk service locator, \nwhich is not yet available. \n@HK2Managed\n could also be used instead.\n\n\n\n\nParamConverterProvider\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nParamConverterProvider\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nFooParamConverter\n \nimplements\n \nParamConverterProvider\n \n{\n\n\n    \n@Override\n\n    \npublic\n \n<\nT\n>\n \nParamConverter\n<\nT\n>\n \ngetConverter\n(\nClass\n<\nT\n>\n \nrawType\n,\n \nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n)\n \n{\n\n        \nif\n \n(\nFoo\n.\nclass\n.\nisAssignableFrom\n(\nrawType\n))\n \n{\n\n            \nreturn\n \n(\nParamConverter\n<\nT\n>)\n \nnew\n \nFooConverter\n();\n\n        \n}\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n    \nprivate\n \nstatic\n \nclass\n \nFooConverter\n \nimplements\n \nParamConverter\n<\nFoo\n>\n \n{\n\n        \n@Override\n\n        \npublic\n \nFoo\n \nfromString\n(\nString\n \nvalue\n)\n \n{\n\n            \nreturn\n \nnew\n \nFoo\n(\nvalue\n);\n\n        \n}\n\n\n        \n@Override\n\n        \npublic\n \nString\n \ntoString\n(\nFoo\n \nvalue\n)\n \n{\n\n            \nreturn\n \nvalue\n.\nvalue\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nContextResolver\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nContextResolver\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyContextResolver\n \nimplements\n \nContextResolver\n<\nContext\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nContext\n \ngetContext\n(\nClass\n \ntype\n)\n \n{\n\n        \nreturn\n \nnew\n \nContext\n();\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nclass\n \nContext\n \n{}\n\n\n}\n\n\n\n\n\n\nMessageBodyReader\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nMessageBodyReader\n (or extending abstract class implementing it).\nUseful for \ncustom representations\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nTypeMessageBodyReader\n \nimplements\n \nMessageBodyReader\n<\nType\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nisReadable\n(\nClass\n<?>\n \ntype\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n)\n \n{\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nType\n \nreadFrom\n(\nClass\n<\nType\n>\n \ntype\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n,\n \nMultivaluedMap\n<\nString\n,\n \nString\n>\n \nhttpHeaders\n,\n \nInputStream\n \nentityStream\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nclass\n \nType\n \n{}\n\n\n}\n\n\n\n\n\n\nMessageBodyWriter\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nMessageBodyWriter\n (or extending abstract class implementing it).\nUseful for \ncustom representations\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nTypeMessageBodyWriter\n \nimplements\n \nMessageBodyWriter\n<\nType\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nisWriteable\n(\nClass\n<?>\n \ntype\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n)\n \n{\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nlong\n \ngetSize\n(\nType\n \ntype\n,\n \nClass\n<?>\n \ntype2\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n)\n \n{\n\n        \nreturn\n \n0\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nwriteTo\n(\nType\n \ntype\n,\n \nClass\n<?>\n \ntype2\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n,\n \nMultivaluedMap\n<\nString\n,\n \nObject\n>\n \nhttpHeaders\n,\n \nOutputStream\n \nentityStream\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nclass\n \nType\n \n{}\n\n\n}\n\n\n\n\n\n\nReaderInterceptor\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nReaderInterceptor\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyReaderInterceptor\n \nimplements\n \nReaderInterceptor\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nObject\n \naroundReadFrom\n(\nReaderInterceptorContext\n \ncontext\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWriterInterceptor\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nWriterInterceptor\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyWriterInterceptor\n \nimplements\n \nWriterInterceptor\n \n{\n\n\n    \n@Override\n\n    \nvoid\n \naroundWriteTo\n(\nWriterInterceptorContext\n \ncontext\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nContainerRequestFilter\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\ncontainer\n.\nContainerRequestFilter\n (or extending abstract class implementing it).\nUseful for \nrequest modifications\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyContainerRequestFilter\n \nimplements\n \nContainerRequestFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nfilter\n(\nContainerRequestContext\n \nrequestContext\n)\n \nthrows\n \nIOException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nContainerResponseFilter\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\ncontainer\n.\nContainerResponseFilter\n (or extending abstract class implementing it).\nUseful for \nresponse modifications\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyContainerResponseFilter\n \nimplements\n \nContainerResponseFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nfilter\n(\nContainerRequestContext\n \nrequestContext\n,\n \nContainerResponseContext\n \nresponseContext\n)\n \nthrows\n \nIOException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDynamicFeature\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\ncontainer\n.\nDynamicFeature\n (or extending abstract class implementing it).\nUseful for conditional \nactivation of filters\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyDynamicFeature\n \nimplements\n \nDynamicFeature\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nconfigure\n(\nResourceInfo\n \nresourceInfo\n,\n \nFeatureContext\n \ncontext\n)\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\nApplicationEventListener\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\njersey\n.\nserver\n.\nmonitoring\n.\nApplicationEventListener\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyApplicationEventListener\n \nimplements\n \nApplicationEventListener\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonEvent\n(\nApplicationEvent\n \nevent\n)\n \n{\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nRequestEventListener\n \nonRequest\n(\nRequestEvent\n \nrequestEvent\n)\n \n{\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n}",
            "title": "Jersey extension"
        },
        {
            "location": "/installers/jersey-ext/#jersey-extension-installer",
            "text": "CoreInstallersBundle /  JerseyProviderInstaller            Installs various jersey extensions, usually annotated with jersey  @Provider  annotation and installed via  environment . jersey (). register () :  Factory, ExceptionMapper, ValueFactoryProvider, InjectionResolver, \nParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, \nReaderInterceptor, WriterInterceptor, ContainerRequestFilter, \nContainerResponseFilter, DynamicFeature, ApplicationEventListener",
            "title": "Jersey extension installer"
        },
        {
            "location": "/installers/jersey-ext/#recognition",
            "text": "Detects  classes annotated with jersey  @javax.ws.rs.ext.Provider  annotation and register their instances in jersey.   Extensions registered as  singletons , even if guice bean scope isn't set.     Due to specifics of HK integration (TODO link), you may need to use:   @HK2Managed  to delegate bean creation to HK  @LazyBinding  to delay bean creation to time when all dependencies will be available   javax.inject.Provider  as universal workaround (to wrap not immediately available dependency).",
            "title": "Recognition"
        },
        {
            "location": "/installers/jersey-ext/#factory",
            "text": "Any class implementing  org . glassfish . hk2 . api . Factory  (or extending abstract class implementing it).  @Provider  public   class   AuthFactory   implements   Factory < User >{ \n\n     @Override \n     public   User   provide ()   { \n         return   new   User (); \n     } \n\n     @Override \n     public   void   dispose ( User   instance )   { \n     }  }    Factories in essence are very like guice (or javax.inject) providers ( Provider ).   Example of using jersey abstract class instead of direct implementation:  @Provider  public   class   LocaleInjectableProvider   extends   AbstractContainerRequestValueFactory < Locale >   { \n\n     @Inject \n     private   javax . inject . Provider < HttpHeaders >   request ; \n\n     @Override \n     public   Locale   provide ()   { \n         final   List < Locale >   locales   =   request . get (). getAcceptableLanguages (); \n         return   locales . isEmpty ()   ?   Locale . US   :   locales . get ( 0 ); \n     }  }",
            "title": "Factory"
        },
        {
            "location": "/installers/jersey-ext/#exceptionmapper",
            "text": "Any class implementing  javax . ws . rs . ext . ExceptionMapper  (or extending abstract class implementing it). \nUseful for  error handling customization .  @Provider  public   class   DummyExceptionMapper   implements   ExceptionMapper < RuntimeException >   { \n\n     private   final   Logger   logger   =   LoggerFactory . getLogger ( DummyExceptionMapper . class ); \n\n     @Override \n     public   Response   toResponse ( RuntimeException   e )   { \n         logger . debug ( \"Problem while executing\" ,   e ); \n         return   Response . status ( Response . Status . BAD_REQUEST ) \n                 . type ( MediaType . TEXT_PLAIN ) \n                 . entity ( e . getMessage ()) \n                 . build (); \n     }  }",
            "title": "ExceptionMapper"
        },
        {
            "location": "/installers/jersey-ext/#valuefactoryprovider",
            "text": "Any class implementing  org . glassfish . jersey . server . spi . internal . ValueFactoryProvider  (or extending abstract class implementing it).  @Provider  @LazyBinding   public   class   AuthFactoryProvider   extends   AbstractValueFactoryProvider   { \n\n     private   final   Factory < User >   authFactory ; \n\n     @Inject \n     public   AuthFactoryProvider ( final   MultivaluedParameterExtractorProvider   extractorProvider , \n                                final   AuthFactory   factory ,  \n                                final   ServiceLocator   injector )   { \n         super ( extractorProvider ,   injector ,   Parameter . Source . UNKNOWN ); \n         this . authFactory   =   factory ; \n     } \n\n     @Override \n     protected   Factory <?>   createValueFactory ( Parameter   parameter )   { \n         final   Auth   auth   =   parameter . getAnnotation ( Auth . class ); \n         return   auth   !=   null   ?   authFactory   :   null ; \n     }  }    Note  @LazyBinding  was used to delay provider creation because required dependency  MultivaluedParameterExtractorProvider \n(by super class) will be available only after HK context creation (which is created after guice context). \nAnother option could be using  @HK2Managed  (instead of lazy) which will delegate bean creation to hk.",
            "title": "ValueFactoryProvider"
        },
        {
            "location": "/installers/jersey-ext/#injectionresolver",
            "text": "Any class implementing  org . glassfish . hk2 . api . InjectionResolver  (or extending abstract class implementing it).  @Provider  @LazyBinding  public   class   AuthInjectionResolver   extends   ParamInjectionResolver < Auth >   { \n\n     public   AuthInjectionResolver ()   { \n         super ( AuthFactoryProvider . class ); \n     }  }    Note  @LazyBinding  was used to delay provider creation because super class will require hk service locator, \nwhich is not yet available.  @HK2Managed  could also be used instead.",
            "title": "InjectionResolver"
        },
        {
            "location": "/installers/jersey-ext/#paramconverterprovider",
            "text": "Any class implementing  javax . ws . rs . ext . ParamConverterProvider  (or extending abstract class implementing it).  @Provider  public   class   FooParamConverter   implements   ParamConverterProvider   { \n\n     @Override \n     public   < T >   ParamConverter < T >   getConverter ( Class < T >   rawType ,   Type   genericType ,   Annotation []   annotations )   { \n         if   ( Foo . class . isAssignableFrom ( rawType ))   { \n             return   ( ParamConverter < T >)   new   FooConverter (); \n         } \n         return   null ; \n     } \n\n     private   static   class   FooConverter   implements   ParamConverter < Foo >   { \n         @Override \n         public   Foo   fromString ( String   value )   { \n             return   new   Foo ( value ); \n         } \n\n         @Override \n         public   String   toString ( Foo   value )   { \n             return   value . value ; \n         } \n     }  }",
            "title": "ParamConverterProvider"
        },
        {
            "location": "/installers/jersey-ext/#contextresolver",
            "text": "Any class implementing  javax . ws . rs . ext . ContextResolver  (or extending abstract class implementing it).  @Provider  public   class   MyContextResolver   implements   ContextResolver < Context >   { \n\n     @Override \n     public   Context   getContext ( Class   type )   { \n         return   new   Context (); \n     } \n\n     public   static   class   Context   {}  }",
            "title": "ContextResolver"
        },
        {
            "location": "/installers/jersey-ext/#messagebodyreader",
            "text": "Any class implementing  javax . ws . rs . ext . MessageBodyReader  (or extending abstract class implementing it).\nUseful for  custom representations .  @Provider  public   class   TypeMessageBodyReader   implements   MessageBodyReader < Type >   { \n\n     @Override \n     public   boolean   isReadable ( Class <?>   type ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType )   { \n         return   false ; \n     } \n\n     @Override \n     public   Type   readFrom ( Class < Type >   type ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType ,   MultivaluedMap < String ,   String >   httpHeaders ,   InputStream   entityStream )   throws   IOException ,   WebApplicationException   { \n         return   null ; \n     } \n\n     public   static   class   Type   {}  }",
            "title": "MessageBodyReader"
        },
        {
            "location": "/installers/jersey-ext/#messagebodywriter",
            "text": "Any class implementing  javax . ws . rs . ext . MessageBodyWriter  (or extending abstract class implementing it).\nUseful for  custom representations .  @Provider  public   class   TypeMessageBodyWriter   implements   MessageBodyWriter < Type >   { \n\n     @Override \n     public   boolean   isWriteable ( Class <?>   type ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType )   { \n         return   false ; \n     } \n\n     @Override \n     public   long   getSize ( Type   type ,   Class <?>   type2 ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType )   { \n         return   0 ; \n     } \n\n     @Override \n     public   void   writeTo ( Type   type ,   Class <?>   type2 ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType ,   MultivaluedMap < String ,   Object >   httpHeaders ,   OutputStream   entityStream )   throws   IOException ,   WebApplicationException   { \n     } \n\n     public   static   class   Type   {}  }",
            "title": "MessageBodyWriter"
        },
        {
            "location": "/installers/jersey-ext/#readerinterceptor",
            "text": "Any class implementing  javax . ws . rs . ext . ReaderInterceptor  (or extending abstract class implementing it).  @Provider  public   class   MyReaderInterceptor   implements   ReaderInterceptor   { \n\n     @Override \n     public   Object   aroundReadFrom ( ReaderInterceptorContext   context )   throws   IOException ,   WebApplicationException   { \n         return   null ; \n     }  }",
            "title": "ReaderInterceptor"
        },
        {
            "location": "/installers/jersey-ext/#writerinterceptor",
            "text": "Any class implementing  javax . ws . rs . ext . WriterInterceptor  (or extending abstract class implementing it).  @Provider  public   class   MyWriterInterceptor   implements   WriterInterceptor   { \n\n     @Override \n     void   aroundWriteTo ( WriterInterceptorContext   context )   throws   IOException ,   WebApplicationException   { \n     }  }",
            "title": "WriterInterceptor"
        },
        {
            "location": "/installers/jersey-ext/#containerrequestfilter",
            "text": "Any class implementing  javax . ws . rs . container . ContainerRequestFilter  (or extending abstract class implementing it).\nUseful for  request modifications .  @Provider  public   class   MyContainerRequestFilter   implements   ContainerRequestFilter   { \n\n     @Override \n     public   void   filter ( ContainerRequestContext   requestContext )   throws   IOException   { \n     }  }",
            "title": "ContainerRequestFilter"
        },
        {
            "location": "/installers/jersey-ext/#containerresponsefilter",
            "text": "Any class implementing  javax . ws . rs . container . ContainerResponseFilter  (or extending abstract class implementing it).\nUseful for  response modifications .  @Provider  public   class   MyContainerResponseFilter   implements   ContainerResponseFilter   { \n\n     @Override \n     public   void   filter ( ContainerRequestContext   requestContext ,   ContainerResponseContext   responseContext )   throws   IOException   { \n     }  }",
            "title": "ContainerResponseFilter"
        },
        {
            "location": "/installers/jersey-ext/#dynamicfeature",
            "text": "Any class implementing  javax . ws . rs . container . DynamicFeature  (or extending abstract class implementing it).\nUseful for conditional  activation of filters .  @Provider  public   class   MyDynamicFeature   implements   DynamicFeature   { \n\n     @Override \n     public   void   configure ( ResourceInfo   resourceInfo ,   FeatureContext   context )   { \n     }  }",
            "title": "DynamicFeature"
        },
        {
            "location": "/installers/jersey-ext/#applicationeventlistener",
            "text": "Any class implementing  org . glassfish . jersey . server . monitoring . ApplicationEventListener  (or extending abstract class implementing it).  @Provider  public   class   MyApplicationEventListener   implements   ApplicationEventListener   { \n\n     @Override \n     public   void   onEvent ( ApplicationEvent   event )   { \n     } \n\n     @Override \n     public   RequestEventListener   onRequest ( RequestEvent   requestEvent )   { \n         return   null ; \n     }  }",
            "title": "ApplicationEventListener"
        },
        {
            "location": "/installers/jersey-feature/",
            "text": "Jersey feature installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nJerseyFeatureInstaller\n\n\n\n\nRecognition\n\u00b6\n\n\nDetects classes implementing \njavax\n.\nws\n.\nrs\n.\ncore\n.\nFeature\n and register their instances in jersey.\n\n\nIt may be useful to configure jersey inside guice components:\n\n\npublic\n \nclass\n \nMyClass\n \n{\n\n    \n...\n   \n    \npublic\n \nstatic\n \nclass\n \nConfigurationFeature\n \nimplements\n \nFeature\n \n{\n\n        \n@Override\n\n        \npublic\n \nboolean\n \nconfigure\n(\nFeatureContext\n \ncontext\n)\n \n{\n\n            \ncontext\n.\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n            \ncontext\n.\nregister\n(\nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n            \nreturn\n \ntrue\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nInner classes are also recognized by classpath scan.\n\n\n\n\nBut often the same could be achieved by injecting \nEnvironment\n instance.\n\n\n@Singleton\n\n\npublic\n \nclass\n \nMyClass\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nMyClass\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\n\n                \nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n    \n}\n    \n\n}",
            "title": "Jersey feature"
        },
        {
            "location": "/installers/jersey-feature/#jersey-feature-installer",
            "text": "CoreInstallersBundle /  JerseyFeatureInstaller",
            "title": "Jersey feature installer"
        },
        {
            "location": "/installers/jersey-feature/#recognition",
            "text": "Detects classes implementing  javax . ws . rs . core . Feature  and register their instances in jersey.  It may be useful to configure jersey inside guice components:  public   class   MyClass   { \n     ...    \n     public   static   class   ConfigurationFeature   implements   Feature   { \n         @Override \n         public   boolean   configure ( FeatureContext   context )   { \n             context . register ( RolesAllowedDynamicFeature . class ); \n             context . register ( new   AuthValueFactoryProvider . Binder ( User . class )); \n             return   true ; \n         } \n     }  }    Inner classes are also recognized by classpath scan.   But often the same could be achieved by injecting  Environment  instance.  @Singleton  public   class   MyClass   { \n\n     @Inject \n     public   MyClass ( Environment   environment )   { \n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n         environment . jersey (). register ( \n                 new   AuthValueFactoryProvider . Binder ( User . class )); \n     }      }",
            "title": "Recognition"
        },
        {
            "location": "/installers/eager/",
            "text": "Eager singleton installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nEagerSingletonInstaller\n\n\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@EagerSingleton\n annotation and register them in guice injector. \nIt is equivalent of eager singleton registration \nbind\n(\ntype\n).\nasEagerSingleton\n()\n.\n\n\nUseful in case when you have bean not injected by other beans (so guice can't register\nit through aot). Normally, you would have to manually register such bean in module.\n\n\nMost likely, such bean will contain initialization logic. \nIdeal for cases not directly covered by installers. For example:\n\n\n@EagerSingleton\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nLifeCycle\n.\nListener\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nMyListener\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nenvironment\n.\nlifecicle\n.\naddListener\n(\nthis\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nClass will be recognized by eager singleton installer, environment object injected by guice and we manually register listener.\n\n\nMay be used in conjunction with \n@PostConstruct\n annotations (e.g. using \next-annotations\n):\ninstaller finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should\nbe used for quick prototyping only.",
            "title": "Eager singleton"
        },
        {
            "location": "/installers/eager/#eager-singleton-installer",
            "text": "CoreInstallersBundle /  EagerSingletonInstaller",
            "title": "Eager singleton installer"
        },
        {
            "location": "/installers/eager/#recognition",
            "text": "Detects classes annotated with  @EagerSingleton  annotation and register them in guice injector. \nIt is equivalent of eager singleton registration  bind ( type ). asEagerSingleton () .  Useful in case when you have bean not injected by other beans (so guice can't register\nit through aot). Normally, you would have to manually register such bean in module.  Most likely, such bean will contain initialization logic. \nIdeal for cases not directly covered by installers. For example:  @EagerSingleton  public   class   MyListener   implements   LifeCycle . Listener   { \n\n     @Inject \n     public   MyListener ( Environment   environment )   { \n         environment . lifecicle . addListener ( this ); \n     }  }   Class will be recognized by eager singleton installer, environment object injected by guice and we manually register listener.  May be used in conjunction with  @PostConstruct  annotations (e.g. using  ext-annotations ):\ninstaller finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should\nbe used for quick prototyping only.",
            "title": "Recognition"
        },
        {
            "location": "/installers/plugin/",
            "text": "Plugin installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nPluginInstaller\n\n\n\n\nAllows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case).  \n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with guicey \n@Plugin\n annotation and bind them into set or map using guice \n\nmultibindings\n mechanism.\n\n\nSuppose you have plugin interface \npublic\n \ninterface\n \nPluginInterface\n.\n\n\nAnnotate plugin implementations with \n@Plugin\n:\n\n\n@Plugin\n(\nPluginInterface\n.\nclass\n)\n\n\npublic\n \nclass\n \nPluginImpl1\n \nimplements\n \nPluginInterface\n\n\n\n\n\n\nNow all implementations could be autowired as\n\n\n@Inject\n \nSet\n<\nPluginInterface\n>\n \nplugins\n;\n\n\n\n\n\n\n\n\nWarning\n\n\nAt least one implementation must be provided because otherwise guicey will not be able to register\nSet\n binding and guice startup will fail.\nIf no plugins situation is possible, then you will have to manually register empty (default)\nplugins binding: \n\npublic\n \nclass\n \nMyModule\n \nextends\n \nAbstractModule\n \n{\n    \n    \n@Override\n\n    \nprotected\n \nconfigure\n()\n \n{\n\n        \nMultibinder\n.\nnewSetBinder\n(\nbinder\n(),\n \nPluginInterface\n.\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\nGuicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting.\n\n\n\n\nNamed plugins\n\u00b6\n\n\nSometimes it's required to have named plugin mapping: to bind, Map\n instead of simple set.\nFor example, when you have multiple authorization providers and each provider implementation must be registered with name.\n\n\nMost likely, you would use enum for keys:\n\n\npublic\n \nenum\n \nPluginKey\n \n{\n\n    \nFIRST\n,\n \nSECOND\n\n\n}\n\n\n\n\n\n\nCustom plugin annotation needs to be defined to use new keys:\n\n\n@Plugin\n(\nPluginInterface\n.\nclass\n)\n\n\n@Target\n(\nElementType\n.\nTYPE\n)\n\n\n@Retention\n(\nRetentionPolicy\n.\nRUNTIME\n)\n\n\npublic\n \n@interface\n \nMyPlugin\n \n{\n\n    \nPluginKey\n \nvalue\n();\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\nAnnotation itself is annotated with \n@Plugin\n, defining target plugin interface.\nGuicey will detect your custom annotation usage by analyzing its annotations. \n\n\n\n\nAnnotating plugin implementation:\n\n\n@MyPlugin\n(\nPluginKey\n.\nFIRST\n)\n\n\npublic\n \nclass\n \nPluginImpl1\n \nimplements\n \nPluginInterface\n\n\n\n\n\n\nAll plugins could be referenced as map:\n\n\n@Inject\n \nMap\n<\nPluginKey\n,\n \nPluginInterface\n>\n \nplugins\n;\n\n\n\n\n\n\n\n\nNote\n\n\nIt's not required to use enum as key. Any type could be set in your custom annotation. \nFor example, string key could be used: \n\npublic\n \n@interface\n \nMyPlugin\n \n{\n\n    \nString\n \nvalue\n();\n\n\n}\n\n\n\n@MyPlugin\n(\n\"first\"\n)\n\n\npublic\n \nclass\n \nPluginImpl1\n \nimplements\n \nPluginInterface\n\n\n\n@Inject\n \nMap\n<\nString\n,\n \nPluginInterface\n>\n \nplugins\n;\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nAs with simple plugin bindings, at least one plugin must be registered so guice could create map binding.\nOtherwise, you need to manually declare empty (default) plugnis map binding:\n\nMapBinder\n.\nnewMapBinder\n(\nbinder\n,\n \nkeyType\n,\n \npluginType\n);",
            "title": "Plugin"
        },
        {
            "location": "/installers/plugin/#plugin-installer",
            "text": "CoreInstallersBundle /  PluginInstaller   Allows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case).",
            "title": "Plugin installer"
        },
        {
            "location": "/installers/plugin/#recognition",
            "text": "Detects classes annotated with guicey  @Plugin  annotation and bind them into set or map using guice  multibindings  mechanism.  Suppose you have plugin interface  public   interface   PluginInterface .  Annotate plugin implementations with  @Plugin :  @Plugin ( PluginInterface . class )  public   class   PluginImpl1   implements   PluginInterface   Now all implementations could be autowired as  @Inject   Set < PluginInterface >   plugins ;    Warning  At least one implementation must be provided because otherwise guicey will not be able to register\nSet  binding and guice startup will fail.\nIf no plugins situation is possible, then you will have to manually register empty (default)\nplugins binding:  public   class   MyModule   extends   AbstractModule   {     \n     @Override \n     protected   configure ()   { \n         Multibinder . newSetBinder ( binder (),   PluginInterface . class ); \n     }  }  \n\nGuicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting.",
            "title": "Recognition"
        },
        {
            "location": "/installers/plugin/#named-plugins",
            "text": "Sometimes it's required to have named plugin mapping: to bind, Map  instead of simple set.\nFor example, when you have multiple authorization providers and each provider implementation must be registered with name.  Most likely, you would use enum for keys:  public   enum   PluginKey   { \n     FIRST ,   SECOND  }   Custom plugin annotation needs to be defined to use new keys:  @Plugin ( PluginInterface . class )  @Target ( ElementType . TYPE )  @Retention ( RetentionPolicy . RUNTIME )  public   @interface   MyPlugin   { \n     PluginKey   value ();  }    Note  Annotation itself is annotated with  @Plugin , defining target plugin interface.\nGuicey will detect your custom annotation usage by analyzing its annotations.    Annotating plugin implementation:  @MyPlugin ( PluginKey . FIRST )  public   class   PluginImpl1   implements   PluginInterface   All plugins could be referenced as map:  @Inject   Map < PluginKey ,   PluginInterface >   plugins ;    Note  It's not required to use enum as key. Any type could be set in your custom annotation. \nFor example, string key could be used:  public   @interface   MyPlugin   { \n     String   value ();  }  @MyPlugin ( \"first\" )  public   class   PluginImpl1   implements   PluginInterface  @Inject   Map < String ,   PluginInterface >   plugins ;      Warning  As with simple plugin bindings, at least one plugin must be registered so guice could create map binding.\nOtherwise, you need to manually declare empty (default) plugnis map binding: MapBinder . newMapBinder ( binder ,   keyType ,   pluginType );",
            "title": "Named plugins"
        },
        {
            "location": "/installers/servlet/",
            "text": "Web servlet installer\n\u00b6\n\n\n\n\nWebInstallersBundle / \nWebServletInstaller\n        \n\n\n\n\n\n\nWeb installers\n are not enabled by default. Enable it with \nbundle\n.\nuseWebInstallers\n()\n.\n\n\n\n\nRegister new servlet in main or admin contexts.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@javax.servlet.annotation.WebServlet\n annotation and register them in dropwizard environment.\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\n\nOnly the following annotation properties are supported: \nname\n, \nurlPatterns\n (or \nvalue\n), \ninitParams\n, \nasyncSupported\n.\n\n\nServlet name is not required. If name not provided, it will be generated as:\n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off.\nFor example, for class \"MyCoolServlet\" generated name will be \".mycool\".\n\n\n\n\nWarning\n\n\nOne or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings.\nIf you want to throw exception in this case, use special option:\n\nbundle\n.\noption\n(\nInstallersOptions\n.\nDenyServletRegistrationWithClash\n,\n \ntrue\n)\n\n\n\n\nNote that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later \n(and so exception will not be thrown).\n\n\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order servlets registration.\n\n@Order\n(\n10\n)\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n\n\n\n\n\n\n\nThere is a difference between using servlet installer and registering servlets with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\n\n\nInstaller use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).       \n\n\nAsync\n\u00b6\n\n\nExample of async servlet definition:\n\n\n@WebServlet\n(\nurlPatterns\n \n=\n \n\"/async\"\n,\n \nasyncSupported\n \n=\n \ntrue\n)\n\n\npublic\n \nclass\n \nAsyncServlet\n \nextends\n \nHttpServlet\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \ndoGet\n(\nHttpServletRequest\n \nreq\n,\n \nHttpServletResponse\n \nresp\n)\n \nthrows\n \nServletException\n,\n \nIOException\n \n{\n\n        \nfinal\n \nAsyncContext\n \ncontext\n \n=\n \nreq\n.\nstartAsync\n();\n\n        \ncontext\n.\nstart\n(()\n \n->\n \n{\n\n            \ncontext\n.\ngetResponse\n().\ngetWriter\n().\nwrite\n(\n\"done!\"\n);\n\n            \ncontext\n.\ncomplete\n();\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNote that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets.\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, installer target application context. If you want to install into admin context then \nuse guicey \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\n\nWill install servlet in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n{\n \n...\n \n}",
            "title": "Web servlet"
        },
        {
            "location": "/installers/servlet/#web-servlet-installer",
            "text": "WebInstallersBundle /  WebServletInstaller             Web installers  are not enabled by default. Enable it with  bundle . useWebInstallers () .   Register new servlet in main or admin contexts.",
            "title": "Web servlet installer"
        },
        {
            "location": "/installers/servlet/#recognition",
            "text": "Detects classes annotated with  @javax.servlet.annotation.WebServlet  annotation and register them in dropwizard environment.  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet   {   ...   }   Only the following annotation properties are supported:  name ,  urlPatterns  (or  value ),  initParams ,  asyncSupported .  Servlet name is not required. If name not provided, it will be generated as:\n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off.\nFor example, for class \"MyCoolServlet\" generated name will be \".mycool\".   Warning  One or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings.\nIf you want to throw exception in this case, use special option: bundle . option ( InstallersOptions . DenyServletRegistrationWithClash ,   true )  \n\nNote that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later \n(and so exception will not be thrown).    Tip  Use guicey  @Order  annotation to order servlets registration. @Order ( 10 )  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet      There is a difference between using servlet installer and registering servlets with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).  Installer use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).",
            "title": "Recognition"
        },
        {
            "location": "/installers/servlet/#async",
            "text": "Example of async servlet definition:  @WebServlet ( urlPatterns   =   \"/async\" ,   asyncSupported   =   true )  public   class   AsyncServlet   extends   HttpServlet   { \n\n     @Override \n     protected   void   doGet ( HttpServletRequest   req ,   HttpServletResponse   resp )   throws   ServletException ,   IOException   { \n         final   AsyncContext   context   =   req . startAsync (); \n         context . start (()   ->   { \n             context . getResponse (). getWriter (). write ( \"done!\" ); \n             context . complete (); \n         }); \n     }  }    Note that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets.",
            "title": "Async"
        },
        {
            "location": "/installers/servlet/#admin-context",
            "text": "By default, installer target application context. If you want to install into admin context then \nuse guicey  @AdminContext  annotation.  For example:   @AdminContext  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet   {   ...   }   Will install servlet in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet   {   ...   }",
            "title": "Admin context"
        },
        {
            "location": "/installers/filter/",
            "text": "Web filter installer\n\u00b6\n\n\n\n\nWebInstallersBundle / \nWebFilterInstaller\n        \n\n\n\n\n\n\nWeb installers\n are not enabled by default. Enable it with \nbundle\n.\nuseWebInstallers\n()\n.\n\n\n\n\nRegister new filter in main or admin contexts.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@javax.servlet.annotation.WebFilter\n annotation and register them in dropwizard environment.\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}\n\n\n\n\n\n\nOnly the following annotation properties are supported: \nfilterName\n, \nurlPatterns\n (or \nvalue\n), \nservletNames\n, \ndispatcherTypes\n, \ninitParams\n, \nasyncSupported\n.\n\n\n\n\nWarning\n\n\nUrl patterns and servlet names can't be used at the same time.\n\n\n\n\nFilter name is not required. If name not provided, then it will be generated as: \n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off.\nFor example, for class \"MyCoolFilter\" generated name will be \".mycool\".\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order servlets registration.\n\n@Order\n(\n10\n)\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}\n\n\n\n\n\n\n\n\nThere is a difference between using filter installer and registering filters with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\n\n\nInstaller use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata).       \n\n\nAsync\n\u00b6\n\n\nExample of async filter definition:\n\n\n@WebFilter\n(\nurlPatterns\n \n=\n \n\"/asyncfilter\"\n,\n \nasyncSupported\n \n=\n \ntrue\n)\n\n\npublic\n \nclass\n \nAsyncFilter\n \nimplements\n \nFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninit\n(\nFilterConfig\n \nfilterConfig\n)\n \nthrows\n \nServletException\n \n{\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndoFilter\n(\nServletRequest\n \nrequest\n,\n \nServletResponse\n \nresponse\n,\n \nFilterChain\n \nchain\n)\n \nthrows\n \nIOException\n,\n \nServletException\n \n{\n\n        \nfinal\n \nAsyncContext\n \ncontext\n \n=\n \nrequest\n.\nstartAsync\n();\n\n        \ncontext\n.\nstart\n(()\n \n->\n \n{\n\n            \ncontext\n.\ngetResponse\n().\nwriter\n.\nwrite\n(\n\"done!\"\n);\n\n            \ncontext\n.\ncomplete\n();\n\n        \n});\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndestroy\n()\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNote that guice servlet module does not allow using async filters, so installer is the only option to install async filters.\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, installer target application context. If you want to install into admin context then \nuse guicey \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}\n\n\n\n\n\n\nWill install filter in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}",
            "title": "Web filter"
        },
        {
            "location": "/installers/filter/#web-filter-installer",
            "text": "WebInstallersBundle /  WebFilterInstaller             Web installers  are not enabled by default. Enable it with  bundle . useWebInstallers () .   Register new filter in main or admin contexts.",
            "title": "Web filter installer"
        },
        {
            "location": "/installers/filter/#recognition",
            "text": "Detects classes annotated with  @javax.servlet.annotation.WebFilter  annotation and register them in dropwizard environment.  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }   Only the following annotation properties are supported:  filterName ,  urlPatterns  (or  value ),  servletNames ,  dispatcherTypes ,  initParams ,  asyncSupported .   Warning  Url patterns and servlet names can't be used at the same time.   Filter name is not required. If name not provided, then it will be generated as: \n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off.\nFor example, for class \"MyCoolFilter\" generated name will be \".mycool\".   Tip  Use guicey  @Order  annotation to order servlets registration. @Order ( 10 )  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }     There is a difference between using filter installer and registering filters with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).  Installer use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata).",
            "title": "Recognition"
        },
        {
            "location": "/installers/filter/#async",
            "text": "Example of async filter definition:  @WebFilter ( urlPatterns   =   \"/asyncfilter\" ,   asyncSupported   =   true )  public   class   AsyncFilter   implements   Filter   { \n\n     @Override \n     public   void   init ( FilterConfig   filterConfig )   throws   ServletException   { \n     } \n\n     @Override \n     public   void   doFilter ( ServletRequest   request ,   ServletResponse   response ,   FilterChain   chain )   throws   IOException ,   ServletException   { \n         final   AsyncContext   context   =   request . startAsync (); \n         context . start (()   ->   { \n             context . getResponse (). writer . write ( \"done!\" ); \n             context . complete (); \n         }); \n     } \n\n     @Override \n     public   void   destroy ()   { \n     }  }    Note that guice servlet module does not allow using async filters, so installer is the only option to install async filters.",
            "title": "Async"
        },
        {
            "location": "/installers/filter/#admin-context",
            "text": "By default, installer target application context. If you want to install into admin context then \nuse guicey  @AdminContext  annotation.  For example:   @AdminContext  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }   Will install filter in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }",
            "title": "Admin context"
        },
        {
            "location": "/installers/listener/",
            "text": "Web listener installer\n\u00b6\n\n\n\n\nWebInstallersBundle / \nWebListenerInstaller\n        \n\n\n\n\n\n\nWeb installers\n are not enabled by default. Enable it with \nbundle\n.\nuseWebInstallers\n()\n.\n\n\n\n\nRegister new web listener in main or admin contexts.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@javax.servlet.annotation.WebListener\n annotation and register them in dropwizard environment.\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n,\n \nServletRequestListener\n \n{...}\n\n\n\n\n\n\n\n\nListener could implement multiple listener interfaces and all types will be registered.\n\n\n\n\nSupported listeners (the same as declared in annotation):\n\n\n\n\njavax.servlet.ServletContextListener\n\n\njavax.servlet.ServletContextAttributeListener\n\n\njavax.servlet.ServletRequestListener\n\n\njavax.servlet.ServletRequestAttributeListener\n\n\njavax.servlet.http.HttpSessionListener\n\n\njavax.servlet.http.HttpSessionAttributeListener\n\n\njavax.servlet.http.HttpSessionIdListener\n\n\n\n\n\n\nBy default, dropwizard is not configured to support sessions. If you define session listeners without configured session support\nthen warning will be logged (and servlet listeners will actually not be registered).\nError is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work).\nIf you want to throw exception in such case, use special option:\n\nbundle\n.\noption\n(\nInstallersOptions\n.\nDenySessionListenersWithoutSession\n,\n \ntrue\n)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order servlets registration.\n\n@Order\n(\n10\n)\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n \n{...}\n\n\n\n\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, installer target application context. If you want to install into admin context then \nuse guicey \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n \n{...}\n\n\n\n\n\n\nWill install filter in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n \n{...}",
            "title": "Web listener"
        },
        {
            "location": "/installers/listener/#web-listener-installer",
            "text": "WebInstallersBundle /  WebListenerInstaller             Web installers  are not enabled by default. Enable it with  bundle . useWebInstallers () .   Register new web listener in main or admin contexts.",
            "title": "Web listener installer"
        },
        {
            "location": "/installers/listener/#recognition",
            "text": "Detects classes annotated with  @javax.servlet.annotation.WebListener  annotation and register them in dropwizard environment.  @WebListener  public   class   MyListener   implements   ServletContextListener ,   ServletRequestListener   {...}    Listener could implement multiple listener interfaces and all types will be registered.   Supported listeners (the same as declared in annotation):   javax.servlet.ServletContextListener  javax.servlet.ServletContextAttributeListener  javax.servlet.ServletRequestListener  javax.servlet.ServletRequestAttributeListener  javax.servlet.http.HttpSessionListener  javax.servlet.http.HttpSessionAttributeListener  javax.servlet.http.HttpSessionIdListener    By default, dropwizard is not configured to support sessions. If you define session listeners without configured session support\nthen warning will be logged (and servlet listeners will actually not be registered).\nError is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work).\nIf you want to throw exception in such case, use special option: bundle . option ( InstallersOptions . DenySessionListenersWithoutSession ,   true )      Tip  Use guicey  @Order  annotation to order servlets registration. @Order ( 10 )  @WebListener  public   class   MyListener   implements   ServletContextListener   {...}",
            "title": "Recognition"
        },
        {
            "location": "/installers/listener/#admin-context",
            "text": "By default, installer target application context. If you want to install into admin context then \nuse guicey  @AdminContext  annotation.  For example:   @AdminContext  @WebListener  public   class   MyListener   implements   ServletContextListener   {...}   Will install filter in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebListener  public   class   MyListener   implements   ServletContextListener   {...}",
            "title": "Admin context"
        },
        {
            "location": "/examples/authentication/",
            "text": "Authentication\n\u00b6\n\n\nExample of \ndropwizard authentication\n usage with guice.\n\n\nSimple auth\n\u00b6\n\n\nUsing \ndropwizard oauth\n example as basement.\nOther auth types are configured in similar way.\n\n\n@Provider\n\n\npublic\n \nclass\n \nOAuthDynamicFeature\n \nextends\n \nAuthDynamicFeature\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nOAuthDynamicFeature\n(\nOAuthAuthenticator\n \nauthenticator\n,\n \n                                \nUserAuthorizer\n \nauthorizer\n,\n \n                                \nEnvironment\n \nenvironment\n)\n \n{\n\n        \nsuper\n(\nnew\n \nOAuthCredentialAuthFilter\n.\nBuilder\n<\nUser\n>()\n\n                \n.\nsetAuthenticator\n(\nauthenticator\n)\n\n                \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                \n.\nsetPrefix\n(\n\"Bearer\"\n)\n\n                \n.\nbuildAuthFilter\n());\n\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n    \n}\n\n\n    \n// classes below may be external (internal for simplicity)\n\n\n    \n@Singleton\n\n    \npublic\n \nstatic\n \nclass\n \nOAuthAuthenticator\n \nimplements\n \nAuthenticator\n<\nString\n,\n \nUser\n>\n \n{\n\n\n        \n@Override\n\n        \npublic\n \nOptional\n<\nUser\n>\n \nauthenticate\n(\nString\n \ncredentials\n)\n \nthrows\n \nAuthenticationException\n \n{\n\n            \nreturn\n \nOptional\n.\nfromNullable\n(\n\"valid\"\n.\nequals\n(\ncredentials\n)\n \n?\n \nnew\n \nUser\n()\n \n:\n \nnull\n);\n        \n}\n\n    \n}\n\n\n    \n@Singleton\n\n    \npublic\n \nstatic\n \nclass\n \nUserAuthorizer\n \nimplements\n \nAuthorizer\n<\nUser\n>\n \n{\n\n        \n@Override\n\n        \npublic\n \nboolean\n \nauthorize\n(\nUser\n \nuser\n,\n \nString\n \nrole\n)\n \n{\n\n            \nreturn\n \nuser\n.\ngetName\n().\nequals\n(\n\"good-guy\"\n)\n \n&&\n \nrole\n.\nequals\n(\n\"ADMIN\"\n);\n\n        \n}\n\n    \n}\n   \n\n}\n\n\n\n\n\n\nClass recognized with \njersey installer\n.\n\nOAuthAuthenticator\n and \nOAuthAuthorizer\n are simple guice beans (no special installation required).\n\n\nConstructor injection used to obtain required guice managed instances and then configure\nauthentication the same way as described in dropwizard docs.\n\n\nIf auto configuration is enabled, then class will be resolved and installed automatically.\n\n\nChained auth\n\u00b6\n\n\nChained auth\n is useful to support different authentication schemes.\n\n\nIntegration approach is the same as in simple case:\n\n\n@Provider\n\n\npublic\n \nclass\n \nChainedAuthDynamicFeature\n \nextends\n \nAuthDynamicFeature\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nChainedAuthDynamicFeature\n(\nBasicAuthenticator\n \nbasicAuthenticator\n,\n\n                                      \nOAuthAuthenticator\n \noauthAuthenticator\n,\n \n                                      \nUserAuthorizer\n \nauthorizer\n,\n \n                                      \nEnvironment\n \nenvironment\n)\n \n{\n\n        \nsuper\n(\nnew\n \nChainedAuthFilter\n(\nArrays\n.\nasList\n(\n\n                \nnew\n \nBasicCredentialAuthFilter\n.\nBuilder\n<>()\n\n                            \n.\nsetAuthenticator\n(\nbasicAuthenticator\n)\n\n                            \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                            \n.\nsetPrefix\n(\n\"Basic\"\n)\n\n                            \n.\nbuildAuthFilter\n(),\n\n                \nnew\n \nOAuthCredentialAuthFilter\n.\nBuilder\n<>()\n\n                            \n.\nsetAuthenticator\n(\noauthAuthenticator\n)\n\n                            \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                            \n.\nsetPrefix\n(\n\"Bearer\"\n)\n\n                            \n.\nbuildAuthFilter\n()\n\n        \n)));\n                \n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n    \n}\n   \n\n}\n\n\n\n\n\n\nPolymorphic auth\n\u00b6\n\n\nPolymorphic auth\n allows using different auth schemes simultaneously.\n\n\nIntegration approach is the same as in simple case:\n\n\n@Provider\n\n\npublic\n \nclass\n \nPolyAuthDynamicFeature\n \nextends\n \nPolymorphicAuthDynamicFeature\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nPolyAuthDynamicFeature\n(\nBasicAuthenticator\n \nbasicAuthenticator\n,\n\n                                   \nOauthAuthenticator\n \noauthAuthenticator\n,\n\n                                   \nUserAuthorizer\n \nauthorizer\n,\n\n                                   \nEnvironment\n \nenvironment\n)\n \n{\n\n        \nsuper\n(\nImmutableMap\n.\nof\n(\n\n                  \nBasicPrincipal\n.\nclass\n,\n \nnew\n \nBasicCredentialAuthFilter\n.\nBuilder\n<\nBasicPrincipal\n>()\n\n                                                \n.\nsetAuthenticator\n(\nbasicAuthenticator\n)\n\n                                                \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                                                \n.\nsetRealm\n(\n\"SUPER SECRET STUFF\"\n)\n\n                                                \n.\nbuildAuthFilter\n(),\n\n                  \nOAuthPrincipal\n.\nclass\n,\n \nnew\n \nOAuthCredentialAuthFilter\n.\nBuilder\n<\nOAuthPrincipal\n>()\n\n                                                \n.\nsetAuthenticator\n(\noauthAuthenticator\n)\n\n                                                \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                                                \n.\nsetPrefix\n(\n\"Bearer\"\n)\n\n                                                \n.\nbuildAuthFilter\n()));\n             \n\n        \nfinal\n \nAbstractBinder\n \nbinder\n \n=\n \nnew\n \nPolymorphicAuthValueFactoryProvider\n.\nBinder\n<>(\n\n            \nImmutableSet\n.\nof\n(\nBasicPrincipal\n.\nclass\n,\n \nOAuthPrincipal\n.\nclass\n));\n\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nbinder\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n    \n}\n\n\n}",
            "title": "Authentication"
        },
        {
            "location": "/examples/authentication/#authentication",
            "text": "Example of  dropwizard authentication  usage with guice.",
            "title": "Authentication"
        },
        {
            "location": "/examples/authentication/#simple-auth",
            "text": "Using  dropwizard oauth  example as basement.\nOther auth types are configured in similar way.  @Provider  public   class   OAuthDynamicFeature   extends   AuthDynamicFeature   { \n\n     @Inject \n     public   OAuthDynamicFeature ( OAuthAuthenticator   authenticator ,  \n                                 UserAuthorizer   authorizer ,  \n                                 Environment   environment )   { \n         super ( new   OAuthCredentialAuthFilter . Builder < User >() \n                 . setAuthenticator ( authenticator ) \n                 . setAuthorizer ( authorizer ) \n                 . setPrefix ( \"Bearer\" ) \n                 . buildAuthFilter ()); \n\n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n         environment . jersey (). register ( new   AuthValueFactoryProvider . Binder ( User . class )); \n     } \n\n     // classes below may be external (internal for simplicity) \n\n     @Singleton \n     public   static   class   OAuthAuthenticator   implements   Authenticator < String ,   User >   { \n\n         @Override \n         public   Optional < User >   authenticate ( String   credentials )   throws   AuthenticationException   { \n             return   Optional . fromNullable ( \"valid\" . equals ( credentials )   ?   new   User ()   :   null );          } \n     } \n\n     @Singleton \n     public   static   class   UserAuthorizer   implements   Authorizer < User >   { \n         @Override \n         public   boolean   authorize ( User   user ,   String   role )   { \n             return   user . getName (). equals ( \"good-guy\" )   &&   role . equals ( \"ADMIN\" ); \n         } \n     }     }   Class recognized with  jersey installer . OAuthAuthenticator  and  OAuthAuthorizer  are simple guice beans (no special installation required).  Constructor injection used to obtain required guice managed instances and then configure\nauthentication the same way as described in dropwizard docs.  If auto configuration is enabled, then class will be resolved and installed automatically.",
            "title": "Simple auth"
        },
        {
            "location": "/examples/authentication/#chained-auth",
            "text": "Chained auth  is useful to support different authentication schemes.  Integration approach is the same as in simple case:  @Provider  public   class   ChainedAuthDynamicFeature   extends   AuthDynamicFeature   { \n\n     @Inject \n     public   ChainedAuthDynamicFeature ( BasicAuthenticator   basicAuthenticator , \n                                       OAuthAuthenticator   oauthAuthenticator ,  \n                                       UserAuthorizer   authorizer ,  \n                                       Environment   environment )   { \n         super ( new   ChainedAuthFilter ( Arrays . asList ( \n                 new   BasicCredentialAuthFilter . Builder <>() \n                             . setAuthenticator ( basicAuthenticator ) \n                             . setAuthorizer ( authorizer ) \n                             . setPrefix ( \"Basic\" ) \n                             . buildAuthFilter (), \n                 new   OAuthCredentialAuthFilter . Builder <>() \n                             . setAuthenticator ( oauthAuthenticator ) \n                             . setAuthorizer ( authorizer ) \n                             . setPrefix ( \"Bearer\" ) \n                             . buildAuthFilter () \n         )));                 \n\n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n         environment . jersey (). register ( new   AuthValueFactoryProvider . Binder ( User . class )); \n     }     }",
            "title": "Chained auth"
        },
        {
            "location": "/examples/authentication/#polymorphic-auth",
            "text": "Polymorphic auth  allows using different auth schemes simultaneously.  Integration approach is the same as in simple case:  @Provider  public   class   PolyAuthDynamicFeature   extends   PolymorphicAuthDynamicFeature   { \n\n     @Inject \n     public   PolyAuthDynamicFeature ( BasicAuthenticator   basicAuthenticator , \n                                    OauthAuthenticator   oauthAuthenticator , \n                                    UserAuthorizer   authorizer , \n                                    Environment   environment )   { \n         super ( ImmutableMap . of ( \n                   BasicPrincipal . class ,   new   BasicCredentialAuthFilter . Builder < BasicPrincipal >() \n                                                 . setAuthenticator ( basicAuthenticator ) \n                                                 . setAuthorizer ( authorizer ) \n                                                 . setRealm ( \"SUPER SECRET STUFF\" ) \n                                                 . buildAuthFilter (), \n                   OAuthPrincipal . class ,   new   OAuthCredentialAuthFilter . Builder < OAuthPrincipal >() \n                                                 . setAuthenticator ( oauthAuthenticator ) \n                                                 . setAuthorizer ( authorizer ) \n                                                 . setPrefix ( \"Bearer\" ) \n                                                 . buildAuthFilter ()));              \n\n         final   AbstractBinder   binder   =   new   PolymorphicAuthValueFactoryProvider . Binder <>( \n             ImmutableSet . of ( BasicPrincipal . class ,   OAuthPrincipal . class )); \n\n         environment . jersey (). register ( binder ); \n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n     }  }",
            "title": "Polymorphic auth"
        },
        {
            "location": "/examples/governator/",
            "text": "Governator integration\n\u00b6\n\n\nInclude the \nNetflix Governator\n dependency:\n\n\ncompile\n \n\"com.netflix.governator:governator:1.5.11\"\n\n\n\n\n\n\nGovernator \nowns injector creation\n, \nso we need to create custom guicey \nInjectorFactory\n\n\npublic\n \nclass\n \nGovernatorInjectorFactory\n \nimplements\n \nInjectorFactory\n \n{\n\n    \npublic\n \nInjector\n \ncreateInjector\n(\nfinal\n \nStage\n \nstage\n,\n \nfinal\n \nIterable\n<?\n \nextends\n \nModule\n>\n \nmodules\n)\n \n{\n\n        \nreturn\n \nLifecycleInjector\n.\nbuilder\n().\nwithModules\n(\nmodules\n).\ninStage\n(\nstage\n).\nbuild\n().\ncreateInjector\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nConfigure new factory in guice bundle:\n\n\n@Override\n\n\npublic\n \nvoid\n \ninitialize\n(\nBootstrap\n<\nConfiguration\n>\n \nbootstrap\n)\n \n{\n\n    \nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\ninjectorFactory\n(\nnew\n \nGovernatorInjectorFactory\n())\n\n            \n.\nenableAutoConfig\n(\n\"com.mycompany.myapp\"\n)\n\n            \n...\n\n            \n.\nbuild\n()\n\n    \n);\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\nAuto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package).\n\n\n\n\nGovernator Lifecycle\n\u00b6\n\n\nMany Governator enhancements are only available when the Governator \nLifecycleManager\n \nis properly \nstarted and closed\n \nwith the application. \n\n\nUse dropwizard's \nmanaged object\n \nto control governator lifecycle:\n\n\nimport\n \nio.dropwizard.lifecycle.Managed\n;\n\n\nimport\n \nru.vyarus.dropwizard.guice.GuiceBundle\n;\n\n\nimport\n \ncom.netflix.governator.lifecycle.LifecycleManager\n;\n\n\nimport\n \njavax.inject.Inject\n;\n\n\n\npublic\n \nclass\n \nGovernatorLifecycle\n \nimplements\n \nManaged\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nLifecycleManager\n \nmanager\n;\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n        \nmanager\n.\nstart\n();\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstop\n()\n \nthrows\n \nException\n \n{\n\n        \nmanager\n.\nclose\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nGuicey will find this managed bean, create governator injector (using custom factory), create managed bean instance and register it in dropwizard. \nThis will \"bind\" governator lifecycle to dropwizard lifecycle.\n\n\n\n\nNote\n\n\nIf you need to run this managed before or after some other dropwizard managed use guicey \n@Order annotation\n.",
            "title": "Governator"
        },
        {
            "location": "/examples/governator/#governator-integration",
            "text": "Include the  Netflix Governator  dependency:  compile   \"com.netflix.governator:governator:1.5.11\"   Governator  owns injector creation , \nso we need to create custom guicey  InjectorFactory  public   class   GovernatorInjectorFactory   implements   InjectorFactory   { \n     public   Injector   createInjector ( final   Stage   stage ,   final   Iterable <?   extends   Module >   modules )   { \n         return   LifecycleInjector . builder (). withModules ( modules ). inStage ( stage ). build (). createInjector (); \n     }  }   Configure new factory in guice bundle:  @Override  public   void   initialize ( Bootstrap < Configuration >   bootstrap )   { \n     bootstrap . addBundle ( GuiceBundle . builder () \n             . injectorFactory ( new   GovernatorInjectorFactory ()) \n             . enableAutoConfig ( \"com.mycompany.myapp\" ) \n             ... \n             . build () \n     );  }    Note  Auto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package).",
            "title": "Governator integration"
        },
        {
            "location": "/examples/governator/#governator-lifecycle",
            "text": "Many Governator enhancements are only available when the Governator  LifecycleManager  \nis properly  started and closed  \nwith the application.   Use dropwizard's  managed object  \nto control governator lifecycle:  import   io.dropwizard.lifecycle.Managed ;  import   ru.vyarus.dropwizard.guice.GuiceBundle ;  import   com.netflix.governator.lifecycle.LifecycleManager ;  import   javax.inject.Inject ;  public   class   GovernatorLifecycle   implements   Managed   { \n\n     @Inject \n     private   LifecycleManager   manager ; \n\n     @Override \n     public   void   start ()   throws   Exception   { \n         manager . start (); \n     } \n\n     @Override \n     public   void   stop ()   throws   Exception   { \n         manager . close (); \n     }  }   Guicey will find this managed bean, create governator injector (using custom factory), create managed bean instance and register it in dropwizard. \nThis will \"bind\" governator lifecycle to dropwizard lifecycle.   Note  If you need to run this managed before or after some other dropwizard managed use guicey  @Order annotation .",
            "title": "Governator Lifecycle"
        },
        {
            "location": "/extras/admin-rest/",
            "text": "Admin REST\n\u00b6\n\n\nAll rest resources could be \"published\" in the admin context too.  This is just an emulation of rest: the same resources \nare accessible in both contexts. On admin side special servlet simply redirects all incoming requests into jersey context.\n\n\nSuch approach is better than registering completely separate jersey context for admin rest because\nof no overhead and simplicity of jersey extensions management.\n\n\nConfiguration\n\u00b6\n\n\nTo install admin rest servlet, register bundle:\n\n\nbootstrap\n.\naddBundle\n(\nnew\n \nAdminRestBundle\n());\n\n\n\n\n\n\nIn this case rest is registered either to '/api/\n', if main context rest is mapped to root ('/\n')\nor to the same path as main context rest.\n\n\nTo register on custom path:\n\n\nbootstrap\n.\naddBundle\n(\nnew\n \nAdminRestBundle\n(\n\"/custom/*\"\n));\n\n\n\n\n\n\nSecurity\n\u00b6\n\n\nIn order to hide specific resource methods or entire resources on main context, annotate resource methods\nor resource class with \n@AdminResource\n annotation.\n\n\nFor example:\n\n\n@GET\n\n\n@Path\n(\n\"/admin\"\n)\n\n\n@AdminResource\n\n\npublic\n \nString\n \nadmin\n()\n \n{\n\n    \nreturn\n \n\"admin\"\n\n\n}\n\n\n\n\n\n\nThis (annotated) method will return 403 error when called from main context and process when called from admin context.\n\n\nThis is just the simplest option to control resources access. Any other method may be used (with some security\nframework or something else).",
            "title": "Admin REST"
        },
        {
            "location": "/extras/admin-rest/#admin-rest",
            "text": "All rest resources could be \"published\" in the admin context too.  This is just an emulation of rest: the same resources \nare accessible in both contexts. On admin side special servlet simply redirects all incoming requests into jersey context.  Such approach is better than registering completely separate jersey context for admin rest because\nof no overhead and simplicity of jersey extensions management.",
            "title": "Admin REST"
        },
        {
            "location": "/extras/admin-rest/#configuration",
            "text": "To install admin rest servlet, register bundle:  bootstrap . addBundle ( new   AdminRestBundle ());   In this case rest is registered either to '/api/ ', if main context rest is mapped to root ('/ ')\nor to the same path as main context rest.  To register on custom path:  bootstrap . addBundle ( new   AdminRestBundle ( \"/custom/*\" ));",
            "title": "Configuration"
        },
        {
            "location": "/extras/admin-rest/#security",
            "text": "In order to hide specific resource methods or entire resources on main context, annotate resource methods\nor resource class with  @AdminResource  annotation.  For example:  @GET  @Path ( \"/admin\" )  @AdminResource  public   String   admin ()   { \n     return   \"admin\"  }   This (annotated) method will return 403 error when called from main context and process when called from admin context.  This is just the simplest option to control resources access. Any other method may be used (with some security\nframework or something else).",
            "title": "Security"
        },
        {
            "location": "/extras/bom/",
            "text": "Guicey BOM\n\u00b6\n\n\n\n\nExtensions project\n module\n\n\n\n\nMaven BOM containing guicey and guicey ext modules versions. Also includes dropwizard and guice boms.\n\n\n\n\nTip\n\n\nBOM's are useful for versions management. After including bom you can simply include required dependencies\n(dropwizard, guice, guicey, guicey-ext) without versions: bom version will control all versions.\n\n\n\n\nSetup\n\u00b6\n\n\n\n\n\n\nMaven:\n\n\n<!-- Implicitly imports Dropwizard and Guice BOMs -->\n\n\n<dependencyManagement>\n\n    \n<dependencies>\n\n        \n<dependency>\n\n            \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n            \n<artifactId>\nguicey-bom\n</artifactId>\n\n            \n<version>\n0.2.1\n</version>\n\n            \n<type>\npom\n</type>\n\n            \n<scope>\nimport\n</scope>\n\n        \n</dependency>\n\n    \n</dependencies>\n\n\n</dependencyManagement>\n\n\n\n<!-- declare guice and ext modules without versions -->\n\n\n<dependencies>\n\n    \n<dependency>\n\n      \n<groupId>\nru.vyarus\n</groupId>\n\n      \n<artifactId>\ndropwizard-guicey\n</artifactId>\n\n    \n</dependency>\n\n    \n<!-- For example, using dropwizard module (without version) -->\n\n    \n<dependency>\n\n      \n<groupId>\nio.dropwizard\n</groupId>\n\n      \n<artifactId>\ndropwizard-auth\n</artifactId>\n\n    \n</dependency>\n\n    \n<!-- Example of extension module usage -->\n\n    \n<dependency>\n\n          \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n          \n<artifactId>\nguicey-eventbus\n</artifactId>\n\n        \n</dependency>\n\n\n</dependencies>\n\n\n\n\n\n\nGradle:\n\n\nplugins\n \n{\n\n    \nid\n \n\"io.spring.dependency-management\"\n \nversion\n \n\"0.6.1.RELEASE\"\n\n\n}\n\n\n\ndependencyManagement\n \n{\n\n    \n// Implicitly imports Dropwizard and Guice BOMs \n\n    \nimports\n \n{\n\n        \nmavenBom\n \n\"ru.vyarus.guicey:guicey-bom:0.2.1\"\n\n    \n}\n\n\n}\n\n\n\n// declare guice and ext modules without versions \n\n\ndependencies\n \n{\n\n    \ncompile\n \n'ru.vyarus.guicey:dropwizard-guicey'\n\n    \n// For example, using dropwizard module (without version)\n\n    \ncompile\n \n'io.dropwizard:dropwizard-auth'\n\n    \n// Example of extension module usage\n\n    \ncompile\n \n'ru.vyarus.guicey:guicey-eventbus'\n \n\n}\n\n\n\n\n\n\nSpring's \ndependency management plugin\n is required to import BOM.\n\n\nDependencies override\n\u00b6\n\n\nYou may override BOM version for any dependency by simply specifying exact version in dependecy declaration section.\n\n\nIf you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly:\n\n\n\n\nio.dropwizard:dropwizard-bom:$VERSION\n for dropwizard\n\n\ncom.google.inject:guice-bom:$VERSION\n for guice",
            "title": "BOM"
        },
        {
            "location": "/extras/bom/#guicey-bom",
            "text": "Extensions project  module   Maven BOM containing guicey and guicey ext modules versions. Also includes dropwizard and guice boms.   Tip  BOM's are useful for versions management. After including bom you can simply include required dependencies\n(dropwizard, guice, guicey, guicey-ext) without versions: bom version will control all versions.",
            "title": "Guicey BOM"
        },
        {
            "location": "/extras/bom/#setup",
            "text": "Maven:  <!-- Implicitly imports Dropwizard and Guice BOMs -->  <dependencyManagement> \n     <dependencies> \n         <dependency> \n             <groupId> ru.vyarus.guicey </groupId> \n             <artifactId> guicey-bom </artifactId> \n             <version> 0.2.1 </version> \n             <type> pom </type> \n             <scope> import </scope> \n         </dependency> \n     </dependencies>  </dependencyManagement>  <!-- declare guice and ext modules without versions -->  <dependencies> \n     <dependency> \n       <groupId> ru.vyarus </groupId> \n       <artifactId> dropwizard-guicey </artifactId> \n     </dependency> \n     <!-- For example, using dropwizard module (without version) --> \n     <dependency> \n       <groupId> io.dropwizard </groupId> \n       <artifactId> dropwizard-auth </artifactId> \n     </dependency> \n     <!-- Example of extension module usage --> \n     <dependency> \n           <groupId> ru.vyarus.guicey </groupId> \n           <artifactId> guicey-eventbus </artifactId> \n         </dependency>  </dependencies>   Gradle:  plugins   { \n     id   \"io.spring.dependency-management\"   version   \"0.6.1.RELEASE\"  }  dependencyManagement   { \n     // Implicitly imports Dropwizard and Guice BOMs  \n     imports   { \n         mavenBom   \"ru.vyarus.guicey:guicey-bom:0.2.1\" \n     }  }  // declare guice and ext modules without versions   dependencies   { \n     compile   'ru.vyarus.guicey:dropwizard-guicey' \n     // For example, using dropwizard module (without version) \n     compile   'io.dropwizard:dropwizard-auth' \n     // Example of extension module usage \n     compile   'ru.vyarus.guicey:guicey-eventbus'   }   Spring's  dependency management plugin  is required to import BOM.",
            "title": "Setup"
        },
        {
            "location": "/extras/bom/#dependencies-override",
            "text": "You may override BOM version for any dependency by simply specifying exact version in dependecy declaration section.  If you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly:   io.dropwizard:dropwizard-bom:$VERSION  for dropwizard  com.google.inject:guice-bom:$VERSION  for guice",
            "title": "Dependencies override"
        },
        {
            "location": "/extras/eventbus/",
            "text": "Guava EventBus integration\n\u00b6\n\n\n\n\nExtensions project\n module\n\n\n\n\nIntegrates \nGuava EventBus\n with guice.\n\n\nFeatures:\n\n\n\n\nEventBus available for injection (to publish events)\n\n\nAutomatic registration of listener methods (annotated with \n@Subscribe\n)\n\n\nConsole reporting of registered listeners\n\n\n\n\nSetup\n\u00b6\n\n\n\n\n\n\nAvoid version in dependency declaration below if you use \nextensions BOM\n. \n\n\nMaven:\n\n\n<dependency>\n\n  \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n  \n<artifactId>\nguicey-eventbus\n</artifactId>\n\n  \n<version>\n0.2.1\n</version>\n\n\n</dependency>\n\n\n\n\n\n\nGradle:\n\n\ncompile\n \n'ru.vyarus.guicey:guicey-eventbus:0.2.1'\n\n\n\n\n\n\nSee the most recent version in the badge above.\n\n\nUsage\n\u00b6\n\n\nRegister bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n        \n        \n.\nbundles\n(\nnew\n \nEventBusBundle\n())\n\n        \n...\n\n\n\n\n\n\nCreate event:\n\n\npublic\n \nclass\n \nMyEvent\n \n{\n\n    \n// some state\n\n\n}\n\n\n\n\n\n\nInject \nEventBus\n to publish new events.\n\n\npublic\n \nclass\n \nSomeService\n \n{\n\n    \n@Inject\n\n    \nprivate\n \nEVentBus\n \neventbus\n;\n    \n\n    \npublic\n \nvoid\n \ninSomeMethod\n()\n \n{\n\n        \nevetbus\n.\npost\n(\nnew\n \nMyEvent\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nListen for event:\n\n\npublic\n \nclass\n \nSomeOtherService\n \n{\n\n\n    \n@Subscribe\n\n    \npublic\n \nvoid\n \nonEvent\n(\nMyEvent\n \nevent\n)\n \n{\n\n         \n// handle event   \n\n    \n}\n\n\n}\n\n\n\n\n\n\nAfter server start you should see all registered event listeners in log:\n\n\nINFO  [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = \n\n    MyEvent\n        com.foo.something.SomeOtherService        \n\n\n\n\n\n\n\nNote\n\n\nOnly subscriptions of beans registered at the time of injector startup will be shown.\nFor example, if MyBean has subscription method but binding for it not declared (and noone depends on it)\nthen JIT binding will be created only somewhere later in time (when bean will be actually used) and \nso listener registration happen after server startup and will not be shown in console report.\n\n\n\n\nConsuming multiple events\n\u00b6\n\n\nNote that you can build event hierarchies and subscribe to some base event to receive any derived event.   \n\n\nTo receive all events use:\n\n\n@Subscribe\n\n\npublic\n \nvoid\n \nonEvent\n(\nObject\n \nevent\n){\n    \n\n}\n\n\n\n\n\n\nEvent bus\n\u00b6\n\n\nBy default, events will be handled synchronously (\nbus.push()\n waits while all subscribers processed).\n\n\nIf you want events to be async use custom eventbus:\n\n\nnew\n \nEventBusBundle\n(\n\n        \nnew\n \nAsyncEventBus\n(\nsomeExecutor\n)\n\n\n)\n\n\n\n\n\n\nBy default, event listeners considered not thread safe and so no parallel events processing (for single method) \nwill be performed. To mark subscriber as thread safe use \n@AllowConcurrentEvents\n:\n\n\n@Subscribe\n\n\n@AllowConcurrentEvents\n\n\npublic\n \nvoid\n \nonEvent\n(\nMyEvent\n \nevent\n)\n      \n\n\n\n\n\nIf listener method will fail to process event (throw exception) then other listeners will still be processed\nand failed listener exception will be logged. If you want to change this behaviour set custom exception \nhandler by creating custom eventbus instance:\n\n\nnew\n \nEventBusBundle\n(\n\n        \nnew\n \nEventBus\n(\ncustomExceptionHandler\n)\n\n\n)\n\n\n\n\n\n\nListeners recognition\n\u00b6\n\n\nGuice type listener used to intercept all beans instances. Each bean instance is registered in eventbus: \nit's valid behaviour for eventbus and only beans with actual listener methods will be registered.\n\n\nBut, it means that each bean class is checked: every method in class hierarchy. This is very fast and\ndoes not make problems for most of the cases. But, if you want, you can reduce the scope for checking by\nspecifying custom class matcher:\n\n\nnew\n \nEventBusBundle\n()\n\n    \n.\nwithMatcher\n(\nMatchers\n.\ninSubpackage\n(\n\"some.package\"\n))\n\n\n\n\n\n\nThis will only check beans in class and subpackages.\n\n\nIf you want maximum performance, then you can add extra marker annotation (e.g. \n@HasEvents\n) and reduce\nscope to just annotated classes:\n\n\nnew\n \nEventBusBundle\n()\n\n    \n.\nwithMatcher\n(\nMatchers\n.\nannotatedWith\n(\nHasEvents\n.\nclass\n))\n\n\n\n\n\n\nConsole reporting\n\u00b6\n\n\nYou can switch off console reporting (for example, if you have too much listeners):\n\n\nnew\n \nEventBusBundle\n().\nnoReport\n()\n\n\n\n\n\n\nImportant moment: reporting has to use reflection to get subscribers list. If reflection will fail with newer guava version\n(not yet supported), then simply disable reporting and everything will work.\n\n\nSubscribers info bean\n\u00b6\n\n\nSpecial guice bean registered and available for injection: \nEventSubscribersInfo\n.\nWith it you can get active listeners and used event types. Reporting use it for console report.\nIt may be useful for unit tests.\n\n\nAs described above, internally it use reflection to access eventbus listeners map.",
            "title": "Guava EventBus"
        },
        {
            "location": "/extras/eventbus/#guava-eventbus-integration",
            "text": "Extensions project  module   Integrates  Guava EventBus  with guice.  Features:   EventBus available for injection (to publish events)  Automatic registration of listener methods (annotated with  @Subscribe )  Console reporting of registered listeners",
            "title": "Guava EventBus integration"
        },
        {
            "location": "/extras/eventbus/#setup",
            "text": "Avoid version in dependency declaration below if you use  extensions BOM .   Maven:  <dependency> \n   <groupId> ru.vyarus.guicey </groupId> \n   <artifactId> guicey-eventbus </artifactId> \n   <version> 0.2.1 </version>  </dependency>   Gradle:  compile   'ru.vyarus.guicey:guicey-eventbus:0.2.1'   See the most recent version in the badge above.",
            "title": "Setup"
        },
        {
            "location": "/extras/eventbus/#usage",
            "text": "Register bundle:  GuiceBundle . builder ()         \n         . bundles ( new   EventBusBundle ()) \n         ...   Create event:  public   class   MyEvent   { \n     // some state  }   Inject  EventBus  to publish new events.  public   class   SomeService   { \n     @Inject \n     private   EVentBus   eventbus ;     \n\n     public   void   inSomeMethod ()   { \n         evetbus . post ( new   MyEvent ()); \n     }  }   Listen for event:  public   class   SomeOtherService   { \n\n     @Subscribe \n     public   void   onEvent ( MyEvent   event )   { \n          // handle event    \n     }  }   After server start you should see all registered event listeners in log:  INFO  [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = \n\n    MyEvent\n        com.foo.something.SomeOtherService           Note  Only subscriptions of beans registered at the time of injector startup will be shown.\nFor example, if MyBean has subscription method but binding for it not declared (and noone depends on it)\nthen JIT binding will be created only somewhere later in time (when bean will be actually used) and \nso listener registration happen after server startup and will not be shown in console report.",
            "title": "Usage"
        },
        {
            "location": "/extras/eventbus/#consuming-multiple-events",
            "text": "Note that you can build event hierarchies and subscribe to some base event to receive any derived event.     To receive all events use:  @Subscribe  public   void   onEvent ( Object   event ){      }",
            "title": "Consuming multiple events"
        },
        {
            "location": "/extras/eventbus/#event-bus",
            "text": "By default, events will be handled synchronously ( bus.push()  waits while all subscribers processed).  If you want events to be async use custom eventbus:  new   EventBusBundle ( \n         new   AsyncEventBus ( someExecutor )  )   By default, event listeners considered not thread safe and so no parallel events processing (for single method) \nwill be performed. To mark subscriber as thread safe use  @AllowConcurrentEvents :  @Subscribe  @AllowConcurrentEvents  public   void   onEvent ( MyEvent   event )         If listener method will fail to process event (throw exception) then other listeners will still be processed\nand failed listener exception will be logged. If you want to change this behaviour set custom exception \nhandler by creating custom eventbus instance:  new   EventBusBundle ( \n         new   EventBus ( customExceptionHandler )  )",
            "title": "Event bus"
        },
        {
            "location": "/extras/eventbus/#listeners-recognition",
            "text": "Guice type listener used to intercept all beans instances. Each bean instance is registered in eventbus: \nit's valid behaviour for eventbus and only beans with actual listener methods will be registered.  But, it means that each bean class is checked: every method in class hierarchy. This is very fast and\ndoes not make problems for most of the cases. But, if you want, you can reduce the scope for checking by\nspecifying custom class matcher:  new   EventBusBundle () \n     . withMatcher ( Matchers . inSubpackage ( \"some.package\" ))   This will only check beans in class and subpackages.  If you want maximum performance, then you can add extra marker annotation (e.g.  @HasEvents ) and reduce\nscope to just annotated classes:  new   EventBusBundle () \n     . withMatcher ( Matchers . annotatedWith ( HasEvents . class ))",
            "title": "Listeners recognition"
        },
        {
            "location": "/extras/eventbus/#console-reporting",
            "text": "You can switch off console reporting (for example, if you have too much listeners):  new   EventBusBundle (). noReport ()   Important moment: reporting has to use reflection to get subscribers list. If reflection will fail with newer guava version\n(not yet supported), then simply disable reporting and everything will work.",
            "title": "Console reporting"
        },
        {
            "location": "/extras/eventbus/#subscribers-info-bean",
            "text": "Special guice bean registered and available for injection:  EventSubscribersInfo .\nWith it you can get active listeners and used event types. Reporting use it for console report.\nIt may be useful for unit tests.  As described above, internally it use reflection to access eventbus listeners map.",
            "title": "Subscribers info bean"
        },
        {
            "location": "/extras/jdbi/",
            "text": "JDBI integration\n\u00b6\n\n\n\n\nExtensions project\n module\n\n\n\n\nIntegrates \nJDBI\n with guice. Based on \ndropwizard-jdbi\n integration.\n\n\nFeatures:\n\n\n\n\nDBI instance available for injection\n\n\nIntroduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional)\n\n\nRepositories (JDBI proxies for interfaces and abstract classes):\n\n\ninstalled automatically (when classpath scan enabled)\n\n\nare normal guice beans, supporting aop and participating in global (thread bound) transaction.\n\n\nno need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction.\n\n\n\n\n\n\nAutomatic installation for custom \nResultSetMapper\n \n\n\n\n\nAdded installers:\n\n\n\n\nRepositoryInstaller\n - sql proxies\n\n\nMapperInstaller\n - result set mappers  \n\n\n\n\nSetup\n\u00b6\n\n\n\n\n\n\nAvoid version in dependency declaration below if you use \nextensions BOM\n. \n\n\nMaven:\n\n\n<dependency>\n\n  \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n  \n<artifactId>\nguicey-jdbi\n</artifactId>\n\n  \n<version>\n0.2.1\n</version>\n\n\n</dependency>\n\n\n\n\n\n\nGradle:\n\n\ncompile\n \n'ru.vyarus.guicey:guicey-jdbi:0.2.1'\n\n\n\n\n\n\nSee the most recent version in the badge above.\n\n\nUsage\n\u00b6\n\n\nRegister bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n        \n        \n.\nbundles\n(\nJdbiBundle\n.<\nConfType\n>\nforDatabase\n((\nconf\n,\n \nenv\n)\n \n->\n \nconf\n.\ngetDatabase\n()))\n\n        \n...\n\n\n\n\n\n\nHere default DBI instance will be created from database configuration (much like it's described in \n\ndropwizard documentation\n).\n\n\nOr build DBI instance yourself:\n\n\nJdbiBundle\n.\nforDbi\n((\nconf\n,\n \nenv\n)\n \n->\n \nlocateDbi\n())\n\n\n\n\n\n\nUnit of work\n\u00b6\n\n\nUnit of work concept states for: every database related operation must be performed inside unit of work.\n\n\nIn DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of\nsql object proxies: if you create it on-demand it would always create new handle; if you want to combine\nmultiple objects in one transaction, you have to always create them manually for each transaction.\n\n\nIntegration removes these restrictions: dao (repository) objects are normal guice beans and transaction\nscope is controlled by \n@InTransaction\n annotation (note that such name was intentional to avoid confusion with\nDBI own's Transaction annotation and more common Transactional annotations).\n\n\nAt the beginning of unit of work, DBI handle is created and bound to thread (thread local).\nAll repositories are simply using this bound handle and so share transaction inside unit of work.\n\n\n@InTransaction\n\u00b6\n\n\nAnnotation on method or class declares transactional scope. For example:\n\n\n@Inject\n \nMyDAO\n \ndao\n\n\n\n@InTransaction\n\n\npublic\n \nResult\n \ndoSomething\n()\n \n{\n\n   \ndao\n.\nselect\n();\n\n   \n...\n\n\n}\n\n\n\n\n\n\nTransaction opened before doSomething() method and closed after it. \nDao call is also performed inside transaction.\nIf exception appears during execution, it's propagated and transaction rolled back.\n\n\nNested annotations are allowed (they simply ignored).\n\n\nNote that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). \nBut, for simplicity, you may think of it as the same things, if you always use \n@InTransaction\n annotation. \n\n\nIf required, you may use your own annotation for transaction definition:\n\n\nJdbiBundle\n.\nforDatabase\n((\nconf\n,\n \nenv\n)\n \n->\n \nconf\n.\ngetDatabase\n())\n\n    \n.\nwithTxAnnotations\n(\nMyCustomTransactional\n.\nclass\n);\n\n\n\n\n\n\nNote that this will override default annotation support. If you want to support multiple annotations then specify\nall of them:\n\n\nJdbiBundle\n.\nforDatabase\n((\nconf\n,\n \nenv\n)\n \n->\n \nconf\n.\ngetDatabase\n())\n\n    \n.\nwithTxAnnotations\n(\nInTransaction\n.\nclass\n,\n \nMyCustomTransactional\n.\nclass\n);\n\n\n\n\n\n\nContext Handle\n\u00b6\n\n\nInside unit of work you may reference current handle by using:\n\n\n@Inject\n \nProvider\n<\nHandle\n>\n\n\n\n\n\n\nManual transaction definition\n\u00b6\n\n\nYou may define transaction (with unit of work) without annotation using:\n\n\n@Inject\n \nTransactionTenpate\n \ntemplate\n;\n\n\n...\n\n\ntemplate\n.\ninTrabsansaction\n((\nhandle\n)\n \n->\n \ndoSomething\n())\n\n\n\n\n\n\nNote that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as \nwith annotation.\n\n\nRepository\n\u00b6\n\n\nDeclare repository (interface or abstract class) as usual, using DBI annotations. \nIt only must be annotated with \n@JdbiRepository\n so installer\ncould recognize it and register in guice context.\n\n\n\n\nSingleton scope will be forced for repositories.\n\n\n\n\n@JdbiRepository\n\n\n@InTransaction\n\n\npublic\n \ninterface\n \nMyRepository\n \n{\n     \n\n    \n@SqlQuery\n(\n\"select name from something where id = :id\"\n)\n\n    \nString\n \nfindNameById\n(\n@Bind\n(\n\"id\"\n)\n \nint\n \nid\n);\n\n\n}\n\n\n\n\n\n\nNote the use of \n@InTransaction\n: it was used to be able to call repository methods without extra annotations\n(the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand\nsql object proxies.\n\n\n@InTransaction\n annotation is handled using guice aop. You can use any other guice aop related features.\n\n\nYou can also use injection inside repositories, but only field injection:\n\n\npublic\n \nabstract\n \nclass\n \nMyRepo\n \n{\n\n    \n@Inject\n \nSomeBean\n \nbean\n;\n\n\n}\n\n\n\n\n\n\nConstructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able\nto construct proxy for class with constructor injection.\n\n\nDon't use DBI @Transaction and @CreateSqlObject annotations anymore\n: probably they will even work, but they are not\nneeded now and may confuse.\n\n\nAll installed repositories are reported into console:\n\n\nINFO  [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = \n\n    (ru.vyarus.guicey.jdbi.support.repository.SampleRepository)\n\n\n\n\n\nResult set mapper\n\u00b6\n\n\nIf you have custom implementations of \nResultSetMapper\n, it may be registered automatically. \nYou will be able to use injections there because mappers become ususal guice beans (singletons).\nWhen classpath scan is enabled, such classes will be searched and installed automatically.\n\n\npublic\n \nclass\n \nCustomMapper\n \nimplements\n \nResutlSetMapper\n<\nCustom\n>\n \n{\n\n    \n@Override\n\n    \npublic\n \nCusom\n \nmap\n(\nint\n \nrow\n,\n \nResultSet\n \nrs\n,\n \nStatementContext\n \nctx\n)\n \n{\n\n        \n// mapping here\n\n        \nreturn\n \ncustom\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAnd now Custom type could be used for queries:\n\n\n@JdbiRepository\n\n\n@InTransaction\n\n\npublic\n \ninterface\n \nCustomRepository\n \n{\n     \n\n    \n@SqlQuery\n(\n\"select * from custom where id = :id\"\n)\n\n    \nCustom\n \nfindNameById\n(\n@Bind\n(\n\"id\"\n)\n \nint\n \nid\n);\n\n\n}\n\n\n\n\n\n\nAll installed mappers are reported to console:\n\n\nINFO  [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = \n\n    Sample               (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper)\n\n\n\n\n\nManual unit of work definition\n\u00b6\n\n\nIf, for some reason, you don't need transaction at some place, you can declare raw unit of work and use \nassigned handle directly:\n\n\n@Inject\n \nUnitManager\n \nmanager\n;\n\n\n\nmanager\n.\nbeginUnit\n();\n\n\ntry\n \n{\n\n    \nHandle\n \nhandle\n \n=\n \nmanager\n.\nget\n();\n\n    \n// logic executed in unit of work but without transaction\n\n\n}\n \nfinally\n \n{\n\n    \nmanager\n.\nendUnit\n();\n\n\n}\n\n\n\n\n\n\nRepositories could also be called inside such manual unit (as unit of work is correctly started).",
            "title": "JDBI"
        },
        {
            "location": "/extras/jdbi/#jdbi-integration",
            "text": "Extensions project  module   Integrates  JDBI  with guice. Based on  dropwizard-jdbi  integration.  Features:   DBI instance available for injection  Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional)  Repositories (JDBI proxies for interfaces and abstract classes):  installed automatically (when classpath scan enabled)  are normal guice beans, supporting aop and participating in global (thread bound) transaction.  no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction.    Automatic installation for custom  ResultSetMapper     Added installers:   RepositoryInstaller  - sql proxies  MapperInstaller  - result set mappers",
            "title": "JDBI integration"
        },
        {
            "location": "/extras/jdbi/#setup",
            "text": "Avoid version in dependency declaration below if you use  extensions BOM .   Maven:  <dependency> \n   <groupId> ru.vyarus.guicey </groupId> \n   <artifactId> guicey-jdbi </artifactId> \n   <version> 0.2.1 </version>  </dependency>   Gradle:  compile   'ru.vyarus.guicey:guicey-jdbi:0.2.1'   See the most recent version in the badge above.",
            "title": "Setup"
        },
        {
            "location": "/extras/jdbi/#usage",
            "text": "Register bundle:  GuiceBundle . builder ()         \n         . bundles ( JdbiBundle .< ConfType > forDatabase (( conf ,   env )   ->   conf . getDatabase ())) \n         ...   Here default DBI instance will be created from database configuration (much like it's described in  dropwizard documentation ).  Or build DBI instance yourself:  JdbiBundle . forDbi (( conf ,   env )   ->   locateDbi ())",
            "title": "Usage"
        },
        {
            "location": "/extras/jdbi/#unit-of-work",
            "text": "Unit of work concept states for: every database related operation must be performed inside unit of work.  In DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of\nsql object proxies: if you create it on-demand it would always create new handle; if you want to combine\nmultiple objects in one transaction, you have to always create them manually for each transaction.  Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction\nscope is controlled by  @InTransaction  annotation (note that such name was intentional to avoid confusion with\nDBI own's Transaction annotation and more common Transactional annotations).  At the beginning of unit of work, DBI handle is created and bound to thread (thread local).\nAll repositories are simply using this bound handle and so share transaction inside unit of work.",
            "title": "Unit of work"
        },
        {
            "location": "/extras/jdbi/#intransaction",
            "text": "Annotation on method or class declares transactional scope. For example:  @Inject   MyDAO   dao  @InTransaction  public   Result   doSomething ()   { \n    dao . select (); \n    ...  }   Transaction opened before doSomething() method and closed after it. \nDao call is also performed inside transaction.\nIf exception appears during execution, it's propagated and transaction rolled back.  Nested annotations are allowed (they simply ignored).  Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). \nBut, for simplicity, you may think of it as the same things, if you always use  @InTransaction  annotation.   If required, you may use your own annotation for transaction definition:  JdbiBundle . forDatabase (( conf ,   env )   ->   conf . getDatabase ()) \n     . withTxAnnotations ( MyCustomTransactional . class );   Note that this will override default annotation support. If you want to support multiple annotations then specify\nall of them:  JdbiBundle . forDatabase (( conf ,   env )   ->   conf . getDatabase ()) \n     . withTxAnnotations ( InTransaction . class ,   MyCustomTransactional . class );",
            "title": "@InTransaction"
        },
        {
            "location": "/extras/jdbi/#context-handle",
            "text": "Inside unit of work you may reference current handle by using:  @Inject   Provider < Handle >",
            "title": "Context Handle"
        },
        {
            "location": "/extras/jdbi/#manual-transaction-definition",
            "text": "You may define transaction (with unit of work) without annotation using:  @Inject   TransactionTenpate   template ;  ...  template . inTrabsansaction (( handle )   ->   doSomething ())   Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as \nwith annotation.",
            "title": "Manual transaction definition"
        },
        {
            "location": "/extras/jdbi/#repository",
            "text": "Declare repository (interface or abstract class) as usual, using DBI annotations. \nIt only must be annotated with  @JdbiRepository  so installer\ncould recognize it and register in guice context.   Singleton scope will be forced for repositories.   @JdbiRepository  @InTransaction  public   interface   MyRepository   {      \n\n     @SqlQuery ( \"select name from something where id = :id\" ) \n     String   findNameById ( @Bind ( \"id\" )   int   id );  }   Note the use of  @InTransaction : it was used to be able to call repository methods without extra annotations\n(the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand\nsql object proxies.  @InTransaction  annotation is handled using guice aop. You can use any other guice aop related features.  You can also use injection inside repositories, but only field injection:  public   abstract   class   MyRepo   { \n     @Inject   SomeBean   bean ;  }   Constructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able\nto construct proxy for class with constructor injection.  Don't use DBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not\nneeded now and may confuse.  All installed repositories are reported into console:  INFO  [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = \n\n    (ru.vyarus.guicey.jdbi.support.repository.SampleRepository)",
            "title": "Repository"
        },
        {
            "location": "/extras/jdbi/#result-set-mapper",
            "text": "If you have custom implementations of  ResultSetMapper , it may be registered automatically. \nYou will be able to use injections there because mappers become ususal guice beans (singletons).\nWhen classpath scan is enabled, such classes will be searched and installed automatically.  public   class   CustomMapper   implements   ResutlSetMapper < Custom >   { \n     @Override \n     public   Cusom   map ( int   row ,   ResultSet   rs ,   StatementContext   ctx )   { \n         // mapping here \n         return   custom ; \n     }  }   And now Custom type could be used for queries:  @JdbiRepository  @InTransaction  public   interface   CustomRepository   {      \n\n     @SqlQuery ( \"select * from custom where id = :id\" ) \n     Custom   findNameById ( @Bind ( \"id\" )   int   id );  }   All installed mappers are reported to console:  INFO  [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = \n\n    Sample               (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper)",
            "title": "Result set mapper"
        },
        {
            "location": "/extras/jdbi/#manual-unit-of-work-definition",
            "text": "If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use \nassigned handle directly:  @Inject   UnitManager   manager ;  manager . beginUnit ();  try   { \n     Handle   handle   =   manager . get (); \n     // logic executed in unit of work but without transaction  }   finally   { \n     manager . endUnit ();  }   Repositories could also be called inside such manual unit (as unit of work is correctly started).",
            "title": "Manual unit of work definition"
        },
        {
            "location": "/about/license/",
            "text": "The MIT License (MIT)\n\n\nCopyright \u00a9 2014, Vyacheslav Rusakov\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "License"
        },
        {
            "location": "/about/history/",
            "text": "4.0.1 (2016-11-18)\n\u00b6\n\n\n\n\nUpdate to dropwizard 1.0.5 and fix compatibility (#24)\n\n\nFix guice version conflict for maven (#20)\n\n\n\n\n4.0.0 (2016-08-22)\n\u00b6\n\n\n\n\nUpdate to dropwizard 1.0.0\n\n\n(breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle)\n\n\nAdd WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts:\n\n\nWebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter\n\n\nWebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet\n\n\nWebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener    \n\n\n\n\n\n\nAdd general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3\nrd\n party bundles use it's own low-level options.\n\n\nGuiceyBootstrap option(option) method provides access to defined options from bundles\n\n\nOptions guice bean provide access to options from guice services\n\n\nInstallers could access options by implementing WithOptions interface\n\n\nOptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions())\n\n\nOptions reporting added to DiagnosticBundle\n\n\n\n\n\n\n(breaking) remove GuiceBunldle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) \n    (use either shortcuts without parameters or generic options method instead)\n\n\n(breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option \n\n\n(breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava\n\n\n(breaking) InjectorLookup changed to use java8 Optional instead of guava    \n\n\nAdd ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option \n\n\nAdd ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources) \n\n\nJersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK)\n\n\nAdd methods to GuiceBundle builder:\n\n\noption(option, value) - used to specify custom option value\n\n\noptions(Map) - used to provide multiple options at once (for custom options lookup mechanisms)\n\n\nprintAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features)\n\n\nuseWebInstallers() - shortcut for installing WebInstallersBundle\n\n\nnoGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support  \n\n\nnoDefaultInstallers() - disables CoreInstallersBundle automatic installation\n\n\n\n\n\n\n\n\n3.3.0 (2016-08-02)\n\u00b6\n\n\n\n\nUpdate to guice 4.1.0\n\n\nUpdate to dropwizard 0.9.3\n\n\nGrant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings\n\n\nResourceInstaller looks for @Path on directly implemented interface (#10)\n\n\nFix bundles lookup reporting (correct multiline)\n\n\nFix duplicate extensions installation when registered both manually and by auto scan\n\n\nRestrict extension installation to one installer (first matching, according to installers order)\n\n\nImprove dropwizard configuration class binding:\n\n\nComplete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself)\n\n\n(optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages \n (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces()))\n\n\n\n\n\n\nAdd GuiceyBootstrap methods (extend GuiceyBundle abilities):\n\n\nbundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type.\n\n\napplication(): returns current application instance\n\n\n\n\n\n\nRewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item\n\n\nAdd GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc)\n\n\nAdd DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page). \n\n\n\n\n\n\nAdd GuiceBundle builder configuration options:\n\n\nbindConfigurationInterfaces() to enable configuration interface bindings\n\n\nstrictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests)\n\n\nprintDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs)\n\n\nshortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces()\n\n\n\n\n\n\n\n\nNOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api)    \n\n\n3.2.0 (2016-01-23)\n\u00b6\n\n\n\n\nClear possible duplicate guicey bundle instances\n\n\nAdd GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources.\n\n\nDefault: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles.\n\n\nDefault: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions.\n\n\nAdd builder bundleLookup method to register custom lookup implementation\n\n\nAdd builder disableBundleLookup to disable default lookups\n\n\nDefault lookup implementation logs all resolved bundles\n\n\n\n\n\n\nFix JerseyProviderInstaller: prevent hk beans duplicate instantiations; fix DynamicFeature support.\n\n\nAdd HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed \nare managed by HK2 only. May be used in tests as extra validation.\n\n\nAdd JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration. \n\n\nUpdate to dropwizard 0.9\n\n\nRevert system exit on guice injector creation error (added in 3.1.1)\n\n\n\n\n3.1.1 (2015-11-24)\n\u00b6\n\n\n\n\nExit on guice injector creation error.\n\n\nAdd classpath scan packages validation for intersection (to prevent duplicate instances)\n\n\n\n\n3.1.0 (2015-09-06)\n\u00b6\n\n\n\n\nJerseyProviderInstaller: \n\n\nadd support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor,\n  ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener\n\n\nsupport multiple extension interfaces on the same bean\n\n\nIntroduce bundles (GuiceyBundle) to simplify extensions:\n\n\ncore installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed\n\n\nbuilder bundles() method to add guicey bundles\n\n\nbuilder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism)\n\n\nAdd admin context rest support (AdminRestBundle)\n\n\nAdd request scoped beans support in admin context\n\n\n\n\n3.0.1 (2015-07-04)\n\u00b6\n\n\n\n\nAdd DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces\n\n\n\n\n3.0.0 (2015-04-26)\n\u00b6\n\n\n\n\nFix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly) \n\n\n(breaking) Remove static state from GuiceBundle:\n\n\nGuiceBundle.getInjector method remain, but its now instance specific (instead of static)\n\n\nInjector could be referenced statically using application instance: InjectorLookup.getInjector(app).get() \n\n\nJerseyInstaller interface signature changed: now install method receives injector instance\n\n\n\n\n2.2.0 (2015-04-17)\n\u00b6\n\n\n\n\nFix ExceptionMapper registration\n\n\nAdd installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 \n(to simplify custom installers injection between them)\n\n\n\n\n2.1.2 (2015-03-03)\n\u00b6\n\n\n\n\nSpock 1.0 compatibility\n\n\n\n\n2.1.1 (2015-01-25)\n\u00b6\n\n\n\n\nDropwizard 0.8-rc2 compatibility\n\n\n\n\n2.1.0 (2015-01-04)\n\u00b6\n\n\n\n\nAdd ability to customize injector creation (required by some guice third party modules, like governator). Contributed by \nNicholas Pace\n\n\nAdd spock extensions to use injections directly in specification (like spock-guice do)\n\n\n\n\n2.0.0 (2014-11-25)\n\u00b6\n\n\n\n\nDropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(hk2)).\nJersey integration completely rewritten.\n\n\nAdd JerseyInstaller installer type\n\n\nAdd @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request)\n\n\n\n\n1.1.0 (2014-10-23)\n\u00b6\n\n\n\n\nFix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils\n\n\nDrop java 1.6 compatibility, because dropwizard is 1.7 compatible\n\n\nAdd junit rule for lightweight testing (run guice without starting jetty)\n\n\n\n\n1.0.0 (2014-10-14)\n\u00b6\n\n\n\n\nAdd dependency on guice-multibindings\n\n\nInstallers may choose now from three types of installation (binding, type or instance) or combine them.\n\n\nAdd PluginInstaller: shortcut for multibindings mechanism\n\n\nUpdated guice (4.0.beta4 -> 4.0.beta5)\n\n\nForce singleton for resources\n\n\n@Eager renamed to @EagerSingleton and now forces singleton scope for bean\n\n\nAdd dropwizard style reporting for installed features (like resources or tasks)\n\n\nRemoved JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider\n\n\nAdd extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers)\n\n\nAdd admin context filter and servlet installers\n\n\nRename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions\n\n\n\n\n0.9.0 (2014-09-05)\n\u00b6\n\n\n\n\nInitial release",
            "title": "Release notes"
        },
        {
            "location": "/about/history/#401-2016-11-18",
            "text": "Update to dropwizard 1.0.5 and fix compatibility (#24)  Fix guice version conflict for maven (#20)",
            "title": "4.0.1 (2016-11-18)"
        },
        {
            "location": "/about/history/#400-2016-08-22",
            "text": "Update to dropwizard 1.0.0  (breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle)  Add WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts:  WebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter  WebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet  WebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener        Add general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3 rd  party bundles use it's own low-level options.  GuiceyBootstrap option(option) method provides access to defined options from bundles  Options guice bean provide access to options from guice services  Installers could access options by implementing WithOptions interface  OptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions())  Options reporting added to DiagnosticBundle    (breaking) remove GuiceBunldle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) \n    (use either shortcuts without parameters or generic options method instead)  (breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option   (breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava  (breaking) InjectorLookup changed to use java8 Optional instead of guava      Add ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option   Add ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources)   Jersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK)  Add methods to GuiceBundle builder:  option(option, value) - used to specify custom option value  options(Map) - used to provide multiple options at once (for custom options lookup mechanisms)  printAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features)  useWebInstallers() - shortcut for installing WebInstallersBundle  noGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support    noDefaultInstallers() - disables CoreInstallersBundle automatic installation",
            "title": "4.0.0 (2016-08-22)"
        },
        {
            "location": "/about/history/#330-2016-08-02",
            "text": "Update to guice 4.1.0  Update to dropwizard 0.9.3  Grant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings  ResourceInstaller looks for @Path on directly implemented interface (#10)  Fix bundles lookup reporting (correct multiline)  Fix duplicate extensions installation when registered both manually and by auto scan  Restrict extension installation to one installer (first matching, according to installers order)  Improve dropwizard configuration class binding:  Complete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself)  (optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages \n (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces()))    Add GuiceyBootstrap methods (extend GuiceyBundle abilities):  bundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type.  application(): returns current application instance    Rewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item  Add GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc)  Add DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page).     Add GuiceBundle builder configuration options:  bindConfigurationInterfaces() to enable configuration interface bindings  strictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests)  printDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs)  shortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces()     NOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api)",
            "title": "3.3.0 (2016-08-02)"
        },
        {
            "location": "/about/history/#320-2016-01-23",
            "text": "Clear possible duplicate guicey bundle instances  Add GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources.  Default: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles.  Default: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions.  Add builder bundleLookup method to register custom lookup implementation  Add builder disableBundleLookup to disable default lookups  Default lookup implementation logs all resolved bundles    Fix JerseyProviderInstaller: prevent hk beans duplicate instantiations; fix DynamicFeature support.  Add HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed \nare managed by HK2 only. May be used in tests as extra validation.  Add JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration.   Update to dropwizard 0.9  Revert system exit on guice injector creation error (added in 3.1.1)",
            "title": "3.2.0 (2016-01-23)"
        },
        {
            "location": "/about/history/#311-2015-11-24",
            "text": "Exit on guice injector creation error.  Add classpath scan packages validation for intersection (to prevent duplicate instances)",
            "title": "3.1.1 (2015-11-24)"
        },
        {
            "location": "/about/history/#310-2015-09-06",
            "text": "JerseyProviderInstaller:   add support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor,\n  ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener  support multiple extension interfaces on the same bean  Introduce bundles (GuiceyBundle) to simplify extensions:  core installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed  builder bundles() method to add guicey bundles  builder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism)  Add admin context rest support (AdminRestBundle)  Add request scoped beans support in admin context",
            "title": "3.1.0 (2015-09-06)"
        },
        {
            "location": "/about/history/#301-2015-07-04",
            "text": "Add DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces",
            "title": "3.0.1 (2015-07-04)"
        },
        {
            "location": "/about/history/#300-2015-04-26",
            "text": "Fix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly)   (breaking) Remove static state from GuiceBundle:  GuiceBundle.getInjector method remain, but its now instance specific (instead of static)  Injector could be referenced statically using application instance: InjectorLookup.getInjector(app).get()   JerseyInstaller interface signature changed: now install method receives injector instance",
            "title": "3.0.0 (2015-04-26)"
        },
        {
            "location": "/about/history/#220-2015-04-17",
            "text": "Fix ExceptionMapper registration  Add installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 \n(to simplify custom installers injection between them)",
            "title": "2.2.0 (2015-04-17)"
        },
        {
            "location": "/about/history/#212-2015-03-03",
            "text": "Spock 1.0 compatibility",
            "title": "2.1.2 (2015-03-03)"
        },
        {
            "location": "/about/history/#211-2015-01-25",
            "text": "Dropwizard 0.8-rc2 compatibility",
            "title": "2.1.1 (2015-01-25)"
        },
        {
            "location": "/about/history/#210-2015-01-04",
            "text": "Add ability to customize injector creation (required by some guice third party modules, like governator). Contributed by  Nicholas Pace  Add spock extensions to use injections directly in specification (like spock-guice do)",
            "title": "2.1.0 (2015-01-04)"
        },
        {
            "location": "/about/history/#200-2014-11-25",
            "text": "Dropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(hk2)).\nJersey integration completely rewritten.  Add JerseyInstaller installer type  Add @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request)",
            "title": "2.0.0 (2014-11-25)"
        },
        {
            "location": "/about/history/#110-2014-10-23",
            "text": "Fix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils  Drop java 1.6 compatibility, because dropwizard is 1.7 compatible  Add junit rule for lightweight testing (run guice without starting jetty)",
            "title": "1.1.0 (2014-10-23)"
        },
        {
            "location": "/about/history/#100-2014-10-14",
            "text": "Add dependency on guice-multibindings  Installers may choose now from three types of installation (binding, type or instance) or combine them.  Add PluginInstaller: shortcut for multibindings mechanism  Updated guice (4.0.beta4 -> 4.0.beta5)  Force singleton for resources  @Eager renamed to @EagerSingleton and now forces singleton scope for bean  Add dropwizard style reporting for installed features (like resources or tasks)  Removed JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider  Add extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers)  Add admin context filter and servlet installers  Rename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions",
            "title": "1.0.0 (2014-10-14)"
        },
        {
            "location": "/about/history/#090-2014-09-05",
            "text": "Initial release",
            "title": "0.9.0 (2014-09-05)"
        }
    ]
}