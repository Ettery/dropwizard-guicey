{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to dropwizard-guicey\n\u00b6\n\n\n\n\nGuice\n integration for \ndropwizard\n.\n\n\n\n\nRelease notes\n - \nSupport\n - \nLicense\n\n\nMain features\n\u00b6\n\n\n\n\nAuto configuration\n: use classpath scan to find and install extensions \nautomatically without manual configurations (of course, \nmanual mode\n is also possible)  \n\n\nConfiguration values bindings\n by path or unique sub objects. \n\n\nWeb\n (servlets, filters):\n\n\nsupports both contexts (main and admin)\n\n\nguice ServletModule support is enabled by default (\ncould be disabled\n)\n\n\njee web annotations (@WebServlet, @WebFilter) support (\ncould be enabled\n)\n\n\n\n\n\n\nDropwizard style \nreporting\n: detected (and installed) extensions are printed to console to remove uncertainty\n\n\nAdmin context \nrest emulation\n \n\n\nTest support\n: custom junit and \nspock\n extensions\n\n\nDeveloper friendly: \n\n\ncore integrations \nmay be replaced\n (to better fit needs)\n\n\nrich api for developing \ncustom integrations\n, \ncustom behaviours\n and \nconfiguration modification\n \n\n\nout of the box support for plug-n-play plugins (\nauto discoverable\n)\n\n\nself diagnostic tools (\nconfiguration diagnostic report\n, \nbindable configuration paths\n, \nlifecycle stages\n) \n\n\n\n\n\n\n\n\nHow to use docs\n\u00b6\n\n\nIntroduction\n\u00b6\n\n\n\n\nIf you are migrating from \ndropwizard-guice\n read \nmigration guide\n first\n\n\n\n\n\n\nGetting started\n guide describes installation and shows core usage examples\n\n\nConcepts overview\n guide introduce core guicey concepts and explains differences with pure dropwizard usage\n\n\n\n\nReference\n\u00b6\n\n\n\n\nUser guide\n section contain detailed features descriptions. Good to read, but if no time, read as you need it.\n\n\nInstallers\n section describes all guicey installers. Use it as a \nextensions hand book\n.\n\n\n\n\nExamples and integrations\n\u00b6\n\n\n\n\nExamples\n section contains common example cases. Look also \nexamples repository\n for additinoal examples.\n\n\nExtras\n section covers extra modules: admin rest, 3\nrd\n party integrations (event bus, jdbi) provided by guicey itself \nor extensions project.\n\n\n\n\nSources structure\n\u00b6\n\n\nThe main repository\n contains library itself and this documentation sources.\n\n\nGuicey stays as feature complete library with commonly used core integrations and \nrich api for building custom integrations (for specific needs). \nIt's very close to guice philosophy of being simple and stable.\n\n\nExamples repository\n holds examples of main features usage, dropwizard bundles \nintegrations and extensions samples.\n\n\nExtensions repository\n contains guicey external integrations. \n\n\nExtensions project shows what is possible to achieve based on guicey. Besides, provided integrations \nitself might be quite useful.\n\n\nBOM module\n unifies dependencies management for extensions, dropwizard and guice (as it includes boms for them).\nOverall, extensions project is more like spring: growing set of solutions for everything (more \"enterprisy\").",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-dropwizard-guicey",
            "text": "Guice  integration for  dropwizard .   Release notes  -  Support  -  License",
            "title": "Welcome to dropwizard-guicey"
        },
        {
            "location": "/#main-features",
            "text": "Auto configuration : use classpath scan to find and install extensions \nautomatically without manual configurations (of course,  manual mode  is also possible)    Configuration values bindings  by path or unique sub objects.   Web  (servlets, filters):  supports both contexts (main and admin)  guice ServletModule support is enabled by default ( could be disabled )  jee web annotations (@WebServlet, @WebFilter) support ( could be enabled )    Dropwizard style  reporting : detected (and installed) extensions are printed to console to remove uncertainty  Admin context  rest emulation    Test support : custom junit and  spock  extensions  Developer friendly:   core integrations  may be replaced  (to better fit needs)  rich api for developing  custom integrations ,  custom behaviours  and  configuration modification    out of the box support for plug-n-play plugins ( auto discoverable )  self diagnostic tools ( configuration diagnostic report ,  bindable configuration paths ,  lifecycle stages )",
            "title": "Main features"
        },
        {
            "location": "/#how-to-use-docs",
            "text": "",
            "title": "How to use docs"
        },
        {
            "location": "/#introduction",
            "text": "If you are migrating from  dropwizard-guice  read  migration guide  first    Getting started  guide describes installation and shows core usage examples  Concepts overview  guide introduce core guicey concepts and explains differences with pure dropwizard usage",
            "title": "Introduction"
        },
        {
            "location": "/#reference",
            "text": "User guide  section contain detailed features descriptions. Good to read, but if no time, read as you need it.  Installers  section describes all guicey installers. Use it as a  extensions hand book .",
            "title": "Reference"
        },
        {
            "location": "/#examples-and-integrations",
            "text": "Examples  section contains common example cases. Look also  examples repository  for additinoal examples.  Extras  section covers extra modules: admin rest, 3 rd  party integrations (event bus, jdbi) provided by guicey itself \nor extensions project.",
            "title": "Examples and integrations"
        },
        {
            "location": "/#sources-structure",
            "text": "The main repository  contains library itself and this documentation sources.  Guicey stays as feature complete library with commonly used core integrations and \nrich api for building custom integrations (for specific needs). \nIt's very close to guice philosophy of being simple and stable.  Examples repository  holds examples of main features usage, dropwizard bundles \nintegrations and extensions samples.  Extensions repository  contains guicey external integrations.   Extensions project shows what is possible to achieve based on guicey. Besides, provided integrations \nitself might be quite useful.  BOM module  unifies dependencies management for extensions, dropwizard and guice (as it includes boms for them).\nOverall, extensions project is more like spring: growing set of solutions for everything (more \"enterprisy\").",
            "title": "Sources structure"
        },
        {
            "location": "/getting-started/",
            "text": "Getting started\n\u00b6\n\n\n\n\nGetting started guide briefly shows the most commonly used features.\nAdvanced description of guicey concepts may be found in \nthe concepts section\n.\nIf you are migrating from dropwizard-guice, read \nmigration guide\n.    \n\n\n\n\nInstallation\n\u00b6\n\n\nAvailable from maven central and \nbintray jcenter\n.\n\n\nMaven:\n\n\n<dependency>\n\n  \n<groupId>\nru.vyarus\n</groupId>\n\n  \n<artifactId>\ndropwizard-guicey\n</artifactId>\n\n  \n<version>\n4.2.0\n</version>\n\n\n</dependency>\n\n\n\n\n\nGradle:\n\n\ncompile\n \n'ru.vyarus:dropwizard-guicey:4.2.0'\n\n\n\n\n\nBOM\n\u00b6\n\n\nGuicey pom may be also used as maven BOM:\n\n\nplugins\n \n{\n\n    \nid\n \n\"io.spring.dependency-management\"\n \nversion\n \n\"1.0.5.RELEASE\"\n\n\n}\n\n\ndependencyManagement\n \n{\n\n    \nimports\n \n{\n\n        \nmavenBom\n \n'ru.vyarus:dropwizard-guicey:4.2.0'\n  \n        \n// uncomment to override dropwizard version    \n\n        \n// mavenBom 'io.dropwizard:dropwizard-bom:1.3.5' \n\n    \n}\n\n\n}\n\n\n\ndependencies\n \n{\n\n    \ncompile\n \n'ru.vyarus:dropwizard-guicey:4.2.0'\n\n\n    \n// no need to specify versions\n\n    \ncompile\n \n'io.dropwizard:dropwizard-auth'\n\n    \ncompile\n \n'com.google.inject:guice-assistedinject'\n   \n\n    \ntestCompile\n \n'io.dropwizard:dropwizard-test'\n\n    \ntestCompile\n \n'org.spockframework:spock-core'\n\n\n}\n\n\n\n\n\nBom includes:\n\n\n\n\nDropwizard BOM (io.dropwizard:dropwizard-bom)\n\n\nGuice BOM (com.google.inject:guice-bom)\n\n\nHK2 bridge (org.glassfish.hk2:guice-bridge) \n\n\nSystem rules, required for StartupErrorRule (com.github.stefanbirkner:system-rules)\n\n\nSpock (org.spockframework:spock-core)\n\n\n\n\nGuicey extensions project provide extended BOM with guicey and all guicey modules included. \nSee \nextensions project BOM\n section for more details of BOM usage.\n\n\nUsage\n\u00b6\n\n\n\n\nFull source of example application is \npublished here\n\n\n\n\nRegister guice bundle:\n\n\npublic\n \nclass\n \nSampleApplication\n \nextends\n \nApplication\n<\nConfiguration\n>\n \n{\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \nthrows\n \nException\n \n{\n\n            \nnew\n \nSampleApplication\n().\nrun\n(\nargs\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nBootstrap\n<\nConfiguration\n>\n \nbootstrap\n)\n \n{\n\n        \nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n.\nenableAutoConfig\n(\ngetClass\n().\ngetPackage\n().\ngetName\n())\n\n                \n.\nbuild\n());\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nConfiguration\n \nconfiguration\n,\n \nEnvironment\n \nenvironment\n)\n \nthrows\n \nException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nTip\n\n\nBundle builder contains shortcuts for all available features, so required function \nmay be found only by looking at available methods (and reading javadoc).\n\n\n\n\nAuto configuration (activated with \nenableAutoConfig\n) means that guicey will search for extensions in application package and subpackages.\n\n\n\n\nTip\n\n\nYou can declare multiple packages for classpath scan: \n\n \n.\nenableAutoConfig\n(\n\"com.mycompany.foo\"\n,\n \n\"com.mycompany.bar\"\n)\n\n\n\n\n\n\nApplication could be launched by simply running main class (assume you will use IDE run command):\n\n\nSampleApplication server\n\n\n\n\n\n\nNote\n\n\nconfig.yml is not passed as parameter because we don't need additional configuration now\n\n\n\n\nAdd resource\n\u00b6\n\n\nCreating custom rest resource:\n\n\n@Path\n(\n\"/sample\"\n)\n\n\n@Produces\n(\n\"application/json\"\n)\n\n\npublic\n \nclass\n \nSampleResource\n \n{\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/\"\n)\n\n    \npublic\n \nResponse\n \nask\n()\n \n{\n\n        \nreturn\n \nResponse\n.\nok\n(\n\"ok\"\n).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nNow, when you run application, you can see that resource was installed automatically:\n\n\nINFO  [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources:\n\n    GET     /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource)\n\n\n\n\nCall \nhttp://localhost:8080/sample/\n to make sure it works.\n\n\n\n\nTip\n\n\nRest context is mapped to root by default. To change it use configuration file:\n\nserver\n:\n\n    \nrootPath\n:\n \n'/rest/*'\n\n\n\n\n\n\nResource is a guice bean, so you can use guice injection here. To accessing request specific\nobjects like request, response, jersey \njavax.ws.rs.core.UriInfo\n etc. use \nProvider\n:\n\n\n@Path\n(\n\"/sample\"\n)\n\n\n@Produces\n(\n\"application/json\"\n)\n\n\npublic\n \nclass\n \nSampleResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/\"\n)\n\n    \npublic\n \nResponse\n \nask\n()\n \n{\n\n        \nfinal\n \nString\n \nip\n \n=\n \nrequestProvider\n.\nget\n().\ngetRemoteAddr\n();\n\n        \nreturn\n \nResponse\n.\nok\n(\nip\n).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nNow resource will return caller IP.\n\n\n\n\nImportant\n\n\nProviders must be used \ninstead of \n@Context\n field injections\n \n\n\n\n\nAlso, you can inject request specific objects \nas method parameter\n\n\n\n\nField injection used in examples for simplicity. In real life projects \nprefer constructor injection\n.    \n\n\n\n\n\n\nBy default, resources are \nforced to be singletons\n (when no scope annotation defined). \n\n\n\n\nAdd managed\n\u00b6\n\n\nDropwizard managed objects\n are extremely useful for managing resources.\n\n\nCreate simple managed implementation:\n\n\n@Singleton\n\n\npublic\n \nclass\n \nSampleBootstrap\n \nimplements\n \nManaged\n \n{\n\n    \nprivate\n \nfinal\n \nLogger\n \nlogger\n \n=\n \nLoggerFactory\n.\ngetLogger\n(\nSampleBootstrap\n.\nclass\n);\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n        \nlogger\n.\ninfo\n(\n\"Starting some resource\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstop\n()\n \nthrows\n \nException\n \n{\n\n        \nlogger\n.\ninfo\n(\n\"Shutting down some resource\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nIt will be automatically discovered and installed. Guicey always reports installed extensions\n(when they are not reported by dropwizard itself). So you can see in startup logs now:\n\n\nINFO  [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap)\n\n\n\n\nAdd filter\n\u00b6\n\n\n\n\nNote\n\n\nGuice \nServletModule\n may be used for servlets and filters definitions, but most of the time it's more convenient\nto use simple servlet annotations (\n@WebFilter\n, \n@WebServlet\n, \n@WebListener\n). \nMoreover, guice servlet module is not able to register async filters and servlets.\n\n\n\n\nTo use \n@WebFilter\n annotation for filter installation web installers must be activated with shortcut method:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n.\nenableAutoConfig\n(\ngetClass\n().\ngetPackage\n().\ngetName\n())\n\n                \n.\nuseWebInstallers\n()\n\n                \n.\nbuild\n());\n\n\n\n\n\nAdd sample filter around rest methods:\n\n\n@WebFilter\n(\nurlPatterns\n \n=\n \n\"/*\"\n)\n\n\npublic\n \nclass\n \nCustomHeaderFilter\n \nimplements\n \nFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninit\n(\nFilterConfig\n \nfilterConfig\n)\n \nthrows\n \nServletException\n \n{\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndoFilter\n(\nServletRequest\n \nrequest\n,\n \nServletResponse\n \nresponse\n,\n \nFilterChain\n \nchain\n)\n\n            \nthrows\n \nIOException\n,\n \nServletException\n \n{\n\n        \nif\n \n(\n\"me\"\n.\nequals\n(\nrequest\n.\ngetParameter\n(\n\"user\"\n)))\n \n{\n\n            \nchain\n.\ndoFilter\n(\nrequest\n,\n \nresponse\n);\n\n        \n}\n \nelse\n \n{\n\n            \n((\nHttpServletResponse\n)\n \nresponse\n)\n\n                    \n.\nsendError\n(\nHttpServletResponse\n.\nSC_UNAUTHORIZED\n,\n \n\"Not authorized\"\n);\n\n        \n}\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndestroy\n()\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\nFilter will pass through only requests with \nuser=me\n request parameter. It is used just to show\nhow to register custom filters with annotations (implementation itself is not useful).\n\n\nNew lines in log will appear confirming filter installation:\n\n\nINFO  [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters =\n\n    /*                       (ru.vyarus.dropwizard.guice.examples.web.AuthFilter)   .auth\n\n\n\n\nCall \nhttp://localhost:8080/sample/\n and \nhttp://localhost:8080/sample/?user=me\n to make sure filter works.\n\n\nAdd guice module\n\u00b6\n\n\nIf you need to register guice module in injector:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n...\n\n                \n.\nmodules\n(\nnew\n \nSampleModule\n())\n\n                \n.\nbuild\n());\n\n\n\n\n\nMultiple modules could be registered:\n\n.\nmodules\n(\nnew\n \nSampleModule\n(),\n \nnew\n \nSome3rdPatyModule\n())\n\n\n\n\n\n\nGuice \nServletModule\n could be used for filters and servlets registration.\n\n\n\n\n\n\nIf you have at least one module of your own then it's recommended to move \nall guice modules registration there to encapsulate guice staff:  \n\n\n.\nmodules\n(\nnew\n \nSampleModule\n())\n        \n\n\n\npublic\n \nclass\n \nSampleModule\n \nextends\n \nAbstractModule\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \ninstall\n(\nnew\n \nSome3rdPatyModule\n());\n\n\n        \n// some custom bindings there\n\n    \n}\n\n\n}\n\n\n\nExcept when you need to \naccess dropwizard objects\n in module\n\n\n\n\n\n\nWarning\n\n\nGuicey removes duplicate registrations by type. For example, in case:\n\n.\nmodules\n(\nnew\n \nSampleModule\n(),\n \nnew\n \nSampleModule\n())\n\n\n\nOnly one module will be registered. This is intentional restriction to simplify bundles usage\n(to let you register common modules in different bundles and be sure that only one instance will be used).\n\n\n\n\nIn some cases, it could be desired to use different instances of the same module:\n\n.\nmodules\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n),\n \nnew\n \nParametrizableModule\n(\n\"mod2\"\n))\n\n\n\nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module:\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n));\n\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod2\"\n));\n\n\n\n\nManual mode\n\u00b6\n\n\nIf you don't want to use auto configuration, then you will have to manually specify all extensions.\nExample above would look in manual mode like this:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n.\nuseWebInstallers\n()\n\n                \n.\nmodules\n(\nnew\n \nSampleModule\n())\n\n                \n.\nextensions\n(\n\n                        \nSampleResource\n.\nclass\n,\n\n                        \nSampleBootstrap\n.\nclass\n,\n\n                        \nCustomHeaderFilter\n.\nclass\n\n                \n)\n\n                \n.\nbuild\n());\n\n\n\n\n\nAs you can see the actual difference is only the absence of classpath scan, so you have to manually\nspecify all extensions.\n\n\n\n\nTip\n\n\nExplicit extensions declaration could be used in auto configuration mode too: for example,\nclasspath scan could not cover all packages with extensions (e.g. due to too much classes)\nand not covered extensions may be specified manually.    \n\n\n\n\n\n\nImportant\n\n\nDuplicate extensions are filtered. If some extension is registered manually and also found with auto scan\nthen only one extension instance will be registered. \nEven if extension registered multiple times manually,\nonly one extension will work.",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "Getting started guide briefly shows the most commonly used features.\nAdvanced description of guicey concepts may be found in  the concepts section .\nIf you are migrating from dropwizard-guice, read  migration guide .",
            "title": "Getting started"
        },
        {
            "location": "/getting-started/#installation",
            "text": "Available from maven central and  bintray jcenter .  Maven:  <dependency> \n   <groupId> ru.vyarus </groupId> \n   <artifactId> dropwizard-guicey </artifactId> \n   <version> 4.2.0 </version>  </dependency>   Gradle:  compile   'ru.vyarus:dropwizard-guicey:4.2.0'",
            "title": "Installation"
        },
        {
            "location": "/getting-started/#bom",
            "text": "Guicey pom may be also used as maven BOM:  plugins   { \n     id   \"io.spring.dependency-management\"   version   \"1.0.5.RELEASE\"  }  dependencyManagement   { \n     imports   { \n         mavenBom   'ru.vyarus:dropwizard-guicey:4.2.0'   \n         // uncomment to override dropwizard version     \n         // mavenBom 'io.dropwizard:dropwizard-bom:1.3.5'  \n     }  }  dependencies   { \n     compile   'ru.vyarus:dropwizard-guicey:4.2.0' \n\n     // no need to specify versions \n     compile   'io.dropwizard:dropwizard-auth' \n     compile   'com.google.inject:guice-assistedinject'    \n\n     testCompile   'io.dropwizard:dropwizard-test' \n     testCompile   'org.spockframework:spock-core'  }   Bom includes:   Dropwizard BOM (io.dropwizard:dropwizard-bom)  Guice BOM (com.google.inject:guice-bom)  HK2 bridge (org.glassfish.hk2:guice-bridge)   System rules, required for StartupErrorRule (com.github.stefanbirkner:system-rules)  Spock (org.spockframework:spock-core)   Guicey extensions project provide extended BOM with guicey and all guicey modules included. \nSee  extensions project BOM  section for more details of BOM usage.",
            "title": "BOM"
        },
        {
            "location": "/getting-started/#usage",
            "text": "Full source of example application is  published here   Register guice bundle:  public   class   SampleApplication   extends   Application < Configuration >   { \n\n     public   static   void   main ( String []   args )   throws   Exception   { \n             new   SampleApplication (). run ( args ); \n     } \n\n     @Override \n     public   void   initialize ( Bootstrap < Configuration >   bootstrap )   { \n         bootstrap . addBundle ( GuiceBundle . builder () \n                 . enableAutoConfig ( getClass (). getPackage (). getName ()) \n                 . build ()); \n     } \n\n     @Override \n     public   void   run ( Configuration   configuration ,   Environment   environment )   throws   Exception   { \n     }  }    Tip  Bundle builder contains shortcuts for all available features, so required function \nmay be found only by looking at available methods (and reading javadoc).   Auto configuration (activated with  enableAutoConfig ) means that guicey will search for extensions in application package and subpackages.   Tip  You can declare multiple packages for classpath scan:    . enableAutoConfig ( \"com.mycompany.foo\" ,   \"com.mycompany.bar\" )    Application could be launched by simply running main class (assume you will use IDE run command):  SampleApplication server   Note  config.yml is not passed as parameter because we don't need additional configuration now",
            "title": "Usage"
        },
        {
            "location": "/getting-started/#add-resource",
            "text": "Creating custom rest resource:  @Path ( \"/sample\" )  @Produces ( \"application/json\" )  public   class   SampleResource   { \n\n     @GET \n     @Path ( \"/\" ) \n     public   Response   ask ()   { \n         return   Response . ok ( \"ok\" ). build (); \n     }  }   Now, when you run application, you can see that resource was installed automatically:  INFO  [2017-02-05 11:23:31,188] io.dropwizard.jersey.DropwizardResourceConfig: The following paths were found for the configured resources:\n\n    GET     /sample/ (ru.vyarus.dropwizard.guice.examples.rest.SampleResource)  Call  http://localhost:8080/sample/  to make sure it works.   Tip  Rest context is mapped to root by default. To change it use configuration file: server : \n     rootPath :   '/rest/*'    Resource is a guice bean, so you can use guice injection here. To accessing request specific\nobjects like request, response, jersey  javax.ws.rs.core.UriInfo  etc. use  Provider :  @Path ( \"/sample\" )  @Produces ( \"application/json\" )  public   class   SampleResource   { \n\n     @Inject \n     private   Provider < HttpServletRequest >   requestProvider ; \n\n     @GET \n     @Path ( \"/\" ) \n     public   Response   ask ()   { \n         final   String   ip   =   requestProvider . get (). getRemoteAddr (); \n         return   Response . ok ( ip ). build (); \n     }  }   Now resource will return caller IP.   Important  Providers must be used  instead of  @Context  field injections     Also, you can inject request specific objects  as method parameter   Field injection used in examples for simplicity. In real life projects  prefer constructor injection .        By default, resources are  forced to be singletons  (when no scope annotation defined).",
            "title": "Add resource"
        },
        {
            "location": "/getting-started/#add-managed",
            "text": "Dropwizard managed objects  are extremely useful for managing resources.  Create simple managed implementation:  @Singleton  public   class   SampleBootstrap   implements   Managed   { \n     private   final   Logger   logger   =   LoggerFactory . getLogger ( SampleBootstrap . class ); \n\n     @Override \n     public   void   start ()   throws   Exception   { \n         logger . info ( \"Starting some resource\" ); \n     } \n\n     @Override \n     public   void   stop ()   throws   Exception   { \n         logger . info ( \"Shutting down some resource\" ); \n     }  }   It will be automatically discovered and installed. Guicey always reports installed extensions\n(when they are not reported by dropwizard itself). So you can see in startup logs now:  INFO  [2017-02-05 11:59:30,750] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.examples.service.SampleBootstrap)",
            "title": "Add managed"
        },
        {
            "location": "/getting-started/#add-filter",
            "text": "Note  Guice  ServletModule  may be used for servlets and filters definitions, but most of the time it's more convenient\nto use simple servlet annotations ( @WebFilter ,  @WebServlet ,  @WebListener ). \nMoreover, guice servlet module is not able to register async filters and servlets.   To use  @WebFilter  annotation for filter installation web installers must be activated with shortcut method:  bootstrap . addBundle ( GuiceBundle . builder () \n                 . enableAutoConfig ( getClass (). getPackage (). getName ()) \n                 . useWebInstallers () \n                 . build ());   Add sample filter around rest methods:  @WebFilter ( urlPatterns   =   \"/*\" )  public   class   CustomHeaderFilter   implements   Filter   { \n\n     @Override \n     public   void   init ( FilterConfig   filterConfig )   throws   ServletException   { \n     } \n\n     @Override \n     public   void   doFilter ( ServletRequest   request ,   ServletResponse   response ,   FilterChain   chain ) \n             throws   IOException ,   ServletException   { \n         if   ( \"me\" . equals ( request . getParameter ( \"user\" )))   { \n             chain . doFilter ( request ,   response ); \n         }   else   { \n             (( HttpServletResponse )   response ) \n                     . sendError ( HttpServletResponse . SC_UNAUTHORIZED ,   \"Not authorized\" ); \n         } \n     } \n\n     @Override \n     public   void   destroy ()   { \n     }  }   Filter will pass through only requests with  user=me  request parameter. It is used just to show\nhow to register custom filters with annotations (implementation itself is not useful).  New lines in log will appear confirming filter installation:  INFO  [2017-02-11 17:18:16,943] ru.vyarus.dropwizard.guice.module.installer.feature.web.WebFilterInstaller: filters =\n\n    /*                       (ru.vyarus.dropwizard.guice.examples.web.AuthFilter)   .auth  Call  http://localhost:8080/sample/  and  http://localhost:8080/sample/?user=me  to make sure filter works.",
            "title": "Add filter"
        },
        {
            "location": "/getting-started/#add-guice-module",
            "text": "If you need to register guice module in injector:  bootstrap . addBundle ( GuiceBundle . builder () \n                 ... \n                 . modules ( new   SampleModule ()) \n                 . build ());   Multiple modules could be registered: . modules ( new   SampleModule (),   new   Some3rdPatyModule ())    Guice  ServletModule  could be used for filters and servlets registration.    If you have at least one module of your own then it's recommended to move \nall guice modules registration there to encapsulate guice staff:    . modules ( new   SampleModule ())           public   class   SampleModule   extends   AbstractModule   { \n\n     @Override \n     protected   void   configure ()   { \n         install ( new   Some3rdPatyModule ()); \n\n         // some custom bindings there \n     }  }  \nExcept when you need to  access dropwizard objects  in module    Warning  Guicey removes duplicate registrations by type. For example, in case: . modules ( new   SampleModule (),   new   SampleModule ())  \nOnly one module will be registered. This is intentional restriction to simplify bundles usage\n(to let you register common modules in different bundles and be sure that only one instance will be used).   In some cases, it could be desired to use different instances of the same module: . modules ( new   ParametrizableModule ( \"mod1\" ),   new   ParametrizableModule ( \"mod2\" ))  \nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module: install ( new   ParametrizableModule ( \"mod1\" ));  install ( new   ParametrizableModule ( \"mod2\" ));",
            "title": "Add guice module"
        },
        {
            "location": "/getting-started/#manual-mode",
            "text": "If you don't want to use auto configuration, then you will have to manually specify all extensions.\nExample above would look in manual mode like this:  bootstrap . addBundle ( GuiceBundle . builder () \n                 . useWebInstallers () \n                 . modules ( new   SampleModule ()) \n                 . extensions ( \n                         SampleResource . class , \n                         SampleBootstrap . class , \n                         CustomHeaderFilter . class \n                 ) \n                 . build ());   As you can see the actual difference is only the absence of classpath scan, so you have to manually\nspecify all extensions.   Tip  Explicit extensions declaration could be used in auto configuration mode too: for example,\nclasspath scan could not cover all packages with extensions (e.g. due to too much classes)\nand not covered extensions may be specified manually.        Important  Duplicate extensions are filtered. If some extension is registered manually and also found with auto scan\nthen only one extension instance will be registered. \nEven if extension registered multiple times manually,\nonly one extension will work.",
            "title": "Manual mode"
        },
        {
            "location": "/concepts/",
            "text": "Concepts overview\n\u00b6\n\n\n\n\nSection briefly describes new concepts introduced by guicey and explains why it was done that way.\nFor usage instruction and basic examples see \ngetting-started section\n. \n\n\n\n\nInjector creation phase\n\u00b6\n\n\nDropwizard declares two phases: \n\n\n\n\ninitialization (\nApp.initialize\n method) - when dropwizard app must be configured\n\n\nrun (\nApp.run\n method) - when configuration is available and extensions could be registered in environment\n\n\n\n\nIf we create injector in initialization phase then we will not have access to \nConfiguration\n and \nEnvironment\n\nin guice modules, but configuration could be required, especially for 3\nrd\n party modules, which\ndoes not support lazy configuration.   \n\n\nGuicey creates injector at \nrun phase\n to allow using configuration (and environment) in guice modules.\n\n\n\n\nMany people ask why not just use HK2 instead of guice as it's already provided. \nUnfortunately, it's hard to use it in the same elegant way as we can use guice. \nHK2 context is launched too late (after dropwizard run phase). For example, it is \nimpossible to use HK2 to instantiate dropwizard managed object because managed \nmust be registered before HK2 context starts.\n\n\n\n\nGuice module\n\u00b6\n\n\nBut gucie modules are still registered in initialization phase (in \nGuiceBundle\n), when configuration is\nnot available. To overcome this, guicey provides \nmarker interfaces\n \nlike \nConfigurationAwareModule\n to set configuration object into module before injector creation.\n\n\n\n\nTip\n\n\nIf possible, use \nDropwizardAwareModule\n as base module class to avoid boilerplate\n\npublic\n \nclass\n \nSampleModule\n \nextends\n \nDropwizardAwareModule\n<\nConfiguration\n>\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nconfiguration\n()\n \n// access configuration        \n\n        \nenvironment\n()\n \n// access environment\n\n        \nbootstrap\n()\n  \n// access dropwizard bootstrap\n\n        \nconfiguratonTree\n()\n \n// configuration as tree of values\n\n        \nconfuguration\n(\nClass\n)\n \n// unique sub configuration\n\n        \nconfiguration\n(\nString\n)\n \n// configuration value by yaml path\n\n        \nconfigurations\n(\nClass\n)\n \n// sub configuration objects by type (including subtypes)\n\n        \noptions\n()\n \n// access guicey options\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\nThis works only for top level modules registered in root bundle or guicey bundles. \n\n\n\n\nBindings\n\u00b6\n\n\nGuicey always apply it's own module (\nGuiceBootstrapModule\n) to injector. This module \nadds all extra bindings (for dropwizard and jersey objects).  \n\n\n\n\nio.dropwizard.setup.Bootstrap\n \n\n\nio.dropwizard.Configuration\n\n\nio.dropwizard.setup.Environment\n\n\n\n\nBindings below are not immediately available as HK2 context \nstarts after guice\n:\n\n\n\n\njavax.ws.rs.core.Application\n\n\njavax.ws.rs.ext.Providers\n\n\norg.glassfish.hk2.api.ServiceLocator\n\n\norg.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider\n\n\n\n\nRequest-scoped bindings:\n\n\n\n\njavax.ws.rs.core.UriInfo\n\n\njavax.ws.rs.container.ResourceInfo\n\n\njavax.ws.rs.core.HttpHeaders\n\n\njavax.ws.rs.core.SecurityContext\n\n\njavax.ws.rs.core.Request\n\n\norg.glassfish.jersey.server.ContainerRequest\n\n\norg.glassfish.jersey.server.internal.process.AsyncContext\n\n\njavax.servlet.http.HttpServletRequest\n\n\njavax.servlet.http.HttpServletResponse\n\n\n\n\n\n\nRequest scoped objects must be used through provider:\n\n@Inject\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;\n\n\n\n\n\n\nConfiguration bindings\n\u00b6\n\n\nIt is quite common need to access configuration value by path, instead of using\nentire configuration object. Often this removes boilerplate when one option is used in multiple places, compare:\n\n\n@Inject\n \nMyConfiguration\n \nconfig\n\n\n...\n\n\n\n// in each usage\n\n\nconfig\n.\ngetSub\n().\ngetFoo\n()\n\n\n\n\n\nand \n\n\n@Inject\n \n@Config\n(\n\"sub.foo\"\n)\n \nString\n \nfoo\n;\n\n\n\n// and use direct value in all places\n\n\n\n\n\nAlso, often you have some unique configuration sub object, e.g. \n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n    \n@JsonProperty\n\n    \nAuthConfig\n \nauth\n;\n\n\n}\n\n\n\n\n\nIt may be more convenient to bind it directly, instead of full configuration:\n\n\n@Inject\n \n@Config\n \nAuthConfig\n \nauth\n;\n\n\n\n\n\n\n\nNote\n\n\nThis is especially helpful for extensions: if extension can be sure that\nit's configuration object would be used only once in your configuration - it could\ninject it directly, without dealing with your root configuration class.     \n\n\n\n\nYou can see all available bindings from your configuration using \nconfiguration report\n.\n\n\nExtensions\n\u00b6\n\n\nIn raw dropwizard you register extensions like: \n\n\npublic\n \nclass\n \nApp\n \nextends\n \nApplication\n<\nConfiguration\n>\n \n{\n\n\n    \n...\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nConfiguration\n \nconfiguration\n,\n \nEnvironment\n \nenvironment\n)\n \nthrows\n \nException\n \n{\n\n        \n// resource registration\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nMyResource\n.\nclass\n);\n\n        \n// if extension requires configuration:\n\n        \nenvironment\n.\nlifecycle\n().\nmanage\n(\nnew\n \nMyManaged\n(\nconfiguration\n.\ngetSomething\n()));\n\n    \n}\n    \n\n}\n\n\n\n\n\nVery easy, just need to remember where it should be registered.         \n\n\nIf we want to use guice for extensions management, then all extensions must be \nobtained from guice injector, but it's a boilerplate.\n\n\nInstead, guicey introduce \nExtension-Installer\n concept: you create extension (e.g. \nMyResource\n)\nand Installer knows how to install it. Guicey only need to know extension class.\n\n\nIf you use \nclasspath scanning\n, then you don't need to do anything: guicey will recognize extensions and install them.\n\n\nFor example, \nResourceInstaller\n will:\n\n\n\n\nrecognize \nMyResource\n class as rest resource by \n@Path\n annotation\n\n\ngets instance from injector (\ninjector.getInstance(MyResource.class)\n) and\nperforms registration \nenvironment.jersey().register(guiceManagedInstance)\n\n\n\n\nThe same way, \nMangedInstaller\n recognize \nMyManaged\n as managed extension (by implemented interface) and \ninstalls guice managed instance (and so all other extensions).\n\n\n\n\nSummary\n\n\nWith classpath scan you don't need to do anything to install extension and in manual mode \nyou only need to specify extension classes. \n\n\n\n\n\n\nTip\n\n\nMost installer implementations are very simple, so you can easily understand how it works \n(all core installers are declared in \ncore installers bundle\n).    \n\n\n\n\nJersey extensions\n\u00b6\n\n\nIt is important to note that jersey extensions (\nresources\n and \nother\n)\nare forced to be singletons (if explicit scope annotation is not set).\n\n\nThis force you to always use all request scoped objects through \nProvider\n. But, from the other side,\nthis avoids a jvm garbage from creating them for each request and makes everything a bit \nfaster (no extra DI work required for each request).\n\n\nIf you think that developer comfort worth more then small performance gain, then:\n\n\n\n\nYou can use explicit scope annotations to change singleton scope (\n@RequestScoped\n, \n@Prototype\n)\n\n\nSwitch off forced singletons (\n.option(InstallerOptions.ForceSingletonForJerseyExtensions, false)\n)\n\n\nDelegate some extensions or resources management to HK2 using \n@HK2Managed\n\n\nUse \nHK2 by default\n for jersey extensions\n\n\n\n\n\n\nWarning\n\n\nGuice AOP will not work on extensions managed by HK2 \n\n\n\n\nFor more guice-HK2 integration specifics read \nlifecycle section\n.    \n\n\nCustom extensions\n\u00b6\n\n\nInstallers are not limited to dropwizard only features: you can use custom installers to write\nany 3\nrd\n party integration. The only condition is extension classes must have some unique identity (usually annotation).\n\n\nFor example, guice has \n.asEeagerSingleton()\n configuration option, which declares service as singleton\nand grants it's initialization in time of injector creation (even in Development scope).\nYes, in dropwizard case it's better to use \nManaged\n extensions instead, but sometimes eager singletons\nare convenient for quick hacking something (besides, it's just an example).\nTo simplify eager singleton integrations we create new annotation \n@EagerSingleton\n and installer\n(\nEagerSingletonInstaller\n) which recognize annotation and register extensions as eager singletons. Now we need to just\nannotate class and (assuming classpath scan) it will be registered automatically.\n\n\n\n\nTip\n\n\nInstallers are also discovered and registered during classpath scan.   \n\n\n\n\nAnother example is \nPluginInstaller\n which allows you to declare plugins \n(e.g. implementing some interface) and inject all of them at once (as \nSet<PluginInterface>\n).\n\n\nExtensions project\n provides special installer to \n\nregister events in guava eventBus\n:\n\nEventBusInstaller\n check class methods and if any method is annotated with \n@Subscribe\n - register extension\nas event bus listener.\n\n\nNot existing, but possible extension for scheduled tasks: we can create \n@Schedule\n annotation\nand write installer to automatically register such classes in scheduler framework.\n\n\n\n\nSummary\n\n\nIn essence, custom installers could help you avoid many boilerplate operations.\n\n\n\n\n\n\nWarning\n\n\nEach extension could be installed only by one installer. It will be the first installer which recognize\nthe extension in class (according to \ninstallers order\n).\n\n\n\n\nCore installers override\n\u00b6\n\n\nIt is also possible to replace any core installer (e.g. to change it's behaviour) -\nyou just need to disable core installer and install a replacement:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n                \n...\n\n                \n.\ndisableInstaller\n(\nManagedInstaller\n.\nclass\n)\n\n                \n.\ninstallers\n(\nMyCustomManagedInstaller\n.\nclass\n)\n       \n                \n.\nbuild\n());\n\n\n\n\n\n\n\nTip\n\n\nYou can disable all installers enabled by default with:\n\n.\nnoDefaultInstallers\n()\n\n\n\nIn this case, you will have to register some installers manually (even if it would be just a few of \nguicey's own installers).\n\n\n\n\nBundles\n\u00b6\n\n\nDropwizard use bundles for re-usable logic. Bundle also support both dropwizard phases (in essence, it's the same as application)\n\n\npublic\n \ninterface\n \nConfiguredBundle\n<\nT\n>\n \n{\n\n    \nvoid\n \ninitialize\n(\nBootstrap\n<?>\n \nbootstrap\n);\n    \n    \nvoid\n \nrun\n(\nT\n \nconfiguration\n,\n \nEnvironment\n \nenvironment\n)\n \nthrows\n \nException\n;\n\n\n}\n\n\n\n\n\nThe concept is great, but, in context of guice, dropwizard bundle did not allow us to\nregister guice modules (and, of course, guicey installers and extensions).  So there is no way to\nelegantly re-use dropwizard bundles mechanism.\n\n\nGuicey introduce it's own bundles:\n\n\npublic\n \ninterface\n \nGuiceyBundle\n \n{\n\n    \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n);\n\n\n}\n\n\n\n\n\nGuiceyBootstrap\n provides almost all the same methods as main \nGuiceBundle\n, allowing you to register\ninstallers, extensions, modules and other bundles. Also, it provides access to dropwizard objects (bootstrap, configuration, environment)\n\n\n\n\nWarning\n\n\nGuicey bundles are called under dropwizard \nrun\n phase (method name may be confusing, comparing to dropwizard bundles).\nThat means you can't register dropwizard bundles inside guicey bundle (too late for that).\nRun phase used to provide all dropwizard objects (environment and configuration) and only \none method used because guicey bundles usually don't need to register dropwizard bundles)\n\n\n\n\n\n\nTip\n\n\nFor special cases, there is a way to \nmix guicey bundle with dropwizard\n: \nclass must just implement both bundle interfaces.\n\n\n\n\nBundles usage difference\n\u00b6\n\n\nIn dropwizard bundles are helpful not just for extracting re-usable extensions, but for\nseparation of application logic.\n\n\nIn guicey, you don't need to write registration code and, with auto scan enabled,\ndon't need to configure much at all. This makes guicy bundles mostly usable for 3\nrd\n party integrations (or core modules extraction for large projects), \nwhere you can't (and should not) rely on class path scan and must declare all installers and extensions manually.\n\n\nGuicey itself comes with multiple bundles: \n\n\n\n\nCore installers bundle\n - installers, enabled by default\n\n\nWeb installers bundle\n - web annotations installers for servlets and filters\n\n\nHK2/guice scope diagnostic bundle\n - enables instantiation tracking to catch extensions instantiation by both (or just not intended) DI\n\n\nDiagnostics bundle\n - configuration diagnostic reporting to look under the hood of configuration process\n\n\n\n\nLookup\n\u00b6\n\n\nDropwizard force you to always register bundles manually, and this is good for clarity.\nBut, sometimes, it is desirable to apply bundles under some condition. For example,\nyou want custom installers to be registered when 3\nrd\n party integrations jar is available\nor you may want to enable some bundles under integration tests only.\n\n\nGuicey provides such ability: \n\n\n\n\nadd bundles \nappeared in classpath\n (with ServiceLoader, not classpath scan)\n\n\ndeclare extra bundles \nwith system property\n (for example, could be used in tests)\n\n\napply \ncustom lookup implementation\n\n\n\n\nServiceLookup based lookup is ideal for 3\nrd\n party integrations. For example, suppose you have\nscheduler framework integration which provides installers for custom annotation (\n@Job\n). \nAll you need to do to apply extension is to put integration jar into classpath - installers will be \nimplicitly registered.\n\n\n\n\nImportant\n\n\nServiceLookup requires you to \nprepare extra files\n so you prepare your bundle for using that way.\nIt \ndoes not mean\n guicey loads all bundles in classpath!     \n\n\n\n\n\n\nNote\n\n\nServiceLoader and property based lookups are always enabled, but you can switch them \noff if required with \n.disableBundleLookup()\n bundle option.\n\n\n\n\nDisabling\n\u00b6\n\n\nAs you have seen in overriding installers example, you can disable installers. But actually you can disable almost anything:\ninstallers, extensions, guice modules and guicey bundles.\n\n\nMostly this is required for testing (to be able to exclude entire application parts and, maybe, replace with something else).\n\n\nBut, in some cases, you may want to change behaviour of 3\nrd\n party module: as an example above (with replaced installer),\nyou can replace extension, guice module (registered by some bundle), or even prevent entire bundle (with transitive bundles)\ninstallation.\n\n\nSuppose you have some 3\nrd\n party bundle:\n\n\npublic\n \nclass\n \nXBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nbootstrap\n\n            \n.\nextensions\n(...)\n\n            \n.\nmodules\n(\nnew\n \nXModule\n(),\n \nnew\n \nXAddonModule\n());\n\n    \n}\n    \n\n}\n\n\n\n\n\nAnd, for some reason, you don't need XAddonModule guice module, then you can simply disable it:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\nbundles\n(\nnew\n \nXBundle\n())\n\n            \n.\ndisableModules\n(\nXAddonModule\n.\nclass\n)\n\n            \n.\nbuild\n())\n\n\n\n\n\n\n\nTip\n\n\nYou can even perform \nmass disables by predicate\n. \nFor example, disable all installations (extensions, bundles etc) from package:\n\n.\ndisable\n(\nDisables\n.\ninPackage\n(\n\"some.package.here\"\n))\n\n\n\n\n\n\nGuice bindings overrides\n\u00b6\n\n\nGuice allows you to override any binding using \nModules.override()\n. \nWith it you can override any service in context. Guicey provides \ndirect shortcut for using this feature\n. \n\n\nMostly, this is handful for tests, but could be used to override some service, \nregistered by 3\nrd\n party module (probably registered by some bundle).\n\n\nOptions\n\u00b6\n\n\nDropwizard configuration covers most configuration cases, except development specific cases.\nFor example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration).\nOther example is an ability of low level tuning for 3\nrd\n party bundles.\n\n\n\n\nOptions\n are developer configurations: either required only for development or triggers set during development \nand not intended to be changed later.\n\n\n\n\n\n\nOptions are \ndeclared with enum\n (each enum represents options group) with value type declaration to grant safety.\n\n\nOption could be set only \nin main bundle\n (in your application class)\n\n\nYou can access options \nanywhere\n: guice module, guicey bundle, and in any guice service by injecting special service\n\n\nOptions report is included into \ndiagnostic report\n so you can see all option values.\n\n\n\n\nFor example, guicey use two option groups: \nGuiceyOptions\n and \nInstallersOptions\n.\n\nGuiceyOptions\n used for storing main bundle configurations like packages to scan, injector stage, HK2 bridge usage etc.\nThat means you have access to all these application configurations from anywhere in your code\n(for example, you can know if classpath scan is enabled or not in 3\nrd\n party bundle).\n\n\nAnother good example is \nInstallersOptions.JerseyExtensionsManagedByGuice\n which changes the way \njersey extensions are handled: with guice or with HK2. This is developer time decision and must be\nselected by developer (because it affects behaviour a lot). Thanks to generic mechanism other bundles could\nknow what was chosen.\n\n\nHK2 usage is highly dependent on \nHK2-guice-bridge\n presence and with option we can verify it:\n\n\nPreconditions\n.\ncheckState\n(\noptions\n.\nget\n(\nGuiceyOptions\n.\nUseHkBridge\n),\n \n                            \n\"HK2 guice bridge is required!\"\n)\n\n\n\n\n\nDynamic options\n\u00b6\n\n\nYou can bind option to system property in order to introduce special \"hidden\" application flag:\n\n\nGuiceBuilder\n.\nbuilder\n()\n\n    \n...\n\n    \n.\noptions\n(\nnew\n \nOptionsMapper\n()\n\n                    \n.\nprop\n(\n\"myprop\"\n,\n \nMyoptions\n.\nSomeOption\n)\n\n                    \n.\nmap\n())\n\n    \n.\nbuild\n()\n                \n\n\n\n\nNow you can run application with \n-Dmyprop=value\n and this value will be mapped to option (accessible everywhere in the application).\n\n\n\n\nNote\n\n\nThere are built-in basic value conversions from string, but in complex cases you can do manual conversion\n\n \n.\nprop\n(\n\"myprop\"\n,\n \nMyoptions\n.\nSomeOption\n,\n \nval\n \n->\n \nconvertVal\n(\nval\n))\n \n\n\n\n\n\n\n\nNote\n\n\nYou can map options from sys properties, environment variables or strings (obtained somewhere else).\nYou can even allow mass binding to allow external definition of any option \n.props(\"prefix\")\n.\nSee \noptions lookup\n doc.\n\n\n\n\nYou don't need to remember all this\n\u00b6\n\n\nAll guicey features could be revealed from main bundle methods. So you don't \nneed to remember everything - just look methods.\n\n\nThere is a special group of \nprint[Something]\n methods, which are intended to help\nyou understand internal state (and help with debugging).\n\n\nAs you have seen, real life configuration could be quite complex because you may have many extensions, observed with classpath scan,\nbundles, bundles installing other bundles, many gucie modules. Also, some bundles\nmay disable extensions, installers, guice modules (and some modules could even override bindings).\n\n\nDuring startup guicey tracks all performed configurations and you can even access this \ninformation at runtime using \n@Inject GuiceyConfigurationInfo info\n.\n\n\nOut of the box, guicey could print all this into console, you just need to add \n.printDiagnosticInfo()\n:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\nprintDiagnosticInfo\n()\n\n            \n.\nbuild\n())\n\n\n\n\n\nYou can see additional logs in console like:\n\n\n    GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    ...\n\n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceBootstrapModule           (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    ...\n\n\n\n\nAnd \nother logs\n giving you inside look on configuration.\n\n\nOther helpful reports:\n\n\n\n\nprintAvailableInstallers()\n - see all registered installers to know what features you can use\n\n\nprintConfigurationBindings()\n - show available configuration bindings (by path and unique objects)\n\n\nprintCustomConfigurationBindings()\n - the same as above, but without dropwizard configuration (shorter report)\n\n\nprintLifecyclePhases()\n - indicate running steps in logs\n\n\nprintLifecyclePhasesDetailed()\n - very detailed startup reports \n\n\n\n\nNot mentioned\n\u00b6\n\n\n\n\nDropwizard commands support\n (automatic commands installation with classpath scan)\n\n\nHiding classes from classpath scan\n\n\nIntegration tests support\n\n\nLifecycle events\n \n\n\nConfiguration hook\n\n\nAdmin rest support\n\n\nExt integrations like \njdbi\n, \neventbus",
            "title": "Concepts overview"
        },
        {
            "location": "/concepts/#concepts-overview",
            "text": "Section briefly describes new concepts introduced by guicey and explains why it was done that way.\nFor usage instruction and basic examples see  getting-started section .",
            "title": "Concepts overview"
        },
        {
            "location": "/concepts/#injector-creation-phase",
            "text": "Dropwizard declares two phases:    initialization ( App.initialize  method) - when dropwizard app must be configured  run ( App.run  method) - when configuration is available and extensions could be registered in environment   If we create injector in initialization phase then we will not have access to  Configuration  and  Environment \nin guice modules, but configuration could be required, especially for 3 rd  party modules, which\ndoes not support lazy configuration.     Guicey creates injector at  run phase  to allow using configuration (and environment) in guice modules.   Many people ask why not just use HK2 instead of guice as it's already provided. \nUnfortunately, it's hard to use it in the same elegant way as we can use guice. \nHK2 context is launched too late (after dropwizard run phase). For example, it is \nimpossible to use HK2 to instantiate dropwizard managed object because managed \nmust be registered before HK2 context starts.",
            "title": "Injector creation phase"
        },
        {
            "location": "/concepts/#guice-module",
            "text": "But gucie modules are still registered in initialization phase (in  GuiceBundle ), when configuration is\nnot available. To overcome this, guicey provides  marker interfaces  \nlike  ConfigurationAwareModule  to set configuration object into module before injector creation.   Tip  If possible, use  DropwizardAwareModule  as base module class to avoid boilerplate public   class   SampleModule   extends   DropwizardAwareModule < Configuration >   { \n\n     @Override \n     protected   void   configure ()   { \n         configuration ()   // access configuration         \n         environment ()   // access environment \n         bootstrap ()    // access dropwizard bootstrap \n         configuratonTree ()   // configuration as tree of values \n         confuguration ( Class )   // unique sub configuration \n         configuration ( String )   // configuration value by yaml path \n         configurations ( Class )   // sub configuration objects by type (including subtypes) \n         options ()   // access guicey options \n     }  }     Note  This works only for top level modules registered in root bundle or guicey bundles.",
            "title": "Guice module"
        },
        {
            "location": "/concepts/#bindings",
            "text": "Guicey always apply it's own module ( GuiceBootstrapModule ) to injector. This module \nadds all extra bindings (for dropwizard and jersey objects).     io.dropwizard.setup.Bootstrap    io.dropwizard.Configuration  io.dropwizard.setup.Environment   Bindings below are not immediately available as HK2 context  starts after guice :   javax.ws.rs.core.Application  javax.ws.rs.ext.Providers  org.glassfish.hk2.api.ServiceLocator  org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider   Request-scoped bindings:   javax.ws.rs.core.UriInfo  javax.ws.rs.container.ResourceInfo  javax.ws.rs.core.HttpHeaders  javax.ws.rs.core.SecurityContext  javax.ws.rs.core.Request  org.glassfish.jersey.server.ContainerRequest  org.glassfish.jersey.server.internal.process.AsyncContext  javax.servlet.http.HttpServletRequest  javax.servlet.http.HttpServletResponse    Request scoped objects must be used through provider: @Inject   Provider < HttpServletRequest >   requestProvider ;",
            "title": "Bindings"
        },
        {
            "location": "/concepts/#configuration-bindings",
            "text": "It is quite common need to access configuration value by path, instead of using\nentire configuration object. Often this removes boilerplate when one option is used in multiple places, compare:  @Inject   MyConfiguration   config  ...  // in each usage  config . getSub (). getFoo ()   and   @Inject   @Config ( \"sub.foo\" )   String   foo ;  // and use direct value in all places   Also, often you have some unique configuration sub object, e.g.   public   class   MyConfig   extends   Configuration   { \n     @JsonProperty \n     AuthConfig   auth ;  }   It may be more convenient to bind it directly, instead of full configuration:  @Inject   @Config   AuthConfig   auth ;    Note  This is especially helpful for extensions: if extension can be sure that\nit's configuration object would be used only once in your configuration - it could\ninject it directly, without dealing with your root configuration class.        You can see all available bindings from your configuration using  configuration report .",
            "title": "Configuration bindings"
        },
        {
            "location": "/concepts/#extensions",
            "text": "In raw dropwizard you register extensions like:   public   class   App   extends   Application < Configuration >   { \n\n     ... \n\n     @Override \n     public   void   run ( Configuration   configuration ,   Environment   environment )   throws   Exception   { \n         // resource registration \n         environment . jersey (). register ( MyResource . class ); \n         // if extension requires configuration: \n         environment . lifecycle (). manage ( new   MyManaged ( configuration . getSomething ())); \n     }      }   Very easy, just need to remember where it should be registered.           If we want to use guice for extensions management, then all extensions must be \nobtained from guice injector, but it's a boilerplate.  Instead, guicey introduce  Extension-Installer  concept: you create extension (e.g.  MyResource )\nand Installer knows how to install it. Guicey only need to know extension class.  If you use  classpath scanning , then you don't need to do anything: guicey will recognize extensions and install them.  For example,  ResourceInstaller  will:   recognize  MyResource  class as rest resource by  @Path  annotation  gets instance from injector ( injector.getInstance(MyResource.class) ) and\nperforms registration  environment.jersey().register(guiceManagedInstance)   The same way,  MangedInstaller  recognize  MyManaged  as managed extension (by implemented interface) and \ninstalls guice managed instance (and so all other extensions).   Summary  With classpath scan you don't need to do anything to install extension and in manual mode \nyou only need to specify extension classes.     Tip  Most installer implementations are very simple, so you can easily understand how it works \n(all core installers are declared in  core installers bundle ).",
            "title": "Extensions"
        },
        {
            "location": "/concepts/#jersey-extensions",
            "text": "It is important to note that jersey extensions ( resources  and  other )\nare forced to be singletons (if explicit scope annotation is not set).  This force you to always use all request scoped objects through  Provider . But, from the other side,\nthis avoids a jvm garbage from creating them for each request and makes everything a bit \nfaster (no extra DI work required for each request).  If you think that developer comfort worth more then small performance gain, then:   You can use explicit scope annotations to change singleton scope ( @RequestScoped ,  @Prototype )  Switch off forced singletons ( .option(InstallerOptions.ForceSingletonForJerseyExtensions, false) )  Delegate some extensions or resources management to HK2 using  @HK2Managed  Use  HK2 by default  for jersey extensions    Warning  Guice AOP will not work on extensions managed by HK2    For more guice-HK2 integration specifics read  lifecycle section .",
            "title": "Jersey extensions"
        },
        {
            "location": "/concepts/#custom-extensions",
            "text": "Installers are not limited to dropwizard only features: you can use custom installers to write\nany 3 rd  party integration. The only condition is extension classes must have some unique identity (usually annotation).  For example, guice has  .asEeagerSingleton()  configuration option, which declares service as singleton\nand grants it's initialization in time of injector creation (even in Development scope).\nYes, in dropwizard case it's better to use  Managed  extensions instead, but sometimes eager singletons\nare convenient for quick hacking something (besides, it's just an example).\nTo simplify eager singleton integrations we create new annotation  @EagerSingleton  and installer\n( EagerSingletonInstaller ) which recognize annotation and register extensions as eager singletons. Now we need to just\nannotate class and (assuming classpath scan) it will be registered automatically.   Tip  Installers are also discovered and registered during classpath scan.      Another example is  PluginInstaller  which allows you to declare plugins \n(e.g. implementing some interface) and inject all of them at once (as  Set<PluginInterface> ).  Extensions project  provides special installer to  register events in guava eventBus : EventBusInstaller  check class methods and if any method is annotated with  @Subscribe  - register extension\nas event bus listener.  Not existing, but possible extension for scheduled tasks: we can create  @Schedule  annotation\nand write installer to automatically register such classes in scheduler framework.   Summary  In essence, custom installers could help you avoid many boilerplate operations.    Warning  Each extension could be installed only by one installer. It will be the first installer which recognize\nthe extension in class (according to  installers order ).",
            "title": "Custom extensions"
        },
        {
            "location": "/concepts/#core-installers-override",
            "text": "It is also possible to replace any core installer (e.g. to change it's behaviour) -\nyou just need to disable core installer and install a replacement:  bootstrap . addBundle ( GuiceBundle . builder () \n                 ... \n                 . disableInstaller ( ManagedInstaller . class ) \n                 . installers ( MyCustomManagedInstaller . class )        \n                 . build ());    Tip  You can disable all installers enabled by default with: . noDefaultInstallers ()  \nIn this case, you will have to register some installers manually (even if it would be just a few of \nguicey's own installers).",
            "title": "Core installers override"
        },
        {
            "location": "/concepts/#bundles",
            "text": "Dropwizard use bundles for re-usable logic. Bundle also support both dropwizard phases (in essence, it's the same as application)  public   interface   ConfiguredBundle < T >   { \n     void   initialize ( Bootstrap <?>   bootstrap );     \n     void   run ( T   configuration ,   Environment   environment )   throws   Exception ;  }   The concept is great, but, in context of guice, dropwizard bundle did not allow us to\nregister guice modules (and, of course, guicey installers and extensions).  So there is no way to\nelegantly re-use dropwizard bundles mechanism.  Guicey introduce it's own bundles:  public   interface   GuiceyBundle   { \n     void   initialize ( GuiceyBootstrap   bootstrap );  }   GuiceyBootstrap  provides almost all the same methods as main  GuiceBundle , allowing you to register\ninstallers, extensions, modules and other bundles. Also, it provides access to dropwizard objects (bootstrap, configuration, environment)   Warning  Guicey bundles are called under dropwizard  run  phase (method name may be confusing, comparing to dropwizard bundles).\nThat means you can't register dropwizard bundles inside guicey bundle (too late for that).\nRun phase used to provide all dropwizard objects (environment and configuration) and only \none method used because guicey bundles usually don't need to register dropwizard bundles)    Tip  For special cases, there is a way to  mix guicey bundle with dropwizard : \nclass must just implement both bundle interfaces.",
            "title": "Bundles"
        },
        {
            "location": "/concepts/#bundles-usage-difference",
            "text": "In dropwizard bundles are helpful not just for extracting re-usable extensions, but for\nseparation of application logic.  In guicey, you don't need to write registration code and, with auto scan enabled,\ndon't need to configure much at all. This makes guicy bundles mostly usable for 3 rd  party integrations (or core modules extraction for large projects), \nwhere you can't (and should not) rely on class path scan and must declare all installers and extensions manually.  Guicey itself comes with multiple bundles:    Core installers bundle  - installers, enabled by default  Web installers bundle  - web annotations installers for servlets and filters  HK2/guice scope diagnostic bundle  - enables instantiation tracking to catch extensions instantiation by both (or just not intended) DI  Diagnostics bundle  - configuration diagnostic reporting to look under the hood of configuration process",
            "title": "Bundles usage difference"
        },
        {
            "location": "/concepts/#lookup",
            "text": "Dropwizard force you to always register bundles manually, and this is good for clarity.\nBut, sometimes, it is desirable to apply bundles under some condition. For example,\nyou want custom installers to be registered when 3 rd  party integrations jar is available\nor you may want to enable some bundles under integration tests only.  Guicey provides such ability:    add bundles  appeared in classpath  (with ServiceLoader, not classpath scan)  declare extra bundles  with system property  (for example, could be used in tests)  apply  custom lookup implementation   ServiceLookup based lookup is ideal for 3 rd  party integrations. For example, suppose you have\nscheduler framework integration which provides installers for custom annotation ( @Job ). \nAll you need to do to apply extension is to put integration jar into classpath - installers will be \nimplicitly registered.   Important  ServiceLookup requires you to  prepare extra files  so you prepare your bundle for using that way.\nIt  does not mean  guicey loads all bundles in classpath!         Note  ServiceLoader and property based lookups are always enabled, but you can switch them \noff if required with  .disableBundleLookup()  bundle option.",
            "title": "Lookup"
        },
        {
            "location": "/concepts/#disabling",
            "text": "As you have seen in overriding installers example, you can disable installers. But actually you can disable almost anything:\ninstallers, extensions, guice modules and guicey bundles.  Mostly this is required for testing (to be able to exclude entire application parts and, maybe, replace with something else).  But, in some cases, you may want to change behaviour of 3 rd  party module: as an example above (with replaced installer),\nyou can replace extension, guice module (registered by some bundle), or even prevent entire bundle (with transitive bundles)\ninstallation.  Suppose you have some 3 rd  party bundle:  public   class   XBundle   implements   GuiceyBundle   { \n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n         bootstrap \n             . extensions (...) \n             . modules ( new   XModule (),   new   XAddonModule ()); \n     }      }   And, for some reason, you don't need XAddonModule guice module, then you can simply disable it:  bootstrap . addBundle ( GuiceBundle . builder () \n             . bundles ( new   XBundle ()) \n             . disableModules ( XAddonModule . class ) \n             . build ())    Tip  You can even perform  mass disables by predicate . \nFor example, disable all installations (extensions, bundles etc) from package: . disable ( Disables . inPackage ( \"some.package.here\" ))",
            "title": "Disabling"
        },
        {
            "location": "/concepts/#guice-bindings-overrides",
            "text": "Guice allows you to override any binding using  Modules.override() . \nWith it you can override any service in context. Guicey provides  direct shortcut for using this feature .   Mostly, this is handful for tests, but could be used to override some service, \nregistered by 3 rd  party module (probably registered by some bundle).",
            "title": "Guice bindings overrides"
        },
        {
            "location": "/concepts/#options",
            "text": "Dropwizard configuration covers most configuration cases, except development specific cases.\nFor example, some trigger may be useful during application testing and be useless on production (so no reason to put it in configuration).\nOther example is an ability of low level tuning for 3 rd  party bundles.   Options  are developer configurations: either required only for development or triggers set during development \nand not intended to be changed later.    Options are  declared with enum  (each enum represents options group) with value type declaration to grant safety.  Option could be set only  in main bundle  (in your application class)  You can access options  anywhere : guice module, guicey bundle, and in any guice service by injecting special service  Options report is included into  diagnostic report  so you can see all option values.   For example, guicey use two option groups:  GuiceyOptions  and  InstallersOptions . GuiceyOptions  used for storing main bundle configurations like packages to scan, injector stage, HK2 bridge usage etc.\nThat means you have access to all these application configurations from anywhere in your code\n(for example, you can know if classpath scan is enabled or not in 3 rd  party bundle).  Another good example is  InstallersOptions.JerseyExtensionsManagedByGuice  which changes the way \njersey extensions are handled: with guice or with HK2. This is developer time decision and must be\nselected by developer (because it affects behaviour a lot). Thanks to generic mechanism other bundles could\nknow what was chosen.  HK2 usage is highly dependent on  HK2-guice-bridge  presence and with option we can verify it:  Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ),  \n                             \"HK2 guice bridge is required!\" )",
            "title": "Options"
        },
        {
            "location": "/concepts/#dynamic-options",
            "text": "You can bind option to system property in order to introduce special \"hidden\" application flag:  GuiceBuilder . builder () \n     ... \n     . options ( new   OptionsMapper () \n                     . prop ( \"myprop\" ,   Myoptions . SomeOption ) \n                     . map ()) \n     . build ()                   Now you can run application with  -Dmyprop=value  and this value will be mapped to option (accessible everywhere in the application).   Note  There are built-in basic value conversions from string, but in complex cases you can do manual conversion   . prop ( \"myprop\" ,   Myoptions . SomeOption ,   val   ->   convertVal ( val ))      Note  You can map options from sys properties, environment variables or strings (obtained somewhere else).\nYou can even allow mass binding to allow external definition of any option  .props(\"prefix\") .\nSee  options lookup  doc.",
            "title": "Dynamic options"
        },
        {
            "location": "/concepts/#you-dont-need-to-remember-all-this",
            "text": "All guicey features could be revealed from main bundle methods. So you don't \nneed to remember everything - just look methods.  There is a special group of  print[Something]  methods, which are intended to help\nyou understand internal state (and help with debugging).  As you have seen, real life configuration could be quite complex because you may have many extensions, observed with classpath scan,\nbundles, bundles installing other bundles, many gucie modules. Also, some bundles\nmay disable extensions, installers, guice modules (and some modules could even override bindings).  During startup guicey tracks all performed configurations and you can even access this \ninformation at runtime using  @Inject GuiceyConfigurationInfo info .  Out of the box, guicey could print all this into console, you just need to add  .printDiagnosticInfo() :  bootstrap . addBundle ( GuiceBundle . builder () \n             . printDiagnosticInfo () \n             . build ())   You can see additional logs in console like:      GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    ...\n\n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceBootstrapModule           (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    ...  And  other logs  giving you inside look on configuration.  Other helpful reports:   printAvailableInstallers()  - see all registered installers to know what features you can use  printConfigurationBindings()  - show available configuration bindings (by path and unique objects)  printCustomConfigurationBindings()  - the same as above, but without dropwizard configuration (shorter report)  printLifecyclePhases()  - indicate running steps in logs  printLifecyclePhasesDetailed()  - very detailed startup reports",
            "title": "You don't need to remember all this"
        },
        {
            "location": "/concepts/#not-mentioned",
            "text": "Dropwizard commands support  (automatic commands installation with classpath scan)  Hiding classes from classpath scan  Integration tests support  Lifecycle events    Configuration hook  Admin rest support  Ext integrations like  jdbi ,  eventbus",
            "title": "Not mentioned"
        },
        {
            "location": "/guide/configuration/",
            "text": "Configuration\n\u00b6\n\n\nBuilder \nGuiceBundle.builder()\n contains shortcuts for all available features, so you can always find required function \nby looking at available methods and reading javadoc.\n\n\n\n\nConfiguration subjects (vocabulary)\n\n\n\n\nInstallers - used to recognize and install extension (usually encapsulates integration logic: get extension instance from guice injector and register in dropwizard (or jersey, HK2, whatever))\n\n\nExtensions - actual application parts, written by you (resources, tasks, health checks, servlets etc)\n\n\nGuice modules\n\n\nGuicey bundles - groups installers, extensions, gucie modules and other guicey bundles (represent reusable logic or \n3\nrd\n party integrations; very similar to dropwizard bundles)\n\n\nOptions - general mechanism for low level configurations (development time triggers)\n\n\nCommands - dropwizard commands (mentioned because of ability for automatic registration)\n\n\n\n\n\n\n\n\nWarning\n\n\nConfigured bundles, modules, installers and extensions are checked for duplicates using \nclass type\n. Duplicate configurations will be simply ignored.\nFor modules and bundles, which configured using instances, duplicates removes means that if two instances of the same type registered, then second instance will\nbe ignored. For example, in case of \n.bundles(new MyBundle(\"one\"), new MyBundle(\"two))\n\nthe second bundle will be ignored becuause bundle with the same type is already registered \n(no matter that constructor parameters are different - only type matters).\n\n\n\n\nConfiguration process is recorded and may be observed with by \ndiagnostic info\n,\nso there is always a way to understand what and how was configured.\n\n\n\n\nTip\n\n\nYou can see used configuration objects by enabling \ndetailed lifecycle logs\n:\n\nbundle\n.\nprintLifecyclePhasesDetailed\n()\n\n\n\n\n\n\nAuto configuration\n\u00b6\n\n\nAuto configuration enables \nclasspath scan\n to search for extensions and custom installers. \nWithout auto scan, all extensions (resource, managed, health check etc.) must be registered \nmanually\n (manual mode).\n\n\n.\nenableAutoConfig\n(\n\"com.mycompany.app\"\n)\n\n\n\n\n\nor multiple packages\n\n\n.\nenableAutoConfig\n(\n\"com.mycompany.app.resources\"\n,\n \n\"com.mycompany.app.staff\"\n)\n\n\n\n\n\nCommands search\n\u00b6\n\n\nIn auto configuration mode guicey could also \nsearch and install\n dropwiard commands (register in bootstrap object):\n\n\n.\nsearchCommands\n()\n\n\n\n\n\nBy default commands scan is disabled because it may be confusing. Besides, it's not often needed.\n\n\nExtensions\n\u00b6\n\n\nAll features installed with guicey installers are called extensions. When auto configuration is enabled, extensions are discovered\nautomatically. Without auto configuration (manual mode) all extensions must be specified manually.\n\n\n.\nextensions\n(\nMyResource1\n.\nclass\n,\n \nMyHealthCheck\n.\nclass\n)\n\n\n\n\n\nAuto configuration may be used together with manual definition (for example, manually registered extension could be unreachable for\nclasspath scan).\n\n\n\n\nEach extension could be installed only by one installer: if multiple installers could recognize extension, \nonly one of them will install it (first one according to priority).\n\n\n\n\n\n\nTip\n\n\nAny extension could be disabled with \n.disableExtension(Extension.class)\n \n(may be useful to disable not needed extension from 3\nrd\n party bundle)\n\n\n\n\nDisable extensions\n\u00b6\n\n\nYou can disable extensions (even if it's not registered)\n\n\n.\ndisableExtensions\n(\nExtensionOne\n.\nclass\n,\n \nExtensionTwo\n.\nclass\n)\n\n\n\n\n\n\n\nTip\n\n\nThis may be used when classpath scanner detected class you don't need to be installed\nand you can't use \n@InvisibleForScanner\n annotation on it.\n\n\n\n\nMostly useful for tests.\n\n\nInstallers\n\u00b6\n\n\nGuicey come with pre-defined set of installers (for common extensions). But you can \nwrite your own installers\n\n(or use some 3\nrd\n party ones).\n\n\n\n\nMost installers implementations are very simple and easy to understand. Look installer source to better understand\nhow extensions work. In case when default installer does not fit your needs, it's not hard to replace installer \nwith your custom version.\n\n\n\n\n.\ninstallers\n(\nMyExtensionInstaller\n.\nclass\n,\n \nThirdPartyExtensionInstaller\n.\nclass\n)\n\n\n\n\n\n\n\nTip\n\n\nIn auto configuration mode, installers are also detected and installed automatically\n\n\n\n\nDisable default installers\n\u00b6\n\n\nYou can disable all default installers:\n\n\n.\nnoDefaultInstallers\n()\n\n\n\n\n\nBut note that in this case you must register at least one installer\n(it could be one of core installers) because otherwise no extensions could be installed.\n\n\nWeb installers\n\u00b6\n\n\nGuicey has \nadvanced installers\n for standard servlet annotations (\n@WebServlet\n, \n@WebFilter\n, \n@WebListener\n).\nThey are not enabled by default to avoid confusion: user may not expect guice support for these standard annotations.\n\n\nTo enable web installers:\n\n\n.\nuseWebInstallers\n()\n\n\n\n\n\nDisable installers\n\u00b6\n\n\nYou can disable installers (even if it's not registered)\n\n\n.\ndisableInstallers\n(\nManagedInstaller\n.\nclass\n,\n \nResourceInstaller\n.\nclass\n)\n\n\n\n\n\nMostly useful for tests.\n\n\nAvailbale installers\n\u00b6\n\n\nSpecial debug option could \nprint to console all available installers\n (with registration sources):\n\n\n.\nprintAvailableInstallers\n()\n\n\n\n\n\nUse to quickly understand available features.\n\n\nGuice modules\n\u00b6\n\n\nYou can register one or more guice modules (including guice \nServletModule\ns):\n\n\n.\nmodules\n(\nnew\n \nMyModule1\n(),\n \nnew\n \nMyModule2\n())\n\n\n\n\n\nIf you have many modules try to group their installation inside your custom module in order\nto keep guice staff together.\n\n\nIn some cases, it could be desired to use different instances of the same module:\n\n.\nmodules\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n),\n \nnew\n \nParametrizableModule\n(\n\"mod2\"\n))\n\n\n\nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module:\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod1\"\n));\n\n\ninstall\n(\nnew\n \nParametrizableModule\n(\n\"mod2\"\n));\n\n\n\n\nDisable guice modules\n\u00b6\n\n\nYou can disable guice modules (even if it's not registered)\n\n\n.\ndisableInstallers\n(\nModleOne\n.\nclass\n,\n \nModuleTwo\n.\nclass\n)\n\n\n\n\n\n\n\nImportant\n\n\nThis will affect only modules directly registered in main bundle or guicey bundle\n(modules installed inside guice module are not affected).\n\n\n\n\nThis is mostly useful for tests, but could be used to prevent some additional module \ninstallation by 3\nrd\n party bundle (or may be used to override such module).\n\n\n\n\nTip\n\n\nNote that you can also override some bindings (see below) instead of entire module override    \n\n\n\n\nOverride guice bindings\n\u00b6\n\n\nGuice allows you to override any binding with \nModules.override()\n. \nWith it you can override any service in context. Guicey provides direct shortcut \nfor using this feature. \n\n\nMostly, this is handful for tests, but could be used to override some service, \nregistered by 3\nrd\n party module (probably registered by some bundle).\n\n\nSuppose we have 3\nrd\n party service with a bug, registered by 3\nrd\n party module:\n\n\npublic\n \nclass\n \nXModule\n \nextends\n \nAbstractModule\n \n{\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nbind\n(\nXService\n.\nclass\n).\nasEagerSingleton\n();\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nWe can override it with fixed version:\n\n\npublic\n \nclass\n \nFixXServiceModule\n \nextends\n \nAbstractModule\n \n{\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \n// module with only one binding overriding original definition\n\n        \nbind\n(\nXService\n.\nclass\n).\nto\n(\nFixedXService\n.\nclass\n);\n        \n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nFixedXService\n \nextends\n \nXService\n \n{\n\n    \n...\n\n\n}\n \n\n\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\nmodules\n(\nnew\n \nXModule\n())\n\n            \n.\nmodulesOverride\n(\nnew\n \nFixXServiceModule\n())\n\n            \n.\nbuild\n())\n\n\n\n\n\nNow all guice injector will use your service (\nFixedXService\n) instead of \nXService\n.\n\n\nGuicey bundles\n\u00b6\n\n\nIn essence, \nguicey bundles\n are the same as dropwizard bundles: used to install re-usable logic or \n3\nrd\n party library integration.\n\n\n.\nbundles\n(\nnew\n \nMyBundle\n(),\n \nnew\n \nThirdPartyBundle\n());\n\n\n\n\n\nDropwizard bundles unification\n\u00b6\n\n\nGuice bundles must implement interface (\nGuiceyBundle\n). Dropwizard bundle could implement it too. \nThis may be useful for \nuniversal bundles\n when you can register something \nin dropwizard bootstrap (or simply directly) and some features in guicey way (extensions).\n\n\nWhen:\n\n\n.\nconfigureFromDropwizardBundles\n()\n\n\n\n\n\nguicey checks registered dropwizard bundles if they are also \nGuiceyBundle\n and register them as guicey bundles.\n\n\nBundle lookup\n\u00b6\n\n\nBundle lookup\n mechanism provides support for indirect guicey bundles installation.\nDefault lookup mechanism allows using service loader (plug-n-play bundles) or system property (test/diagnostic bundles). \n\n\nCustom implementation could be specified:\n\n\n.\nbundleLookup\n(\nnew\n \nMyBundleLookupImpl\n())\n\n\n\n\n\nShortcut to disable default bundle lookup:\n\n\n.\ndisableBundleLookup\n()\n\n\n\n\n\nDisable bundles\n\u00b6\n\n\nGuicey bundles could be disabled only in root bundle. Bundles can't disable other bundles.  \n\n\n.\ndisableBundles\n(\nMyBundle\n.\nclass\n)\n\n\n\n\n\nThis is mostly useful for tests, but could also be used to disable some not required transitive bundle, installed by\n3\nrd\n party bundle.\n\n\nOptions\n\u00b6\n\n\nOptions\n are used for development time configurations (test specific triggers or low level configurations).\nGuicey option enums: \nGuiceyOptions\n and \nInstallersOptions\n\n\n.\noption\n(\nGuiceyOptions\n.\nInjectorStage\n,\n \nStage\n.\nDEVELOPMENT\n)\n\n\n\n\n\n\n\nTip\n\n\nOptions look better with static import: \n.\noption\n(\nInjectorStage\n,\n \nDEVELOPMENT\n)\n\n\n\n\nOptions mapper\n could be used to map option value \nfrom system properties, environment variables or simple strings (basic type conversions supported):\n\n\n.\noptions\n(\nnew\n \nOptionsMapper\n()\n\n                \n.\nprop\n(\n\"myprop\"\n,\n \nMyoptions\n.\nSomeOption\n)\n\n                \n.\nenv\n(\n\"STAGE\"\n,\n \nGuiceyOptions\n.\nInjectorStage\n)\n\n                \n.\nstring\n(\n\"property value\"\n,\n \nMyoptions\n.\nSomeOtherOption\n)\n\n                \n.\nmap\n())\n                \n\n\n\n\nDisable by predicate\n\u00b6\n\n\nThere is also a generic disable method using predicate. With it you can disable\nitems (bundles, modules, installers, extensions) by package or by installation bundle\nor some other custom condition (e.g. introduce your disabling annotation and handle it with predicate).\n\n\nSupposed to be used in integration tests, but could be used directly too in specific cases.\n\n\nimport static\n \nru.vyarus.dropwizard.guice.module.context.Disables.*\n\n\n\n.\ndisable\n(\ninPackage\n(\n\"com.foo.feature\"\n,\n \n\"com.foo.feature2\"\n));\n\n\n\n\n\nDisable all extensions lying in package (or subpackage). It could be extension, bundle, installer, guice module.\nIf you use package by feature approach then you can easily switch off entire features in tests.\n\n\nimport static\n \nru.vyarus.dropwizard.guice.module.context.Disables.*\n\n\n\n.\ndisable\n(\ninstaller\n()\n\n         \n.\nand\n(\nregisteredBy\n(\nApplication\n.\nclass\n))\n\n         \n.\nand\n(\ntype\n(\nSomeInstallerType\n.\nclass\n).\nnegate\n());\n\n\n\n\n\nDisable all installers, directly registered in main bundle except \nSomeInstallerType\n\n\nimport static\n \nru.vyarus.dropwizard.guice.module.context.Disables.*\n\n\n\n.\ndisable\n(\ntype\n(\nMyExtension\n.\nclass\n,\n\n         \nMyInstaller\n.\nclass\n,\n\n         \nMyBundle\n.\nclass\n,\n\n         \nMyModule\n.\nclass\n));\n\n\n\n\n\nSimply disable items by type.\n\n\nThe condition is java \nPredicate\n. Use \nPredicate#and(Predicate)\n, \nPredicate#or(Predicate)\n\nand \nPredicate#negate()\n to compose complex conditions from simple ones.\n\n\nMost common predicates could be build with \nru.vyarus.dropwizard.guice.module.context.Disables\n\nutility (examples above).\n\n\nGuice\n\u00b6\n\n\nStage\n\u00b6\n\n\nGuice stage cold be provided in:\n\n\n.\nbuild\n(\nStage\n.\nDEVELOPMENT\n)\n\n\n\n\n\nBy default, PRODUCTION stage used.\n\n\nInjector\n\u00b6\n\n\nCustom guice injector factory\n may be registered to customize injector creation. \nFor example, custom factory is required for \ngovernator\n integration:\n\n\n.\ninjectorFactory\n(\nnew\n \nGovernatorInjectorFactory\n())\n\n\n\n\n\nAlso, custom factory may be used to \noverride already overridden guice bindings in tests\n\n\nServletModule\n\u00b6\n\n\nBy default, guicey \nregisters\n \nGuiceFilter\n for both main and admin contexts to provide request scopes for both contexts and\nability to use guice \nServletModule\ns on main context.\n\n\nGuiceFilter\n is registered with REQUEST dispatcher type. If you need to use other types:\n\n\n.\noption\n(\nGuiceFilterRegistration\n,\n \nEnumSet\n.\nof\n(\nREQUEST\n,\n \nFORWARD\n))\n\n\n\n\n\nIf you \ndon't need servlet module support\n (and request scopes), guice filter installation could be disabled:\n\n\n.\nnoGuiceFilter\n()\n\n\n\n\n\nServlet modules will be rejected in this case. Intended to be used when \nweb installers\n enabled.\n\n\n\n\nNote\n\n\nHttpServletRequest\n and \nHttpServletResponse\n objects will be available for injection only in scope of jersey resources call.\n\n\n\n\nConfiguration binding by interface\n\u00b6\n\n\n\n\nDeprecated\n\n\nOption remain for compatibility and will be eventually removed.\nYou can always bind configuration by implemented interface \nusing qualifier\n:\n\n@Inject\n \n@Config\n \nHasRequiredConfig\n \nconfig\n;\n \n\n\nAlso, unique configuration sub objects are also \navailable for injection\n \n(much better option rather then marker interface):\n\n@Inject\n \n@Config\n \nRequiredConfig\n \nconfig\n;\n \n\n\n\n\n\nIt may be useful to bind configuration instance to interface. Suppose some 3\nrd\n party requires your configuration\nto implement interface:\n\n\npublic\n \nclass\n \nMyConfiguration\n \nextends\n \nConfiguration\n \nimplements\n \nHasRequiredConfig\n \n{...}\n\n\n\n\n\nIf binding by interface is enabled:\n\n\n.\nbindConfigurationInterfaces\n()\n\n\n\n\n\nThen configuration could be injected by interface:\n\n\n@Inject\n \nHasRequiredConfig\n \nconf\n;\n\n\n\n\n\nHK2 bridge\n\u00b6\n\n\nIf you need HK2 services be able to use guice beans, then \nHK2 bridge\n \nmust be activated. \nThis may be useful when some services are managed by HK2 (e.g. with \n@HK2Managed\n).\n\n\nTo activate bridge:\n\n\n\n\nAdd dependency: \norg.glassfish.hk2:guice-bridge:2.5.0-b32\n (version must match HK2 version, used by dropwizard)\n\n\nEnable option: \n.\noption\n(\nGuiceyOptions\n.\nUseHkBridge\n,\n \ntrue\n)\n\n\n\n\nAfter that, HK2 beans could inject guice beans:\n\n\n@HK2Managed\n\n\npublic\n \nclass\n \nHkService\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nGuiceService\n \nservice\n;\n\n\n}\n\n\n\n\n\nUse HK2 for jersey extensions\n\u00b6\n\n\nBy default, guice is used to construct all extensions, including jersey related (resources, providers)\nwhich are registered in HK2 context as instances.\n\n\nIf you want to use HK2 for jersey extensions management then use:\n\n\n.\nuseHK2ForJerseyExtensions\n()\n\n\n\n\n\n(It is the same effect as if you will annotate all jersey extensions with \n@HK2Managed\n)\n\n\nAfter enabling, all jersey extensions will be created by HK2. \nOption requires HK2-guice bridge (error will be thrown if bridge is not available in classpath)\nto use guice services inside HK2 managed beans.\n\n\n\n\nWarning\n\n\nGuice AOP will work only for instances created by guice, so after enabling this option you will not\nbe able to use aop on jersey extensions.\n\n\n\n\nBy analogy with \n@HK2Managed\n, you can use \n@GuiceManaged\n to mark exceptional extensions,\nwhich must be still managed by guice.\n\n\nLifecycle events\n\u00b6\n\n\nGuicey broadcast events on all important configuration phases. These events contain\nreferences to all available environment objects and current context configuration.\nFor example, after event with all resolved extension or event with all processed bundles.\n\n\nEvents are used to print lifecycle phases report (see below), but you may use it \nto modify installers, bundles, extensions (post process instances, but not affect quantity).  \n\n\nEvents are registered with:\n\n\n.\nlisten\n(\nnew\n \nMyEventListener\n())\n\n\n\n\n\nRead more in \nevents documentation\n.\n\n\nDiagnostic\n\u00b6\n\n\nStartup errors could be debugged with lifecycle logs:\n\n\n.\nprintLifecyclePhasesDetailed\n()\n\n\n\n\n\n\n\nTip\n\n\nEspecially helpful when classpath scanner accept classes you don't need because\nit will prints all resolved extension before injector creation.\n\n\n\n\n\n\nTip\n\n\nReport shows disabled items. Use \ndiagnostic logs\n to find the disabler.  \n\n\n\n\n\n\nNote\n\n\n.printLifecyclePhases()\n could be used to just indicate phases in logs without additional details\n(useful when need to understand initialization order)\n\n\n\n\nIf you have problems with \nconfiguration bindings\n (or just need to see available bindings) use:\n\n\n.\nprintConfigurationBindings\n()\n\n\n\n\n\n\n\nNote\n\n\nBindings report is printed before injector creation (in case if startup fails due to missed binding) \n\n\n\n\nEnable configuration \ndiagnostic console logs\n to diagnose configuration problems:\n\n\n.\nprintDiagnosticInfo\n()\n\n\n\n\n\nIn case of doubts about extension owner (guice or HK2) and suspicious for duplicate instantiation,\nyou can enable \nstrict control\n which will throw exception in case of wrong owner:\n\n\n.\nstrictScopeControl\n()\n\n\n\n\n\n\n\nNote\n\n\nWhen you have duplicate initialization (most likely for jersey related extensions)\nfirst check that you are not register extension manually! \nUsing constructor injection helps preventing such errors (manual places will immediately reveal).\n\n\n\n\nGuicey configuration hooks\n\u00b6\n\n\nThere is an external configuration mechanism. It could be used to modify \napplication configuration externally without application modification:\n\n\npublic\n \ninterface\n \nGuiceyConfigurationHook\n \n{\n\n    \nvoid\n \nconfigure\n(\nGuiceBundle\n.\nBuilder\n \nbuilder\n);\n    \n\n}\n\n\n\n\n\nHook implementation will receive the same builder instance as used in \nGuiceBundle\n \nand so it is able to change anything (for example, \nGuiceyBundle\n abilities are limited).\n\n\nIf hook is a class then it could be registered directly:\n\n\nnew\n \nMyHook\n().\nregister\n()\n\n\n\n\n\nOtherwise lambda may be used:\n\n\nConfigurationHooksSupport\n.\nregister\n(\nbuilder\n \n->\n \n{\n \n    \n// do modifications \n\n\n})\n\n\n\n\n\nAll hooks are executed just before guice bundle builder finalization (when you call last \n.build()\n method).\nHooks registered after this moment will simply be never used.\n\n\n\n\nNote\n\n\nThis functionality is intended to be used for integration tests and there is\na \nspecial test support\n for it.  \n\n\n\n\nIn hook you can do all the same as in main application configuration. In context of tests,\n the most important is:\n\n\n\n\nChange options\n\n\nDisable any bundle, installer, extension, module\n\n\nRegister disable predicate (to disable features by package, registration source etc.)\n\n\nOverride guice bindings\n\n\nRegister additional bundles, extensions, modules (usually test-specific, for example guicey tests register \nadditional guice module with restricted guice options (disableCircularProxies, requireExplicitBindings, requireExactBindingAnnotations))",
            "title": "Configuration"
        },
        {
            "location": "/guide/configuration/#configuration",
            "text": "Builder  GuiceBundle.builder()  contains shortcuts for all available features, so you can always find required function \nby looking at available methods and reading javadoc.   Configuration subjects (vocabulary)   Installers - used to recognize and install extension (usually encapsulates integration logic: get extension instance from guice injector and register in dropwizard (or jersey, HK2, whatever))  Extensions - actual application parts, written by you (resources, tasks, health checks, servlets etc)  Guice modules  Guicey bundles - groups installers, extensions, gucie modules and other guicey bundles (represent reusable logic or \n3 rd  party integrations; very similar to dropwizard bundles)  Options - general mechanism for low level configurations (development time triggers)  Commands - dropwizard commands (mentioned because of ability for automatic registration)     Warning  Configured bundles, modules, installers and extensions are checked for duplicates using  class type . Duplicate configurations will be simply ignored.\nFor modules and bundles, which configured using instances, duplicates removes means that if two instances of the same type registered, then second instance will\nbe ignored. For example, in case of  .bundles(new MyBundle(\"one\"), new MyBundle(\"two)) \nthe second bundle will be ignored becuause bundle with the same type is already registered \n(no matter that constructor parameters are different - only type matters).   Configuration process is recorded and may be observed with by  diagnostic info ,\nso there is always a way to understand what and how was configured.   Tip  You can see used configuration objects by enabling  detailed lifecycle logs : bundle . printLifecyclePhasesDetailed ()",
            "title": "Configuration"
        },
        {
            "location": "/guide/configuration/#auto-configuration",
            "text": "Auto configuration enables  classpath scan  to search for extensions and custom installers. \nWithout auto scan, all extensions (resource, managed, health check etc.) must be registered  manually  (manual mode).  . enableAutoConfig ( \"com.mycompany.app\" )   or multiple packages  . enableAutoConfig ( \"com.mycompany.app.resources\" ,   \"com.mycompany.app.staff\" )",
            "title": "Auto configuration"
        },
        {
            "location": "/guide/configuration/#commands-search",
            "text": "In auto configuration mode guicey could also  search and install  dropwiard commands (register in bootstrap object):  . searchCommands ()   By default commands scan is disabled because it may be confusing. Besides, it's not often needed.",
            "title": "Commands search"
        },
        {
            "location": "/guide/configuration/#extensions",
            "text": "All features installed with guicey installers are called extensions. When auto configuration is enabled, extensions are discovered\nautomatically. Without auto configuration (manual mode) all extensions must be specified manually.  . extensions ( MyResource1 . class ,   MyHealthCheck . class )   Auto configuration may be used together with manual definition (for example, manually registered extension could be unreachable for\nclasspath scan).   Each extension could be installed only by one installer: if multiple installers could recognize extension, \nonly one of them will install it (first one according to priority).    Tip  Any extension could be disabled with  .disableExtension(Extension.class)  \n(may be useful to disable not needed extension from 3 rd  party bundle)",
            "title": "Extensions"
        },
        {
            "location": "/guide/configuration/#disable-extensions",
            "text": "You can disable extensions (even if it's not registered)  . disableExtensions ( ExtensionOne . class ,   ExtensionTwo . class )    Tip  This may be used when classpath scanner detected class you don't need to be installed\nand you can't use  @InvisibleForScanner  annotation on it.   Mostly useful for tests.",
            "title": "Disable extensions"
        },
        {
            "location": "/guide/configuration/#installers",
            "text": "Guicey come with pre-defined set of installers (for common extensions). But you can  write your own installers \n(or use some 3 rd  party ones).   Most installers implementations are very simple and easy to understand. Look installer source to better understand\nhow extensions work. In case when default installer does not fit your needs, it's not hard to replace installer \nwith your custom version.   . installers ( MyExtensionInstaller . class ,   ThirdPartyExtensionInstaller . class )    Tip  In auto configuration mode, installers are also detected and installed automatically",
            "title": "Installers"
        },
        {
            "location": "/guide/configuration/#disable-default-installers",
            "text": "You can disable all default installers:  . noDefaultInstallers ()   But note that in this case you must register at least one installer\n(it could be one of core installers) because otherwise no extensions could be installed.",
            "title": "Disable default installers"
        },
        {
            "location": "/guide/configuration/#web-installers",
            "text": "Guicey has  advanced installers  for standard servlet annotations ( @WebServlet ,  @WebFilter ,  @WebListener ).\nThey are not enabled by default to avoid confusion: user may not expect guice support for these standard annotations.  To enable web installers:  . useWebInstallers ()",
            "title": "Web installers"
        },
        {
            "location": "/guide/configuration/#disable-installers",
            "text": "You can disable installers (even if it's not registered)  . disableInstallers ( ManagedInstaller . class ,   ResourceInstaller . class )   Mostly useful for tests.",
            "title": "Disable installers"
        },
        {
            "location": "/guide/configuration/#availbale-installers",
            "text": "Special debug option could  print to console all available installers  (with registration sources):  . printAvailableInstallers ()   Use to quickly understand available features.",
            "title": "Availbale installers"
        },
        {
            "location": "/guide/configuration/#guice-modules",
            "text": "You can register one or more guice modules (including guice  ServletModule s):  . modules ( new   MyModule1 (),   new   MyModule2 ())   If you have many modules try to group their installation inside your custom module in order\nto keep guice staff together.  In some cases, it could be desired to use different instances of the same module: . modules ( new   ParametrizableModule ( \"mod1\" ),   new   ParametrizableModule ( \"mod2\" ))  \nThis will not work (second instance will be dropped). In such cases do registrations in custom\nguice module: install ( new   ParametrizableModule ( \"mod1\" ));  install ( new   ParametrizableModule ( \"mod2\" ));",
            "title": "Guice modules"
        },
        {
            "location": "/guide/configuration/#disable-guice-modules",
            "text": "You can disable guice modules (even if it's not registered)  . disableInstallers ( ModleOne . class ,   ModuleTwo . class )    Important  This will affect only modules directly registered in main bundle or guicey bundle\n(modules installed inside guice module are not affected).   This is mostly useful for tests, but could be used to prevent some additional module \ninstallation by 3 rd  party bundle (or may be used to override such module).   Tip  Note that you can also override some bindings (see below) instead of entire module override",
            "title": "Disable guice modules"
        },
        {
            "location": "/guide/configuration/#override-guice-bindings",
            "text": "Guice allows you to override any binding with  Modules.override() . \nWith it you can override any service in context. Guicey provides direct shortcut \nfor using this feature.   Mostly, this is handful for tests, but could be used to override some service, \nregistered by 3 rd  party module (probably registered by some bundle).  Suppose we have 3 rd  party service with a bug, registered by 3 rd  party module:  public   class   XModule   extends   AbstractModule   { \n     protected   void   configure ()   { \n         bind ( XService . class ). asEagerSingleton (); \n         ... \n     }  }   We can override it with fixed version:  public   class   FixXServiceModule   extends   AbstractModule   { \n     protected   void   configure ()   { \n         // module with only one binding overriding original definition \n         bind ( XService . class ). to ( FixedXService . class );         \n     }  }  public   class   FixedXService   extends   XService   { \n     ...  }    bootstrap . addBundle ( GuiceBundle . builder () \n             . modules ( new   XModule ()) \n             . modulesOverride ( new   FixXServiceModule ()) \n             . build ())   Now all guice injector will use your service ( FixedXService ) instead of  XService .",
            "title": "Override guice bindings"
        },
        {
            "location": "/guide/configuration/#guicey-bundles",
            "text": "In essence,  guicey bundles  are the same as dropwizard bundles: used to install re-usable logic or \n3 rd  party library integration.  . bundles ( new   MyBundle (),   new   ThirdPartyBundle ());",
            "title": "Guicey bundles"
        },
        {
            "location": "/guide/configuration/#dropwizard-bundles-unification",
            "text": "Guice bundles must implement interface ( GuiceyBundle ). Dropwizard bundle could implement it too. \nThis may be useful for  universal bundles  when you can register something \nin dropwizard bootstrap (or simply directly) and some features in guicey way (extensions).  When:  . configureFromDropwizardBundles ()   guicey checks registered dropwizard bundles if they are also  GuiceyBundle  and register them as guicey bundles.",
            "title": "Dropwizard bundles unification"
        },
        {
            "location": "/guide/configuration/#bundle-lookup",
            "text": "Bundle lookup  mechanism provides support for indirect guicey bundles installation.\nDefault lookup mechanism allows using service loader (plug-n-play bundles) or system property (test/diagnostic bundles).   Custom implementation could be specified:  . bundleLookup ( new   MyBundleLookupImpl ())   Shortcut to disable default bundle lookup:  . disableBundleLookup ()",
            "title": "Bundle lookup"
        },
        {
            "location": "/guide/configuration/#disable-bundles",
            "text": "Guicey bundles could be disabled only in root bundle. Bundles can't disable other bundles.    . disableBundles ( MyBundle . class )   This is mostly useful for tests, but could also be used to disable some not required transitive bundle, installed by\n3 rd  party bundle.",
            "title": "Disable bundles"
        },
        {
            "location": "/guide/configuration/#options",
            "text": "Options  are used for development time configurations (test specific triggers or low level configurations).\nGuicey option enums:  GuiceyOptions  and  InstallersOptions  . option ( GuiceyOptions . InjectorStage ,   Stage . DEVELOPMENT )    Tip  Options look better with static import:  . option ( InjectorStage ,   DEVELOPMENT )   Options mapper  could be used to map option value \nfrom system properties, environment variables or simple strings (basic type conversions supported):  . options ( new   OptionsMapper () \n                 . prop ( \"myprop\" ,   Myoptions . SomeOption ) \n                 . env ( \"STAGE\" ,   GuiceyOptions . InjectorStage ) \n                 . string ( \"property value\" ,   Myoptions . SomeOtherOption ) \n                 . map ())",
            "title": "Options"
        },
        {
            "location": "/guide/configuration/#disable-by-predicate",
            "text": "There is also a generic disable method using predicate. With it you can disable\nitems (bundles, modules, installers, extensions) by package or by installation bundle\nor some other custom condition (e.g. introduce your disabling annotation and handle it with predicate).  Supposed to be used in integration tests, but could be used directly too in specific cases.  import static   ru.vyarus.dropwizard.guice.module.context.Disables.*  . disable ( inPackage ( \"com.foo.feature\" ,   \"com.foo.feature2\" ));   Disable all extensions lying in package (or subpackage). It could be extension, bundle, installer, guice module.\nIf you use package by feature approach then you can easily switch off entire features in tests.  import static   ru.vyarus.dropwizard.guice.module.context.Disables.*  . disable ( installer () \n          . and ( registeredBy ( Application . class )) \n          . and ( type ( SomeInstallerType . class ). negate ());   Disable all installers, directly registered in main bundle except  SomeInstallerType  import static   ru.vyarus.dropwizard.guice.module.context.Disables.*  . disable ( type ( MyExtension . class , \n          MyInstaller . class , \n          MyBundle . class , \n          MyModule . class ));   Simply disable items by type.  The condition is java  Predicate . Use  Predicate#and(Predicate) ,  Predicate#or(Predicate) \nand  Predicate#negate()  to compose complex conditions from simple ones.  Most common predicates could be build with  ru.vyarus.dropwizard.guice.module.context.Disables \nutility (examples above).",
            "title": "Disable by predicate"
        },
        {
            "location": "/guide/configuration/#guice",
            "text": "",
            "title": "Guice"
        },
        {
            "location": "/guide/configuration/#stage",
            "text": "Guice stage cold be provided in:  . build ( Stage . DEVELOPMENT )   By default, PRODUCTION stage used.",
            "title": "Stage"
        },
        {
            "location": "/guide/configuration/#injector",
            "text": "Custom guice injector factory  may be registered to customize injector creation. \nFor example, custom factory is required for  governator  integration:  . injectorFactory ( new   GovernatorInjectorFactory ())   Also, custom factory may be used to  override already overridden guice bindings in tests",
            "title": "Injector"
        },
        {
            "location": "/guide/configuration/#servletmodule",
            "text": "By default, guicey  registers   GuiceFilter  for both main and admin contexts to provide request scopes for both contexts and\nability to use guice  ServletModule s on main context.  GuiceFilter  is registered with REQUEST dispatcher type. If you need to use other types:  . option ( GuiceFilterRegistration ,   EnumSet . of ( REQUEST ,   FORWARD ))   If you  don't need servlet module support  (and request scopes), guice filter installation could be disabled:  . noGuiceFilter ()   Servlet modules will be rejected in this case. Intended to be used when  web installers  enabled.   Note  HttpServletRequest  and  HttpServletResponse  objects will be available for injection only in scope of jersey resources call.",
            "title": "ServletModule"
        },
        {
            "location": "/guide/configuration/#configuration-binding-by-interface",
            "text": "Deprecated  Option remain for compatibility and will be eventually removed.\nYou can always bind configuration by implemented interface  using qualifier : @Inject   @Config   HasRequiredConfig   config ;   \nAlso, unique configuration sub objects are also  available for injection  \n(much better option rather then marker interface): @Inject   @Config   RequiredConfig   config ;     It may be useful to bind configuration instance to interface. Suppose some 3 rd  party requires your configuration\nto implement interface:  public   class   MyConfiguration   extends   Configuration   implements   HasRequiredConfig   {...}   If binding by interface is enabled:  . bindConfigurationInterfaces ()   Then configuration could be injected by interface:  @Inject   HasRequiredConfig   conf ;",
            "title": "Configuration binding by interface"
        },
        {
            "location": "/guide/configuration/#hk2-bridge",
            "text": "If you need HK2 services be able to use guice beans, then  HK2 bridge  \nmust be activated. \nThis may be useful when some services are managed by HK2 (e.g. with  @HK2Managed ).  To activate bridge:   Add dependency:  org.glassfish.hk2:guice-bridge:2.5.0-b32  (version must match HK2 version, used by dropwizard)  Enable option:  . option ( GuiceyOptions . UseHkBridge ,   true )   After that, HK2 beans could inject guice beans:  @HK2Managed  public   class   HkService   { \n\n     @Inject \n     private   GuiceService   service ;  }",
            "title": "HK2 bridge"
        },
        {
            "location": "/guide/configuration/#use-hk2-for-jersey-extensions",
            "text": "By default, guice is used to construct all extensions, including jersey related (resources, providers)\nwhich are registered in HK2 context as instances.  If you want to use HK2 for jersey extensions management then use:  . useHK2ForJerseyExtensions ()   (It is the same effect as if you will annotate all jersey extensions with  @HK2Managed )  After enabling, all jersey extensions will be created by HK2. \nOption requires HK2-guice bridge (error will be thrown if bridge is not available in classpath)\nto use guice services inside HK2 managed beans.   Warning  Guice AOP will work only for instances created by guice, so after enabling this option you will not\nbe able to use aop on jersey extensions.   By analogy with  @HK2Managed , you can use  @GuiceManaged  to mark exceptional extensions,\nwhich must be still managed by guice.",
            "title": "Use HK2 for jersey extensions"
        },
        {
            "location": "/guide/configuration/#lifecycle-events",
            "text": "Guicey broadcast events on all important configuration phases. These events contain\nreferences to all available environment objects and current context configuration.\nFor example, after event with all resolved extension or event with all processed bundles.  Events are used to print lifecycle phases report (see below), but you may use it \nto modify installers, bundles, extensions (post process instances, but not affect quantity).    Events are registered with:  . listen ( new   MyEventListener ())   Read more in  events documentation .",
            "title": "Lifecycle events"
        },
        {
            "location": "/guide/configuration/#diagnostic",
            "text": "Startup errors could be debugged with lifecycle logs:  . printLifecyclePhasesDetailed ()    Tip  Especially helpful when classpath scanner accept classes you don't need because\nit will prints all resolved extension before injector creation.    Tip  Report shows disabled items. Use  diagnostic logs  to find the disabler.      Note  .printLifecyclePhases()  could be used to just indicate phases in logs without additional details\n(useful when need to understand initialization order)   If you have problems with  configuration bindings  (or just need to see available bindings) use:  . printConfigurationBindings ()    Note  Bindings report is printed before injector creation (in case if startup fails due to missed binding)    Enable configuration  diagnostic console logs  to diagnose configuration problems:  . printDiagnosticInfo ()   In case of doubts about extension owner (guice or HK2) and suspicious for duplicate instantiation,\nyou can enable  strict control  which will throw exception in case of wrong owner:  . strictScopeControl ()    Note  When you have duplicate initialization (most likely for jersey related extensions)\nfirst check that you are not register extension manually! \nUsing constructor injection helps preventing such errors (manual places will immediately reveal).",
            "title": "Diagnostic"
        },
        {
            "location": "/guide/configuration/#guicey-configuration-hooks",
            "text": "There is an external configuration mechanism. It could be used to modify \napplication configuration externally without application modification:  public   interface   GuiceyConfigurationHook   { \n     void   configure ( GuiceBundle . Builder   builder );      }   Hook implementation will receive the same builder instance as used in  GuiceBundle  \nand so it is able to change anything (for example,  GuiceyBundle  abilities are limited).  If hook is a class then it could be registered directly:  new   MyHook (). register ()   Otherwise lambda may be used:  ConfigurationHooksSupport . register ( builder   ->   {  \n     // do modifications   })   All hooks are executed just before guice bundle builder finalization (when you call last  .build()  method).\nHooks registered after this moment will simply be never used.   Note  This functionality is intended to be used for integration tests and there is\na  special test support  for it.     In hook you can do all the same as in main application configuration. In context of tests,\n the most important is:   Change options  Disable any bundle, installer, extension, module  Register disable predicate (to disable features by package, registration source etc.)  Override guice bindings  Register additional bundles, extensions, modules (usually test-specific, for example guicey tests register \nadditional guice module with restricted guice options (disableCircularProxies, requireExplicitBindings, requireExactBindingAnnotations))",
            "title": "Guicey configuration hooks"
        },
        {
            "location": "/guide/lifecycle/",
            "text": "Integration lifecycle\n\u00b6\n\n\nJersey2 guice integration is more complicated than for jersey1, because of \nHK2\n container, used by jersey2.\n\n\n\n\nNote\n\n\nMany people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it \nin the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase).\nFor example, it is impossible to use HK2 to instantiate dropwizard managed object because managed\nmust be registered before HK2 context starts.\n\n\n\n\nGuice integration done in guice exclusive way as much as possible: everything should be managed by guice and invisibly integrated into HK2.\nAnyway, it is not always possible to hide integration details, especially if you need to register jersey extensions.\n\n\n\n\nTip\n\n\nYou can use \nguicey lifecycle events\n to see initialization stages in logs:\n\n.printLifecyclePhases()\n \n\n\n\n\nLifecycle\n\u00b6\n\n\n\n\nDropwizard configuration phase (\n~Application.initialize\n)   \n\n\nApply \nconfiguration hooks\n\n\nGuice bundle registered \n\n\nPerform \nclasspath scan for commands\n (\noptional\n)\n\n\n\n\n\n\nDropwizard run phase (\n~Application.run\n)\n\n\nDropwizard runs bundles (guice bundle is one of them so guice initialization may be performed between other dropwizard bundles)\n\n\nSearch guicey bundles in dropwizard bundles (\noptional\n) \n\n\nLookup guicey bundles\n   \n\n\nApply configuration from guicey bundles\n\n\nInjector creation\n (\nusing factory\n)\n\n\nBind dropwizard objects\n: Environment, Configuration, Bootstrap\n\n\nScan for installers (in auto configuration mode)\n\n\nScan for extensions (in auto configuration mode)\n\n\nRegister \nGuiceFeature\n in environment (jersey \nFeature\n which will trigger jersey side installations)\n\n\nApply \nlazy jersey bindings\n\n\nActivate \nguice servlet support\n, register GuiceFilter on admin and main contexts (\ncould be disabled\n)\n\n\n\n\n\n\nInjector created\n\n\nCall installers to register extensions\n\n\n\n\n\n\nYour application's \nrun\n method executed. Injector is already available, so any guice bean could be \naccessed\n          \n\n\n\n\n\n\nJersey start\n\n\nManaged beans\n started\n\n\nHK2 context creation\n (jersey start)\n\n\nGuiceFeature\n (registered earlier) called\n\n\nOptionally\n register \nHK2-guice bridge\n (only guice to hk2 way to let hk2 managed beans inject guice beans)\n\n\nRun jersey specific installers (\nresource\n, \nextension\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nAny \nEnvironmentCommand\n did no start jersey, so managed objects will not be started.\nAlso, all jersey related extensions will not be started. Still, core guice context will be completely operable. \n\n\n\n\n\n\nWhen guice context is created, \njersey context doesn't exist\n and when jersey context is created \nit doesn't aware of guice existence\n.\n\n\n\n\nCross context bindings\n\u00b6\n\n\nAccess jersey beans from guice\n\u00b6\n\n\nTo access HK2 bindings we need HK2 \nServiceLocator\n: it's instance is registered by \nGuiceFeature\n (in time of HK2 context startup).\n\n\nJersey components are bound as providers:\n\n\nbinder\n.\nbind\n(\njerseyType\n).\ntoProvider\n(\nnew\n \nLazyJerseyProvider\n(\njerseyType\n));\n\n\n\n\n\nInternally this provider will perform lookup in HK2 service locator:\n\n\ninjector\n.\ngetInstance\n(\nServiceLocator\n.\nclass\n).\ngetService\n(\njerseyType\n);\n\n\n\n\n\nThis way jersey beans are \"bridged\" to guice. They can't be accessed directly in guice beans\nat injector creation time (as there is nothing to \"bridge\" yet). \n\n\n@Inject\n \nProvider\n<\nJerseyType\n>\n \nprovider\n must be used to access such beans.     \n\n\nSee more details in \njersey bindings module\n.\n\n\nAccess guice beans from jersey\n\u00b6\n\n\n\n\nNote\n\n\nIt's almost never required to care about beans visibility from HK2 side because guicey already did all required\nbindings.\n\n\n\n\nHK2 could see all guice beans because of registered guice-bridge. But it doesn't mean HK2 can analyze \nall guice beans to search for extensions (it can resolve only direct injection).\n\n\nSpecific jersey installers (\nresource\n, \nextension\n) \ncreate required bindings manually in time of HK2 context creation.\n\n\nJersey extensions installer\n handles most specific installation cases\n(where HK2 knowledge is required). It uses the same technic, as the other side binding:\n\n\nbinder\n.\nbindFactory\n(\nnew\n \nLazyGuiceProvider\n(\nguiceType\n)).\nto\n(\ntype\n)\n\n\n\n\n\nOn request, factory will simply delegate lookup to guice injector:\n\n\ninjector\n.\ngetInstance\n(\nguiceType\n);\n\n\n\n\n\n\n\nTip\n\n\nIf you just want to add some beans in HK2 context, annotate such beans with \n@Provider\n and \n@HK2Managed\n - provider\nwill be recognized by installer and HK2 managed annotation will trigger simple registration (overall it's the same\nas write binding manually).\n\n@HK2Managed\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyBeanMangedByHK2\n \n{\n \n...\n \n}\n    \n\n\n\n\n\nFor more details look \njersey provider installer\n\n\nProblematic cases\n\u00b6\n\n\nThe problems may appear with binding of jersey extensions.\nGood example is \nValueFactoryProvider\n. Most likely you will use \nAbstractValueFactoryProvider\n as base class, but it declares\ndirect binding for \nMultivaluedParameterExtractorProvider\n. So such bean would be impossible to create eagerly in guice context.\n\n\nThere are two options to solve this:\n\n\n\n\nuse \n@LazyBinding\n: bean instance will not be created together with guice context (when \nMultivaluedParameterExtractorProvider\n is not available),\nand creation will be initiated by HK2, when binding could be resolved.\n\n\nor use \n@HK2Managed\n this will delegate instance management to HK2, but still guice services \nmay be injected\n.\n\n\n\n\n\n\nNote\n\n\nYou may use \nHK2-first strategy\n and create all jersey \nextensions in HK2 instead of guice. In this case you can use \n@GuiceManaged\n annotation to delegate management back to guice.\n\n\n\n\nIn other cases simply wrap jersey specific bindings into \nProvider\n.",
            "title": "Integration lifecycle"
        },
        {
            "location": "/guide/lifecycle/#integration-lifecycle",
            "text": "Jersey2 guice integration is more complicated than for jersey1, because of  HK2  container, used by jersey2.   Note  Many people ask why not just use HK2 instead of guice as it's already provided. Unfortunately, it's hard to use it \nin the same elegant way as we can use guice. HK2 context is launched too late (after dropwizard run phase).\nFor example, it is impossible to use HK2 to instantiate dropwizard managed object because managed\nmust be registered before HK2 context starts.   Guice integration done in guice exclusive way as much as possible: everything should be managed by guice and invisibly integrated into HK2.\nAnyway, it is not always possible to hide integration details, especially if you need to register jersey extensions.   Tip  You can use  guicey lifecycle events  to see initialization stages in logs: .printLifecyclePhases()",
            "title": "Integration lifecycle"
        },
        {
            "location": "/guide/lifecycle/#lifecycle",
            "text": "Dropwizard configuration phase ( ~Application.initialize )     Apply  configuration hooks  Guice bundle registered   Perform  classpath scan for commands  ( optional )    Dropwizard run phase ( ~Application.run )  Dropwizard runs bundles (guice bundle is one of them so guice initialization may be performed between other dropwizard bundles)  Search guicey bundles in dropwizard bundles ( optional )   Lookup guicey bundles      Apply configuration from guicey bundles  Injector creation  ( using factory )  Bind dropwizard objects : Environment, Configuration, Bootstrap  Scan for installers (in auto configuration mode)  Scan for extensions (in auto configuration mode)  Register  GuiceFeature  in environment (jersey  Feature  which will trigger jersey side installations)  Apply  lazy jersey bindings  Activate  guice servlet support , register GuiceFilter on admin and main contexts ( could be disabled )    Injector created  Call installers to register extensions    Your application's  run  method executed. Injector is already available, so any guice bean could be  accessed               Jersey start  Managed beans  started  HK2 context creation  (jersey start)  GuiceFeature  (registered earlier) called  Optionally  register  HK2-guice bridge  (only guice to hk2 way to let hk2 managed beans inject guice beans)  Run jersey specific installers ( resource ,  extension )          Note  Any  EnvironmentCommand  did no start jersey, so managed objects will not be started.\nAlso, all jersey related extensions will not be started. Still, core guice context will be completely operable.     When guice context is created,  jersey context doesn't exist  and when jersey context is created  it doesn't aware of guice existence .",
            "title": "Lifecycle"
        },
        {
            "location": "/guide/lifecycle/#cross-context-bindings",
            "text": "",
            "title": "Cross context bindings"
        },
        {
            "location": "/guide/lifecycle/#access-jersey-beans-from-guice",
            "text": "To access HK2 bindings we need HK2  ServiceLocator : it's instance is registered by  GuiceFeature  (in time of HK2 context startup).  Jersey components are bound as providers:  binder . bind ( jerseyType ). toProvider ( new   LazyJerseyProvider ( jerseyType ));   Internally this provider will perform lookup in HK2 service locator:  injector . getInstance ( ServiceLocator . class ). getService ( jerseyType );   This way jersey beans are \"bridged\" to guice. They can't be accessed directly in guice beans\nat injector creation time (as there is nothing to \"bridge\" yet).   @Inject   Provider < JerseyType >   provider  must be used to access such beans.       See more details in  jersey bindings module .",
            "title": "Access jersey beans from guice"
        },
        {
            "location": "/guide/lifecycle/#access-guice-beans-from-jersey",
            "text": "Note  It's almost never required to care about beans visibility from HK2 side because guicey already did all required\nbindings.   HK2 could see all guice beans because of registered guice-bridge. But it doesn't mean HK2 can analyze \nall guice beans to search for extensions (it can resolve only direct injection).  Specific jersey installers ( resource ,  extension ) \ncreate required bindings manually in time of HK2 context creation.  Jersey extensions installer  handles most specific installation cases\n(where HK2 knowledge is required). It uses the same technic, as the other side binding:  binder . bindFactory ( new   LazyGuiceProvider ( guiceType )). to ( type )   On request, factory will simply delegate lookup to guice injector:  injector . getInstance ( guiceType );    Tip  If you just want to add some beans in HK2 context, annotate such beans with  @Provider  and  @HK2Managed  - provider\nwill be recognized by installer and HK2 managed annotation will trigger simple registration (overall it's the same\nas write binding manually). @HK2Managed  @Provider  public   class   MyBeanMangedByHK2   {   ...   }        For more details look  jersey provider installer",
            "title": "Access guice beans from jersey"
        },
        {
            "location": "/guide/lifecycle/#problematic-cases",
            "text": "The problems may appear with binding of jersey extensions.\nGood example is  ValueFactoryProvider . Most likely you will use  AbstractValueFactoryProvider  as base class, but it declares\ndirect binding for  MultivaluedParameterExtractorProvider . So such bean would be impossible to create eagerly in guice context.  There are two options to solve this:   use  @LazyBinding : bean instance will not be created together with guice context (when  MultivaluedParameterExtractorProvider  is not available),\nand creation will be initiated by HK2, when binding could be resolved.  or use  @HK2Managed  this will delegate instance management to HK2, but still guice services  may be injected .    Note  You may use  HK2-first strategy  and create all jersey \nextensions in HK2 instead of guice. In this case you can use  @GuiceManaged  annotation to delegate management back to guice.   In other cases simply wrap jersey specific bindings into  Provider .",
            "title": "Problematic cases"
        },
        {
            "location": "/guide/injector/",
            "text": "Injector instance\n\u00b6\n\n\nRestrictive options\n\u00b6\n\n\nGuicey itself is compatible with the following guice restrictive options:\n\n\npublic\n \nclass\n \nMyModule\n \nextends\n \nAbstractModule\n \n{\n\n        \n@Override\n\n        \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n            \nbinder\n().\ndisableCircularProxies\n();\n\n            \nbinder\n().\nrequireExactBindingAnnotations\n();\n\n            \nbinder\n().\nrequireExplicitBindings\n();\n\n        \n}\n\n    \n}\n\n\n\n\n\nSo it is safe to enable them.\n\n\nAccess injector\n\u00b6\n\n\nIn some cases it may be important to get injector instance outside of guice context.\n\n\n\n\nWarning\n\n\nInjector is created on dropwizard run phase. Attempt to obtain injector before it\nwill lead to exception.\n\n\n\n\nInjector instance could be resolved with:\n\n\n\n\ngetInjector()\n method on GuiceBundle instance (NPE will be thrown if injector not initialized)\n\n\nInjectorLookup.getInjector(app).get()\n static call using application instance (lookup returns \nOptional\n for null safety).\n\n\n\n\nIf you need lazy injector reference, you can use \nInjectorProvider\n class (it's actually \nProvider<Injector>\n):\n\n\nProvider\n<\nInjector\n>\n \nprovider\n \n=\n \nnew\n \nInjectorProvider\n(\napp\n);\n\n\n// somewhere after run phase\n\n\nInjector\n \ninjector\n \n=\n \nprovider\n.\nget\n();\n\n\n\n\n\nWhen you are inside your application class:\n\n\npublic\n \nclass\n \nMyApplication\n \nextends\n \nApplication\n<\nConfiguration\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nTestConfiguration\n \nconfiguration\n,\n \nEnvironment\n \nenvironment\n)\n \nthrows\n \nException\n \n{\n\n        \nInjectorLookup\n.\ngetInjector\n(\nthis\n).\nget\n()\n\n                \n.\ngetInstance\n(\nSomeService\n.\nclass\n).\ndoSomething\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nTip\n\n\nMost likely, requirement for injector instance means integration with some third party library.\nConsider \nwriting custom installer\n in such cases (it will eliminate need for injector instance).\n\n\n\n\nInside guice context you can simply inject Injector instance:\n\n\n@Inject\n \nInjector\n \ninjector\n;\n\n\n\n\n\nInjector factory\n\u00b6\n\n\nYou can control guice injector creation through \nru.vyarus.dropwizard.guice.injector.InjectorFactory\n. \n\n\nDefault implementation is very simple:\n\n\npublic\n \nclass\n \nDefaultInjectorFactory\n \nimplements\n \nInjectorFactory\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nInjector\n \ncreateInjector\n(\nfinal\n \nStage\n \nstage\n,\n \nfinal\n \nIterable\n<?\n \nextends\n \nModule\n>\n \nmodules\n)\n \n{\n\n        \nreturn\n \nGuice\n.\ncreateInjector\n(\nstage\n,\n \nmodules\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nInjector creation customization may be required by some 3\nrd\n party library.\nFor example, \nnetflix governator\n \nowns injector creation (\nsee example\n).\n\n\nCustom injector factory could be registered in guice bundle builder:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\ninjectorFactory\n(\nnew\n \nCustomInjectorFactory\n())\n\n            \n...",
            "title": "Injector"
        },
        {
            "location": "/guide/injector/#injector-instance",
            "text": "",
            "title": "Injector instance"
        },
        {
            "location": "/guide/injector/#restrictive-options",
            "text": "Guicey itself is compatible with the following guice restrictive options:  public   class   MyModule   extends   AbstractModule   { \n         @Override \n         protected   void   configure ()   { \n             binder (). disableCircularProxies (); \n             binder (). requireExactBindingAnnotations (); \n             binder (). requireExplicitBindings (); \n         } \n     }   So it is safe to enable them.",
            "title": "Restrictive options"
        },
        {
            "location": "/guide/injector/#access-injector",
            "text": "In some cases it may be important to get injector instance outside of guice context.   Warning  Injector is created on dropwizard run phase. Attempt to obtain injector before it\nwill lead to exception.   Injector instance could be resolved with:   getInjector()  method on GuiceBundle instance (NPE will be thrown if injector not initialized)  InjectorLookup.getInjector(app).get()  static call using application instance (lookup returns  Optional  for null safety).   If you need lazy injector reference, you can use  InjectorProvider  class (it's actually  Provider<Injector> ):  Provider < Injector >   provider   =   new   InjectorProvider ( app );  // somewhere after run phase  Injector   injector   =   provider . get ();   When you are inside your application class:  public   class   MyApplication   extends   Application < Configuration >   { \n\n     @Override \n     public   void   run ( TestConfiguration   configuration ,   Environment   environment )   throws   Exception   { \n         InjectorLookup . getInjector ( this ). get () \n                 . getInstance ( SomeService . class ). doSomething (); \n     }  }    Tip  Most likely, requirement for injector instance means integration with some third party library.\nConsider  writing custom installer  in such cases (it will eliminate need for injector instance).   Inside guice context you can simply inject Injector instance:  @Inject   Injector   injector ;",
            "title": "Access injector"
        },
        {
            "location": "/guide/injector/#injector-factory",
            "text": "You can control guice injector creation through  ru.vyarus.dropwizard.guice.injector.InjectorFactory .   Default implementation is very simple:  public   class   DefaultInjectorFactory   implements   InjectorFactory   { \n\n     @Override \n     public   Injector   createInjector ( final   Stage   stage ,   final   Iterable <?   extends   Module >   modules )   { \n         return   Guice . createInjector ( stage ,   modules ); \n     }  }   Injector creation customization may be required by some 3 rd  party library.\nFor example,  netflix governator  \nowns injector creation ( see example ).  Custom injector factory could be registered in guice bundle builder:  bootstrap . addBundle ( GuiceBundle . builder () \n             . injectorFactory ( new   CustomInjectorFactory ()) \n             ...",
            "title": "Injector factory"
        },
        {
            "location": "/guide/module-autowiring/",
            "text": "Module autowiring\n\u00b6\n\n\nBecause guice modules are registered in dropwizard init section only \nBootstrap\n instance is available.\nOften \nEnvironment\n and \nConfiguration\n objects are also required.\n\n\nAutowiring interfaces\n\u00b6\n\n\nGuicey can automatically inject environment objects into your module if \nit implements any of (or all of them): \n\n\n\n\nBootstrapAwareModule\n - access bootstrap instance \n\n\nEnvironmentAwareModule\n - access environment instance \n\n\nConfigurationAwareModule\n - access configuration instance\n\n\nConfigurationTreeAwareModule\n - access to configuration values by path\n\n\nOptionsAwareModule\n - access guicey options\n\n\n\n\nReference object will be set to module just before injector creation, so you can use it inside your \nmodule logic (\nconfiguration\n method).\n\n\n\n\nWarning\n\n\nModule autowiring will only work for modules directly set to \nmodules()\n (of main bundle or any guicey bundle).\n\n\n\n\npublic\n \nclass\n \nMyModule\n \nimplements\n \nEnvironmentAwareModule\n \n{\n\n    \nprivate\n \nEnvironemnt\n \nenvironment\n;\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nsetEnvironment\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nthis\n.\nenvironment\n \n=\n \nenvironment\n;\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \n// use environment here\n\n    \n}\n\n\n}\n\n\n\n\n\nAutowiring base class\n\u00b6\n\n\nTo avoid manually implementing interfaces (avoid boilerplate) you can use \nDropwizardAwareModule\n as \nbase class which already implements all autowiring interfaces:\n\n\npublic\n \nclass\n \nMyModule\n \nextends\n \nDropwizardAwareModule\n<\nMyConfiguration\n>\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nbootstrap\n()\n     \n// Bootstrap instance\n\n        \nenvironment\n()\n   \n// Environment instance\n\n        \nconfiguration\n()\n \n// MyConfiguration instance\n\n        \nappPackage\n()\n    \n// application class package \n\n        \nconfiguratonTree\n()\n \n// configuration as tree of values\n\n        \nconfuguration\n(\nClass\n)\n \n// unique sub configuration\n\n        \nconfiguration\n(\nString\n)\n \n// configuration value by yaml path\n\n        \nconfigurations\n(\nClass\n)\n \n// sub configuration objects by type (including subtypes)\n\n        \noptions\n()\n \n// access guicey options\n\n    \n}\n\n\n}\n \n\n\n\n\nOptions\n\u00b6\n\n\nOptions\n could be used in guice module to access guicey configurations:\n\n\npublic\n \nclass\n \nMyModule\n \nextends\n \nDropwizardAwareModule\n<\nMyConfiguration\n>\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \n// empty when guicey servlet support is dasabled\n\n        \nif\n \n(\noptions\n.<\nEnumSet\n>\nget\n(\nGuiceyOptions\n.\nGuiceFilterRegistration\n).\nisEmtpy\n())\n \n{\n\n            \n// do nothing\n\n        \n}\n \nelse\n \n{\n\n            \n// register servlet module\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nOr it could be some \ncustom options\n usage.\n\n\n\n\nTip\n\n\nIf you are going to register module inside guicey bundle, you can simply resolve\noption value inside guicey bundle and pass it to module directly.\n\n\n\n\nConfiguration access\n\u00b6\n\n\n\n\nTip\n\n\nIf you are going to register module inside guicey bundle, you can simply resolve\nconfiguration object inside guicey bundle and pass it to module directly (bundle has \nabsolutely the same configuration access methods)\n\n\n\n\nUnique feature config\n\u00b6\n\n\nWhen working with re-usable modules, it could be handy to rely on unique configuration \nobject:\n\n\npublic\n \nclass\n \nXFeatureModule\n \nextends\n \nDropwizardAwareModule\n<\nConfiguration\n>\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nXFeatureConfig\n \nconf\n \n=\n \nconfiguration\n(\nXFeatureConfig\n.\nclass\n);\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nNote that this module doesn't known exact type of user configuration, it just \nassumes that XFeatureConfig is declared somewhere in configuration (on any level)\njust once. For example:\n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n\n    \n@JsonProperty\n\n    \nprivate\n \nXFeatureConfig\n \nxfeature\n;\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\nImportant\n\n\nObject uniqueness checked by exact type match, so if configuration also \ncontains some extending class (\nXFeatureConfigExt\n) it will be different unique config. \n\n\n\n\nAccess by path\n\u00b6\n\n\nWhen you are not sure that configuration is unique, you can rely on exact path definition:\n\n\npublic\n \nclass\n \nXFeatureModule\n \nextends\n \nDropwizardAwareModule\n<\nConfiguration\n>\n \n{\n\n\n    \nprivate\n \nString\n \npath\n;\n\n\n    \npublic\n \nXFeatureModule\n(\nString\n \npath\n)\n \n{\n\n        \nthis\n.\npath\n \n=\n \npath\n;\n\n    \n}\n \n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nXFeatureConfig\n \nconf\n \n=\n \nconfiguration\n(\npath\n);\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nPath is declared by module user, who knows required configuration location:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nmodules\n(\nnew\n \nXFeatureModule\n(\n\"sub.feature\"\n))\n\n    \n...\n\n    \n.\nbuild\n()\n\n\n\n\n\nWhere \n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n\n    \n@JsonProperty\n\n    \nprivate\n \nSubConfig\n \nsub\n \n=\n \n{\n \n// pseudo code to combine class declarations\n\n         \n@JsonProperty\n\n         \nprivate\n \nXFeatureConfig\n \nfeature\n;\n   \n    \n}\n\n\n    \n...\n\n\n}\n\n\n\n\n\nMultiple configs\n\u00b6\n\n\nIn case, when multiple config objects could be declared in user configuration,\nyou can access all of them: \n\n\npublic\n \nclass\n \nXFeatureModule\n \nextends\n \nDropwizardAwareModule\n<\nConfiguration\n>\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nList\n<\nXFeatureConfig\n>\n \nconfs\n \n=\n \nconfigurations\n(\nXFeatureConfig\n.\nclass\n);\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nFor configuration\n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n\n    \n@JsonProperty\n\n    \nprivate\n \nXFeatureConfig\n \nxfeature\n;\n\n    \n@JsonProperty\n\n    \nprivate\n \nXFeatureConfig\n \nxfeature2\n;\n\n\n    \n...\n\n\n}\n\n\n\n\n\nIt wil return both objects: \n[xfeature, xfeature2]\n\n\n\n\nImportant\n\n\nIn contrast to unique configurations, this method returns all subclasses too.\nSo if there are \nXFeatureConfigExt\n declared somewhere it will also be returned.\n\n\n\n\nCustom configuration analysis\n\u00b6\n\n\nIn all other cases (with more complex requirements) you can use \nConfigurationTree\n object which\nrepresents introspected configuration paths.  \n\n\npublic\n \nclass\n \nXFeatureModule\n \nextends\n \nDropwizardAwareModule\n<\nConfiguration\n>\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \n// get all properties of custom configuration (ignoring properties from base classes)\n\n        \nList\n<\nConfigPath\n>\n \npaths\n \n=\n \nconfigurationTree\n().\nfindAllRootPathsFrom\n(\nMyConfig\n.\nclass\n);\n\n\n        \nList\n \nmarkedTypes\n \n=\n \npaths\n.\nstream\n()\n\n            \n.\nfilter\n(\nit\n \n->\n \nit\n.\ngetValue\n()\n \n!=\n \nnull\n \n                    \n&&\n \nit\n.\ngetType\n().\ngetValueType\n().\nhasAnnotation\n(\nMyMarker\n.\nclass\n))\n\n            \n.\nmap\n(\nit\n \n->\n \nit\n.\ngetValue\n())\n\n            \n.\ncollect\n(\nCollectors\n.\ntoList\n());\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nIn this example, module search for properties declared directly in MyConfig configuration\nclass with not null value and annotated (classes annotated, not properties!) with custom marker (\n@MyMarker\n).  \n\n\nSee introspected configuration \nstructure description",
            "title": "Module autowiring"
        },
        {
            "location": "/guide/module-autowiring/#module-autowiring",
            "text": "Because guice modules are registered in dropwizard init section only  Bootstrap  instance is available.\nOften  Environment  and  Configuration  objects are also required.",
            "title": "Module autowiring"
        },
        {
            "location": "/guide/module-autowiring/#autowiring-interfaces",
            "text": "Guicey can automatically inject environment objects into your module if \nit implements any of (or all of them):    BootstrapAwareModule  - access bootstrap instance   EnvironmentAwareModule  - access environment instance   ConfigurationAwareModule  - access configuration instance  ConfigurationTreeAwareModule  - access to configuration values by path  OptionsAwareModule  - access guicey options   Reference object will be set to module just before injector creation, so you can use it inside your \nmodule logic ( configuration  method).   Warning  Module autowiring will only work for modules directly set to  modules()  (of main bundle or any guicey bundle).   public   class   MyModule   implements   EnvironmentAwareModule   { \n     private   Environemnt   environment ; \n\n     @Override \n     public   void   setEnvironment ( Environment   environment )   { \n         this . environment   =   environment ; \n     } \n\n     @Override \n     protected   void   configure ()   { \n         // use environment here \n     }  }",
            "title": "Autowiring interfaces"
        },
        {
            "location": "/guide/module-autowiring/#autowiring-base-class",
            "text": "To avoid manually implementing interfaces (avoid boilerplate) you can use  DropwizardAwareModule  as \nbase class which already implements all autowiring interfaces:  public   class   MyModule   extends   DropwizardAwareModule < MyConfiguration >   { \n     @Override \n     protected   void   configure ()   { \n         bootstrap ()       // Bootstrap instance \n         environment ()     // Environment instance \n         configuration ()   // MyConfiguration instance \n         appPackage ()      // application class package  \n         configuratonTree ()   // configuration as tree of values \n         confuguration ( Class )   // unique sub configuration \n         configuration ( String )   // configuration value by yaml path \n         configurations ( Class )   // sub configuration objects by type (including subtypes) \n         options ()   // access guicey options \n     }  }",
            "title": "Autowiring base class"
        },
        {
            "location": "/guide/module-autowiring/#options",
            "text": "Options  could be used in guice module to access guicey configurations:  public   class   MyModule   extends   DropwizardAwareModule < MyConfiguration >   { \n     @Override \n     protected   void   configure ()   { \n         // empty when guicey servlet support is dasabled \n         if   ( options .< EnumSet > get ( GuiceyOptions . GuiceFilterRegistration ). isEmtpy ())   { \n             // do nothing \n         }   else   { \n             // register servlet module \n         } \n     }  }   Or it could be some  custom options  usage.   Tip  If you are going to register module inside guicey bundle, you can simply resolve\noption value inside guicey bundle and pass it to module directly.",
            "title": "Options"
        },
        {
            "location": "/guide/module-autowiring/#configuration-access",
            "text": "Tip  If you are going to register module inside guicey bundle, you can simply resolve\nconfiguration object inside guicey bundle and pass it to module directly (bundle has \nabsolutely the same configuration access methods)",
            "title": "Configuration access"
        },
        {
            "location": "/guide/module-autowiring/#unique-feature-config",
            "text": "When working with re-usable modules, it could be handy to rely on unique configuration \nobject:  public   class   XFeatureModule   extends   DropwizardAwareModule < Configuration >   { \n     @Override \n     protected   void   configure ()   { \n         XFeatureConfig   conf   =   configuration ( XFeatureConfig . class ); \n         ... \n     }  }   Note that this module doesn't known exact type of user configuration, it just \nassumes that XFeatureConfig is declared somewhere in configuration (on any level)\njust once. For example:  public   class   MyConfig   extends   Configuration   { \n\n     @JsonProperty \n     private   XFeatureConfig   xfeature ; \n\n     ...  }    Important  Object uniqueness checked by exact type match, so if configuration also \ncontains some extending class ( XFeatureConfigExt ) it will be different unique config.",
            "title": "Unique feature config"
        },
        {
            "location": "/guide/module-autowiring/#access-by-path",
            "text": "When you are not sure that configuration is unique, you can rely on exact path definition:  public   class   XFeatureModule   extends   DropwizardAwareModule < Configuration >   { \n\n     private   String   path ; \n\n     public   XFeatureModule ( String   path )   { \n         this . path   =   path ; \n     }  \n\n     @Override \n     protected   void   configure ()   { \n         XFeatureConfig   conf   =   configuration ( path ); \n         ... \n     }  }   Path is declared by module user, who knows required configuration location:  GuiceBundle . builder () \n     . modules ( new   XFeatureModule ( \"sub.feature\" )) \n     ... \n     . build ()   Where   public   class   MyConfig   extends   Configuration   { \n\n     @JsonProperty \n     private   SubConfig   sub   =   {   // pseudo code to combine class declarations \n          @JsonProperty \n          private   XFeatureConfig   feature ;    \n     } \n\n     ...  }",
            "title": "Access by path"
        },
        {
            "location": "/guide/module-autowiring/#multiple-configs",
            "text": "In case, when multiple config objects could be declared in user configuration,\nyou can access all of them:   public   class   XFeatureModule   extends   DropwizardAwareModule < Configuration >   { \n     @Override \n     protected   void   configure ()   { \n         List < XFeatureConfig >   confs   =   configurations ( XFeatureConfig . class ); \n         ... \n     }  }   For configuration  public   class   MyConfig   extends   Configuration   { \n\n     @JsonProperty \n     private   XFeatureConfig   xfeature ; \n     @JsonProperty \n     private   XFeatureConfig   xfeature2 ; \n\n     ...  }   It wil return both objects:  [xfeature, xfeature2]   Important  In contrast to unique configurations, this method returns all subclasses too.\nSo if there are  XFeatureConfigExt  declared somewhere it will also be returned.",
            "title": "Multiple configs"
        },
        {
            "location": "/guide/module-autowiring/#custom-configuration-analysis",
            "text": "In all other cases (with more complex requirements) you can use  ConfigurationTree  object which\nrepresents introspected configuration paths.    public   class   XFeatureModule   extends   DropwizardAwareModule < Configuration >   { \n     @Override \n     protected   void   configure ()   { \n         // get all properties of custom configuration (ignoring properties from base classes) \n         List < ConfigPath >   paths   =   configurationTree (). findAllRootPathsFrom ( MyConfig . class ); \n\n         List   markedTypes   =   paths . stream () \n             . filter ( it   ->   it . getValue ()   !=   null  \n                     &&   it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) \n             . map ( it   ->   it . getValue ()) \n             . collect ( Collectors . toList ()); \n         ... \n     }  }   In this example, module search for properties declared directly in MyConfig configuration\nclass with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ).    See introspected configuration  structure description",
            "title": "Custom configuration analysis"
        },
        {
            "location": "/guide/bindings/",
            "text": "Bindings\n\u00b6\n\n\n\n\nNote\n\n\nGuicey is compatible with some \nguice restrictive options\n (like disableCircularProxies)    \n\n\n\n\nRegistered bindings\n\u00b6\n\n\nGuicey binds:\n\n\n\n\nDropwizard objects:\n\n\nio.dropwizard.setup.Bootstrap\n \n\n\nio.dropwizard.Configuration\n \n\n\nio.dropwizard.setup.Environment\n\n\n\n\n\n\nDetailed configuration bindings (by root classes, interfaces, yaml path or unique sub type)\n\n\nAll installed extensions (extensions are explicitly bound to guice, except some specific installers which do manual bindings).\n\n\nJersey objects (including request scoped) \n\n\nGuicey special objects\n\n\n\n\nConfiguration\n\u00b6\n\n\nConfiguration\n bound to guice as: \n\n\n\n\nio.dropwizard.Configuration\n\n\nYour configuration class (\nMyConfiguration\n \nextends\n \nConfiguration\n)\n\n\nAll classes between them\n\n\n\n\nFor example, if\n\n\nMyConfiguration\n \nextends\n \nMyAbstractConfiguration\n \nextends\n \nConfiguration\n\n\n\n\n\nThen \nMyAbstractConfiguration\n will be also bound and following injection will work:\n\n\n@Inject\n \nMyAbstractConfiguration\n \nconf\n\n\n\n\n\n\n\nNote\n\n\nConfiguration object bindings could be declared with or without qualifier \n@Config\n.\nSo \n@Inject @Config MyAbstractConfiguration conf\n will also work. It is suggested to always\nuse qualifier (to get in common with direct value bindings), but it's up to you.\n\n\n\n\nIf root configuration classes implement interfaces then configuration could be bound by interface.\nThis may be used to support common \nHas<Something>\n configuration interfaces convention used to recognize your extension configuration in configuration object.\n\n\npublic\n \ninterface\n \nHasFeatureX\n \n{\n\n    \nFeatureXConfig\n \ngetFetureXConfig\n();\n\n\n}\n\n\n\npublic\n \nclass\n \nMyConfiguration\n \nextends\n \nConfiguration\n \nimplements\n \nHasFeatureXConfig\n \n{...}\n\n\n\npublic\n \nclass\n \nMyBean\n \n{\n\n    \n@Inject\n \n@Config\n \nHasFeatureX\n \nconf\n;\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\nImportant\n\n\nIt is required to use qualifier \n@Config\n for interface binding (to avoid accidental binding clashes).\nThere is a \ndeprecated\n bundle option \n.bindConfigurationInterfaces()\n, which enables direct\ninterfaces bindings without qualifier (feature remains for compatibility, prefer qualified interfaces bindings).\n\n\n\n\nInterface binding will ignore interfaces in \njava.*\n or \ngroovy.*\n packages (to avoid unnecessary bindings).\n\n\n\n\nTip\n\n\nConsider using direct sub configuration object binding (see below) instead of marker interface\nif object uniqueness is guaranteed in user configuration.\n\n\n\n\nConfiguration tree\n\u00b6\n\n\nGuicey introspects configuration instance using jackson serialization api. That means only values\nvisible for jackson serialization will be presented.\n\n\n\n\nNote\n\n\nJackson will see all properties which either have getter and setter or annotated with \n@JsonProperty\n. For example,\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n\n    \nprivate\n \nString\n \none\n \n// visible (getter and setter)\n\n    \n@JsonProperty\n\n    \nprivate\n \nString\n \ntwo\n \n// visible (annotation)\n\n    \nprivate\n \nString\n \nthree\n \n// invisible (no getter)\n\n\n    \npublic\n \nvoid\n \nsetOne\n(\nString\n \none\n)\n \n{\n \n...\n \n}\n\n    \npublic\n \nString\n \ngetOne\n()\n \n{\n \n...\n \n}\n\n\n    \npublic\n \nvoid\n \nsetTwo\n(\nString\n \ntwo\n)\n \n{\n \n...\n \n}\n\n\n    \npublic\n \nvoid\n \nsetThree\n(\nString\n \nthree\n)\n \n{\n \n...\n \n}\n\n\n}\n\n\n\n\n\n\nTree of visible configuration paths could be accessed with bound \n\nru.vyarus.dropwizard.guice.module.yaml.ConfigurationTree\n object.\nIt could be used for config analysis, reporting or something else.\n\n\nFor simple cases, direct configuration value bindings could be used (see below).\n\n\n\n\nTip\n\n\nTo prevent binding of configuration property use \n@JsonIgnore\n on property \ngetter\n\n\nprivate\n \nString\n \nprop\n\n\n\n// dropwizard will set value from yaml\n\n\npublic\n \nvoid\n \nsetProp\n(\nStirng\n \nprop\n)\n \n{\n \n...\n \n}\n\n\n\n// property will not be available as path binding\n\n\n@JsonIgnore\n    \n\npublic\n \nString\n \ngetProp\n()\n \n{\n \n...\n \n}\n\n\n\n\n\n\nUnique sub configuration\n\u00b6\n\n\nIt is quite common to group configuration properties into sub objects like:\n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n    \n@JsonProperty\n \nAuthConfig\n \nauth\n;\n\n    \n@JsonProperty\n \nDbConfig\n \ndb\n;\n\n\n}\n\n\n\n\n\nGuicey detects such unique objects and provides direct bindings for them:\n\n\n@Inject\n \n@Config\n \nAuthConfig\n \nauth\n;\n\n\n@Inject\n \n@Config\n \nDbConfig\n \ndb\n;\n\n\n\n\n\nThis is very useful for re-usable modules, which are not aware of your configuration \nobject structure, but require only one sub configuration object:\n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n    \n@JsonProperty\n \nFeatureXConfig\n \nfeatureX\n;\n\n\n}\n\n\n\n\n\nSomewhere in module service:\n\n\npublic\n \nclass\n \nFeatureXService\n \n{\n\n    \n@Inject\n \n@Config\n \nFeatureXConfig\n \nfeatureX\n;\n \n\n}\n\n\n\n\n\n\n\nImportant\n\n\nSub configuration object uniqueness is checked as direct match, so you may have\n\n@JsonProperty\n \nSubConfig\n \nsub\n\n\n@JsonProperty\n \nSubConfigExt\n \nsubExt\n\n\n\nwhere \nclass SubConfigExt extends SubConfig\n, but still both objects would be considered unique.\nWhereas\n\n@JsonProperty\n \nSubConfig\n \nsub1\n\n\n@JsonProperty\n \nSubConfig\n \nsub2\n\n\n\nwill not.\n\n\n\n\n\n\nTip\n\n\nGuicey bundles and guice modules also could use sub configuration objects directly:\n\nGuiceyBootstrap\n#\nconfiguration\n(\nSubConfig\n.\nclass\n)\n\n\nDropwizardAwareModule\n#\nconfiguration\n(\nSubConfig\n.\nclass\n)\n\n\n\n\n\n\nConfiguration by path\n\u00b6\n\n\nAll visible configuration paths values are directly bindable:\n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n    \nSubConf\n \nsub\n;\n\n\n}\n\n\n\npublic\n \nclass\n \nSubConf\n \n{\n\n    \nString\n \nsmth\n;\n\n    \nList\n<\nString\n>\n \nvalues\n;\n\n\n}\n\n\n\n\n\n@Inject\n \n@Config\n(\n\"sub\"\n)\n \nSubConf\n \nsub\n;\n\n\n@Inject\n \n@Config\n(\n\"sub.smth\"\n)\n \nString\n \nsmth\n;\n\n\n@Inject\n \n@Config\n(\n\"sub.values\"\n)\n \nList\n<\nString\n>\n \nvalues\n;\n\n\n\n\n\n\n\nNote\n\n\nPath bindings are available even for null values. For example, if sub configuration object\nis null, all it's sub paths will still be available (by class declarations). \nThe only exception is conditional mappin like dropwizard \"server\" when available paths\ncould change, depending on configuration (what configuration class will be used)\n\n\n\n\n\n\nNote\n\n\nGenerified types are bound only with generics (with all available type information).\nIf you will have \nSubConf<T> sub\n in config, then it will be bound with correct generic \nSubConfig<String>\n\n(suppose generic T is declared as String).\n\n\n\n\nValue type, declared in configuration class is used for binding, but there are two exceptions.\n\n\nIf declared type is declared as collection (Set, List, Map) implementation then binding will use\nbase collection interface:\n\n\nArrayList\n<\nString\n>\n \nvalue\n\n\n\n@Inject\n \n@Config\n(\n\"value\"\n)\n \nList\n<\nString\n>\n \nvlaue\n;\n\n\n\n\n\nIf, for some (unforgivable) reason, property is declared as Object in configuration,\nthen binding type will depend on value presence:\n\n\n\n\n@Config(\"path\") Object val\n - when value is null\n\n\n@Config(\"path\") ValueType val\n - actual value type, when value is not null       \n\n\n\n\nIt is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard \"server\").\n\n\n\n\nTip\n\n\nYou can declare you own additional bindings using \nConfigurationTree\n (accessible from guice module), \nwhich contains all paths information (including declaration and actual types with generics).\n\n\n\n\nConfiguration bindings report\n\u00b6\n\n\nYou can print all available configuration bindings with values:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n...\n\n    \n.\nprintConfigurationBindings\n()\n\n     \n// or printCustomConfigurationBindings() to avoid dropwizard bindings \n\n    \n.\nbuild\n()\n\n\n\n\n\nWill print:\n\n\nINFO  [2018-06-18 05:55:03,532] ru.vyarus.dropwizard.guice.module.yaml.report.DebugConfigBindings: Available configuration bindings = \n\n    ComplexGenericCase (visible paths)\n    \u2502   \n    \u251c\u2500\u2500 sub: ComplexGenericCase.Sub<String>\n    \u2502   \u2514\u2500\u2500 smth: String = null\n    \u2502   \n    \u251c\u2500\u2500 logging: DefaultLoggingFactory\n    \u2502   \u251c\u2500\u2500 level: String = \"INFO\"\n    \u2502   \u251c\u2500\u2500 loggers: RegularImmutableMap<String, JsonNode> = {}\n    \u2502   \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<ILoggingEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]\n    \u2502   \n    \u251c\u2500\u2500 metrics: MetricsFactory\n    \u2502   \u251c\u2500\u2500 frequency: Duration = 1 minute\n    \u2502   \u2514\u2500\u2500 reporters: RegularImmutableList<ReporterFactory> = []\n    \u2502   \n    \u2514\u2500\u2500 server: DefaultServerFactory\n        \u251c\u2500\u2500 maxThreads: Integer = 1024\n        \u251c\u2500\u2500 minThreads: Integer = 8\n        \u251c\u2500\u2500 maxQueuedRequests: Integer = 1024\n        \u251c\u2500\u2500 idleThreadTimeout: Duration = 1 minute\n        \u251c\u2500\u2500 nofileSoftLimit: Integer = null\n        \u251c\u2500\u2500 nofileHardLimit: Integer = null\n        \u251c\u2500\u2500 gid: Integer = null\n        \u251c\u2500\u2500 uid: Integer = null\n        \u251c\u2500\u2500 user: String = null\n        \u251c\u2500\u2500 group: String = null\n        \u251c\u2500\u2500 umask: String = null\n        \u251c\u2500\u2500 startsAsRoot: Boolean = null\n        \u251c\u2500\u2500 registerDefaultExceptionMappers: Boolean = true\n        \u251c\u2500\u2500 detailedJsonProcessingExceptionMapper: Boolean = false\n        \u251c\u2500\u2500 shutdownGracePeriod: Duration = 30 seconds\n        \u251c\u2500\u2500 allowedMethods: HashSet<String> = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH]\n        \u251c\u2500\u2500 enableThreadNameFilter: Boolean = true\n        \u251c\u2500\u2500 applicationConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b]\n        \u251c\u2500\u2500 adminConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@227a47]\n        \u251c\u2500\u2500 adminMaxThreads: Integer = 64\n        \u251c\u2500\u2500 adminMinThreads: Integer = 1\n        \u251c\u2500\u2500 applicationContextPath: String = \"/\"\n        \u251c\u2500\u2500 adminContextPath: String = \"/\"\n        \u2502   \n        \u251c\u2500\u2500 serverPush: ServerPushFilterFactory\n        \u2502   \u251c\u2500\u2500 enabled: Boolean = false\n        \u2502   \u251c\u2500\u2500 associatePeriod: Duration = 4 seconds\n        \u2502   \u251c\u2500\u2500 maxAssociations: Integer = 16\n        \u2502   \u251c\u2500\u2500 refererHosts: List<String> = null\n        \u2502   \u2514\u2500\u2500 refererPorts: List<Integer> = null\n        \u2502   \n        \u251c\u2500\u2500 rootPath: Optional<String> = Optional.empty\n        \u2502   \n        \u251c\u2500\u2500 requestLog: LogbackAccessRequestLogFactory\n        \u2502   \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<IAccessEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c]\n        \u2502   \n        \u2514\u2500\u2500 gzip: GzipHandlerFactory\n            \u251c\u2500\u2500 enabled: Boolean = true\n            \u251c\u2500\u2500 minimumEntitySize: Size = 256 bytes\n            \u251c\u2500\u2500 bufferSize: Size = 8 kilobytes\n            \u251c\u2500\u2500 excludedUserAgentPatterns: HashSet<String> = []\n            \u251c\u2500\u2500 compressedMimeTypes: Set<String> = null\n            \u251c\u2500\u2500 includedMethods: Set<String> = null\n            \u251c\u2500\u2500 deflateCompressionLevel: Integer = -1\n            \u251c\u2500\u2500 gzipCompatibleInflation: Boolean = true\n            \u2514\u2500\u2500 syncFlush: Boolean = false\n\n\n    Configuration object bindings:\n        @Config ComplexGenericCase\n        @Config Configuration\n\n\n    Unique sub configuration objects bindings:\n\n        ComplexGenericCase.sub\n            @Config ComplexGenericCase.Sub<String> = null\n\n        Configuration.logging\n            @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]}\n\n        Configuration.metrics\n            @Config MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]}\n\n        Configuration.server\n            @Config ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/}\n\n        Configuration.server.gzip\n            @Config GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6\n\n        Configuration.server.requestLog\n            @Config RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571\n\n        Configuration.server.serverPush\n            @Config ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4\n\n\n    Configuration paths bindings:\n\n        ComplexGenericCase:\n            @Config(\"sub\") ComplexGenericCase.Sub<String> = null\n            @Config(\"sub.smth\") String = null\n\n        Configuration:\n            @Config(\"logging\") LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]}\n            @Config(\"logging.appenders\") List<AppenderFactory<ILoggingEvent>> (with actual type SingletonImmutableList<AppenderFactory<ILoggingEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]\n            @Config(\"logging.level\") String = \"INFO\"\n            @Config(\"logging.loggers\") Map<String, JsonNode> (with actual type RegularImmutableMap<String, JsonNode>) = {}\n            @Config(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]}\n            @Config(\"metrics.frequency\") Duration = 1 minute\n            @Config(\"metrics.reporters\") List<ReporterFactory> (with actual type RegularImmutableList<ReporterFactory>) = []\n            @Config(\"server\") ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/}\n            @Config(\"server.adminConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@227a47]\n            @Config(\"server.adminContextPath\") String = \"/\"\n            @Config(\"server.adminMaxThreads\") Integer = 64\n            @Config(\"server.adminMinThreads\") Integer = 1\n            @Config(\"server.allowedMethods\") Set<String> (with actual type HashSet<String>) = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH]\n            @Config(\"server.applicationConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b]\n            @Config(\"server.applicationContextPath\") String = \"/\"\n            @Config(\"server.detailedJsonProcessingExceptionMapper\") Boolean = false\n            @Config(\"server.enableThreadNameFilter\") Boolean = true\n            @Config(\"server.gid\") Integer = null\n            @Config(\"server.group\") String = null\n            @Config(\"server.gzip\") GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6\n            @Config(\"server.gzip.bufferSize\") Size = 8 kilobytes\n            @Config(\"server.gzip.compressedMimeTypes\") Set<String> = null\n            @Config(\"server.gzip.deflateCompressionLevel\") Integer = -1\n            @Config(\"server.gzip.enabled\") Boolean = true\n            @Config(\"server.gzip.excludedUserAgentPatterns\") Set<String> (with actual type HashSet<String>) = []\n            @Config(\"server.gzip.gzipCompatibleInflation\") Boolean = true\n            @Config(\"server.gzip.includedMethods\") Set<String> = null\n            @Config(\"server.gzip.minimumEntitySize\") Size = 256 bytes\n            @Config(\"server.gzip.syncFlush\") Boolean = false\n            @Config(\"server.idleThreadTimeout\") Duration = 1 minute\n            @Config(\"server.maxQueuedRequests\") Integer = 1024\n            @Config(\"server.maxThreads\") Integer = 1024\n            @Config(\"server.minThreads\") Integer = 8\n            @Config(\"server.nofileHardLimit\") Integer = null\n            @Config(\"server.nofileSoftLimit\") Integer = null\n            @Config(\"server.registerDefaultExceptionMappers\") Boolean = true\n            @Config(\"server.requestLog\") RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571\n            @Config(\"server.requestLog.appenders\") List<AppenderFactory<IAccessEvent>> (with actual type SingletonImmutableList<AppenderFactory<IAccessEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c]\n            @Config(\"server.rootPath\") Optional<String> = Optional.empty\n            @Config(\"server.serverPush\") ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4\n            @Config(\"server.serverPush.associatePeriod\") Duration = 4 seconds\n            @Config(\"server.serverPush.enabled\") Boolean = false\n            @Config(\"server.serverPush.maxAssociations\") Integer = 16\n            @Config(\"server.serverPush.refererHosts\") List<String> = null\n            @Config(\"server.serverPush.refererPorts\") List<Integer> = null\n            @Config(\"server.shutdownGracePeriod\") Duration = 30 seconds\n            @Config(\"server.startsAsRoot\") Boolean = null\n            @Config(\"server.uid\") Integer = null\n            @Config(\"server.umask\") String = null\n            @Config(\"server.user\") String = null\n\n\n\n\nIntrospected configuration\n\u00b6\n\n\nConfigurationTree\n object provides access for introspected configuration tree:\n\n\n\n\ngetRootTypes()\n - all classes in configuration hierarchy (including interfaces)\n\n\ngetPaths()\n - all paths (including all steps (\"sub\", \"sub.value\"))\n\n\ngetUniqueTypePaths()\n - paths of unique sub configuration types\n\n\n\n\nEach path item (\nConfigPath\n) contains:\n\n\n\n\nRoot path reference (\"sub.value\" reference \"sub\")\n\n\nChild sub-paths (\"sub\" reference \"sub.value\")\n\n\nDeclaration class (type used in configuration class)\n\n\nValue type (type of actual value; when value null - declaration type (but they still could be different for collections))\n\n\nCurrent path name\n\n\nCurrent path value\n\n\nGenerics for declaration and value types (may be incomplete for value type)\n\n\nCustom type marker: contains sub paths or just looks like sub configuration\n\n\nDeclaration type (class where property was declared - configuration object containing property)\n\n\n\n\nYou can traverse up or down from any path (tree structure).\n\n\nConfigurationTree\n provides basic search methods (more as usage example):\n\n\n\n\nfindByPath(String)\n - search path by case-insensitive match\n\n\nfindAllByType(Class)\n - find all paths with assignable declared value\n\n\nfindAllFrom(Class<? extends Configuration>)\n - find all paths, started in specified configuration class\n\n\nfindAllRootPaths()\n - get all root paths (1\nst\n level paths) \n\n\nfindAllRootPathsFrom(Class<? extends Configuration>)\n - all 1\nst\n level paths of configuration class\n\n\nvalueByPath(String)\n - return path value or null if value null or path not exists\n\n\nvaluesByType(Class)\n - all not null values with assignable type\n\n\nvalueByType(Class)\n - first not null value with assignable type\n\n\nvalueByUniqueDeclaredType(Class)\n - value of unique sub conifguration or null if value is null or config is not unique\n\n\n\n\nPaths are sorted by configuration class (to put custom properties upper) and by path name\n(for predictable paths order).\n\n\nEnvironment binding\n\u00b6\n\n\nDropwizard \nio.dropwizard.setup.Environment\n is bound to guice context.\n\n\nIt is mostly useful to perform additional configurations in guice bean for features not covered with installers. \nFor example:\n\n\npublic\n \nclass\n \nMyBean\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nMyBean\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nenvironment\n.\nlifecycle\n().\naddServerLifecycleListener\n(\nnew\n \nServerLifecycleListener\n \n{\n\n            \npublic\n \nvoid\n \nserverStarted\n(\nServer\n \nserver\n)\n \n{\n\n                \ncallSomeMethod\n();\n\n            \n}\n\n        \n})\n\n    \n}\n\n\n}\n\n\n\n\n\nIt's not the best example, but it illustrates usage (and such things usually helps to quick-test something). \n\n\nSee also \nauthentication configuration example\n.\n\n\nJersey specific bindings\n\u00b6\n\n\nJersey bindings are not immediately available, because HK2 context starts after guice, \nso use \nProvider\n to inject these bindings.\n\n\nThese bindings available after HK2 context start:\n\n\n\n\njavax.ws.rs.core.Application\n\n\njavax.ws.rs.ext.Providers\n\n\norg.glassfish.hk2.api.ServiceLocator\n\n\norg.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider\n\n\n\n\nRequest-scoped bindings:\n\n\n\n\njavax.ws.rs.core.UriInfo\n\n\njavax.ws.rs.container.ResourceInfo\n\n\njavax.ws.rs.core.HttpHeaders\n\n\njavax.ws.rs.core.SecurityContext\n\n\njavax.ws.rs.core.Request\n\n\norg.glassfish.jersey.server.ContainerRequest\n\n\norg.glassfish.jersey.server.internal.process.AsyncContext\n\n\n\n\n\n\nTip\n\n\nRead about jersey bindings implementation in \nlifecycle section\n.\n\n\n\n\nRequest and response\n\u00b6\n\n\nBy default, \nGuiceFilter\n is enabled on both contexts (admin and main). So you can inject\nrequest and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions).\n\n\nIf you disable guice filter with \n.noGuiceFilter()\n then\nguicey will bridge objects from HK2 context:\n\n\n\n\njavax.servlet.http.HttpServletRequest\n\n\njavax.servlet.http.HttpServletResponse\n\n\n\n\n\n\nThis means you can still inject them, but request and response will\nonly be available under resource calls (the only part managed by jersey).\n\n\n\n\nExample usage:\n\n\n@Inject\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;\n\n\n\n\n\n\n\nNote\n\n\nPay attention, that in guice-managed resources \n@Context\n field bindings \n\nmust be replaced with providers\n.\n\n\n\n\nOptions\n\u00b6\n\n\nru.vyarus.dropwizard.guice.module.context.option.Options\n binding provides access to \nguicey options\n:\n\n@Inject\n \nOptions\n \noptions\n;\n\n\n\n\nExample usage:\n\n\nPreconditions\n.\ncheckState\n(\noptions\n.\nget\n(\nGuiceyOptions\n.\nUseHkBridge\n),\n \n                                 \n\"HK2 guice bridge is required!\"\n)\n\n\n\n\n\nGuicey configuration\n\u00b6\n\n\nru.vyarus.dropwizard.guice.module.GuiceyConfigurationInfo\n binding provides access\nto \nguicey configuration details\n:\n\n\n@Inject\n \nGuiceyConfigurationInfo\n \ninfo\n\n\n\n\n\nBinding scope\n\u00b6\n\n\nAs you know, guice assume prototype scope by default (when no scope annotation declared).\n\n\nGuice scope annotations:\n\n\n\n\n@Singleton\n - single instance per context\n\n\n@RequestScoped\n - object per request (if guice filter support is \nnot disabled\n\n\n@Prototype\n - prototype scope annotation (useful for jersey services to override force singleton scope)\n\n\n\n\nJersey extensions (\nresources\n, \nproviders\n) \nforce\nsingleton scope\n for extensions without explicit binding annotation (but this could be disabled with \n\nan option\n).\nUse explicit scope annotations where singletons are not required.\n\n\nRequest scope transition\n\u00b6\n\n\n\n\nThis is guice feature, it is just mentioned here.\n\n\n\n\nGuice could access request scoped bindings only in current thread. If you need to access \nrequest scoped binding in different thread, you need to transfer request scope into that thread:\n\n\n@Singleton\n \n\npublic\n \nclass\n \nRequestBean\n \n{\n\n\n    \n// provider will not work in other thread because of request scope\n\n    \n@Inject\n\n    \nProvider\n<\nUriInfo\n>\n \nuri\n;\n\n\n    \npublic\n \nvoid\n \ndoSomethingInRequestScope\n()\n \n{\n\n            \n// wrap logic that require request scope \n\n            \nCallable\n<\nString\n>\n \naction\n \n=\n \nServletScopes\n.\ntransferRequest\n(()\n \n->\n \n{\n\n                \n// access request scoped binding in different thread \n\n                \nreturn\n \nuri\n.\nget\n().\ngetQueryParameters\n().\ngetFirst\n(\n\"q\"\n);\n\n            \n});\n            \n            \nCompletableFuture\n.\nrunAsync\n(()\n \n->\n \n{\n\n                \ntry\n \n{\n\n                    \n// execute action in different thread\n\n                    \naction\n.\ncall\n();\n\n                \n}\n \ncatch\n \n(\nException\n \ne\n)\n \n{\n\n                    \ne\n.\nprintStackTrace\n();\n\n                \n}\n\n            \n});\n\n    \n}\n\n\n}\n            \n\n\n\n\nExtensions initialisation\n\u00b6\n\n\nAll guicey extensions are bound to guice context (\n.bind(ExtType)\n, to be compatible with \n.requireExplicitBindings()\n strict option) \nthat means that all singleton scoped extensions will be initialized in time of injector creation\n(because by default, \nStage.PRODCUTION\n used).\n\n\n\n\nTip\n\n\nYou can change guice injector stage to \nStage.DEVELOPMENT\n in the \nmain bundle\n\nto avoid singletons initialization during context creation (only \n.asEagerSingleton()\n)\nbindings will be initialized). But don't do it without a \nreally good reason\n\n(for example, legacy codebase required development stage).        \n\n\n\n\nAlso, you can avoid extension binding by annotating it with \n@LazyBinding\n: this \nway extension will not be bound to guice context and so will initialize only\non first usage (obtaining from context).\n\n\nHK2 scope\n\u00b6\n\n\nBy default, all jersey extensions (resources, providers) are managed by guice. But you can switch it to be managed by HK2 by default\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n...\n\n   \n.\nuseHK2ForJerseyExtensions\n()\n\n   \n.\nbuild\n()\n \n\n\n\n\n\n\nWarning\n\n\nYou will not be able to use guice AOP on HK2 managed beans. \n\n\n\n\nDepending on default mode selected, you can use annotations to change extension DI:\n\n\n\n\n@HK2Managed\n - extension managed by HK2 (useful in default mode when all beans created by guice)\n\n\n@GuiceManaged\n - extension managed by guice (default, useful only when \n.useHK2ForJerseyExtensions()\n enabled)\n\n\n\n\nBindings override\n\u00b6\n\n\nGuicey provides direct support for \noverriding bindings\n\nand even \noverride overridden bindings in tests\n.",
            "title": "Bindings"
        },
        {
            "location": "/guide/bindings/#bindings",
            "text": "Note  Guicey is compatible with some  guice restrictive options  (like disableCircularProxies)",
            "title": "Bindings"
        },
        {
            "location": "/guide/bindings/#registered-bindings",
            "text": "Guicey binds:   Dropwizard objects:  io.dropwizard.setup.Bootstrap    io.dropwizard.Configuration    io.dropwizard.setup.Environment    Detailed configuration bindings (by root classes, interfaces, yaml path or unique sub type)  All installed extensions (extensions are explicitly bound to guice, except some specific installers which do manual bindings).  Jersey objects (including request scoped)   Guicey special objects",
            "title": "Registered bindings"
        },
        {
            "location": "/guide/bindings/#configuration",
            "text": "Configuration  bound to guice as:    io.dropwizard.Configuration  Your configuration class ( MyConfiguration   extends   Configuration )  All classes between them   For example, if  MyConfiguration   extends   MyAbstractConfiguration   extends   Configuration   Then  MyAbstractConfiguration  will be also bound and following injection will work:  @Inject   MyAbstractConfiguration   conf    Note  Configuration object bindings could be declared with or without qualifier  @Config .\nSo  @Inject @Config MyAbstractConfiguration conf  will also work. It is suggested to always\nuse qualifier (to get in common with direct value bindings), but it's up to you.   If root configuration classes implement interfaces then configuration could be bound by interface.\nThis may be used to support common  Has<Something>  configuration interfaces convention used to recognize your extension configuration in configuration object.  public   interface   HasFeatureX   { \n     FeatureXConfig   getFetureXConfig ();  }  public   class   MyConfiguration   extends   Configuration   implements   HasFeatureXConfig   {...}  public   class   MyBean   { \n     @Inject   @Config   HasFeatureX   conf ; \n     ...  }    Important  It is required to use qualifier  @Config  for interface binding (to avoid accidental binding clashes).\nThere is a  deprecated  bundle option  .bindConfigurationInterfaces() , which enables direct\ninterfaces bindings without qualifier (feature remains for compatibility, prefer qualified interfaces bindings).   Interface binding will ignore interfaces in  java.*  or  groovy.*  packages (to avoid unnecessary bindings).   Tip  Consider using direct sub configuration object binding (see below) instead of marker interface\nif object uniqueness is guaranteed in user configuration.",
            "title": "Configuration"
        },
        {
            "location": "/guide/bindings/#configuration-tree",
            "text": "Guicey introspects configuration instance using jackson serialization api. That means only values\nvisible for jackson serialization will be presented.   Note  Jackson will see all properties which either have getter and setter or annotated with  @JsonProperty . For example, public   class   MyConfig   extends   Configuration   { \n\n     private   String   one   // visible (getter and setter) \n     @JsonProperty \n     private   String   two   // visible (annotation) \n     private   String   three   // invisible (no getter) \n\n     public   void   setOne ( String   one )   {   ...   } \n     public   String   getOne ()   {   ...   } \n\n     public   void   setTwo ( String   two )   {   ...   } \n\n     public   void   setThree ( String   three )   {   ...   }  }    Tree of visible configuration paths could be accessed with bound  ru.vyarus.dropwizard.guice.module.yaml.ConfigurationTree  object.\nIt could be used for config analysis, reporting or something else.  For simple cases, direct configuration value bindings could be used (see below).   Tip  To prevent binding of configuration property use  @JsonIgnore  on property  getter  private   String   prop  // dropwizard will set value from yaml  public   void   setProp ( Stirng   prop )   {   ...   }  // property will not be available as path binding  @JsonIgnore      public   String   getProp ()   {   ...   }",
            "title": "Configuration tree"
        },
        {
            "location": "/guide/bindings/#unique-sub-configuration",
            "text": "It is quite common to group configuration properties into sub objects like:  public   class   MyConfig   extends   Configuration   { \n     @JsonProperty   AuthConfig   auth ; \n     @JsonProperty   DbConfig   db ;  }   Guicey detects such unique objects and provides direct bindings for them:  @Inject   @Config   AuthConfig   auth ;  @Inject   @Config   DbConfig   db ;   This is very useful for re-usable modules, which are not aware of your configuration \nobject structure, but require only one sub configuration object:  public   class   MyConfig   extends   Configuration   { \n     @JsonProperty   FeatureXConfig   featureX ;  }   Somewhere in module service:  public   class   FeatureXService   { \n     @Inject   @Config   FeatureXConfig   featureX ;   }    Important  Sub configuration object uniqueness is checked as direct match, so you may have @JsonProperty   SubConfig   sub  @JsonProperty   SubConfigExt   subExt  \nwhere  class SubConfigExt extends SubConfig , but still both objects would be considered unique.\nWhereas @JsonProperty   SubConfig   sub1  @JsonProperty   SubConfig   sub2  \nwill not.    Tip  Guicey bundles and guice modules also could use sub configuration objects directly: GuiceyBootstrap # configuration ( SubConfig . class )  DropwizardAwareModule # configuration ( SubConfig . class )",
            "title": "Unique sub configuration"
        },
        {
            "location": "/guide/bindings/#configuration-by-path",
            "text": "All visible configuration paths values are directly bindable:  public   class   MyConfig   extends   Configuration   { \n     SubConf   sub ;  }  public   class   SubConf   { \n     String   smth ; \n     List < String >   values ;  }   @Inject   @Config ( \"sub\" )   SubConf   sub ;  @Inject   @Config ( \"sub.smth\" )   String   smth ;  @Inject   @Config ( \"sub.values\" )   List < String >   values ;    Note  Path bindings are available even for null values. For example, if sub configuration object\nis null, all it's sub paths will still be available (by class declarations). \nThe only exception is conditional mappin like dropwizard \"server\" when available paths\ncould change, depending on configuration (what configuration class will be used)    Note  Generified types are bound only with generics (with all available type information).\nIf you will have  SubConf<T> sub  in config, then it will be bound with correct generic  SubConfig<String> \n(suppose generic T is declared as String).   Value type, declared in configuration class is used for binding, but there are two exceptions.  If declared type is declared as collection (Set, List, Map) implementation then binding will use\nbase collection interface:  ArrayList < String >   value  @Inject   @Config ( \"value\" )   List < String >   vlaue ;   If, for some (unforgivable) reason, property is declared as Object in configuration,\nthen binding type will depend on value presence:   @Config(\"path\") Object val  - when value is null  @Config(\"path\") ValueType val  - actual value type, when value is not null          It is assumed that in such case value would be always present (some sort of property-selected binding, like dropwizard \"server\").   Tip  You can declare you own additional bindings using  ConfigurationTree  (accessible from guice module), \nwhich contains all paths information (including declaration and actual types with generics).",
            "title": "Configuration by path"
        },
        {
            "location": "/guide/bindings/#configuration-bindings-report",
            "text": "You can print all available configuration bindings with values:  GuiceBundle . builder () \n     ... \n     . printConfigurationBindings () \n      // or printCustomConfigurationBindings() to avoid dropwizard bindings  \n     . build ()   Will print:  INFO  [2018-06-18 05:55:03,532] ru.vyarus.dropwizard.guice.module.yaml.report.DebugConfigBindings: Available configuration bindings = \n\n    ComplexGenericCase (visible paths)\n    \u2502   \n    \u251c\u2500\u2500 sub: ComplexGenericCase.Sub<String>\n    \u2502   \u2514\u2500\u2500 smth: String = null\n    \u2502   \n    \u251c\u2500\u2500 logging: DefaultLoggingFactory\n    \u2502   \u251c\u2500\u2500 level: String = \"INFO\"\n    \u2502   \u251c\u2500\u2500 loggers: RegularImmutableMap<String, JsonNode> = {}\n    \u2502   \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<ILoggingEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]\n    \u2502   \n    \u251c\u2500\u2500 metrics: MetricsFactory\n    \u2502   \u251c\u2500\u2500 frequency: Duration = 1 minute\n    \u2502   \u2514\u2500\u2500 reporters: RegularImmutableList<ReporterFactory> = []\n    \u2502   \n    \u2514\u2500\u2500 server: DefaultServerFactory\n        \u251c\u2500\u2500 maxThreads: Integer = 1024\n        \u251c\u2500\u2500 minThreads: Integer = 8\n        \u251c\u2500\u2500 maxQueuedRequests: Integer = 1024\n        \u251c\u2500\u2500 idleThreadTimeout: Duration = 1 minute\n        \u251c\u2500\u2500 nofileSoftLimit: Integer = null\n        \u251c\u2500\u2500 nofileHardLimit: Integer = null\n        \u251c\u2500\u2500 gid: Integer = null\n        \u251c\u2500\u2500 uid: Integer = null\n        \u251c\u2500\u2500 user: String = null\n        \u251c\u2500\u2500 group: String = null\n        \u251c\u2500\u2500 umask: String = null\n        \u251c\u2500\u2500 startsAsRoot: Boolean = null\n        \u251c\u2500\u2500 registerDefaultExceptionMappers: Boolean = true\n        \u251c\u2500\u2500 detailedJsonProcessingExceptionMapper: Boolean = false\n        \u251c\u2500\u2500 shutdownGracePeriod: Duration = 30 seconds\n        \u251c\u2500\u2500 allowedMethods: HashSet<String> = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH]\n        \u251c\u2500\u2500 enableThreadNameFilter: Boolean = true\n        \u251c\u2500\u2500 applicationConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b]\n        \u251c\u2500\u2500 adminConnectors: ArrayList<ConnectorFactory> = [io.dropwizard.jetty.HttpConnectorFactory@227a47]\n        \u251c\u2500\u2500 adminMaxThreads: Integer = 64\n        \u251c\u2500\u2500 adminMinThreads: Integer = 1\n        \u251c\u2500\u2500 applicationContextPath: String = \"/\"\n        \u251c\u2500\u2500 adminContextPath: String = \"/\"\n        \u2502   \n        \u251c\u2500\u2500 serverPush: ServerPushFilterFactory\n        \u2502   \u251c\u2500\u2500 enabled: Boolean = false\n        \u2502   \u251c\u2500\u2500 associatePeriod: Duration = 4 seconds\n        \u2502   \u251c\u2500\u2500 maxAssociations: Integer = 16\n        \u2502   \u251c\u2500\u2500 refererHosts: List<String> = null\n        \u2502   \u2514\u2500\u2500 refererPorts: List<Integer> = null\n        \u2502   \n        \u251c\u2500\u2500 rootPath: Optional<String> = Optional.empty\n        \u2502   \n        \u251c\u2500\u2500 requestLog: LogbackAccessRequestLogFactory\n        \u2502   \u2514\u2500\u2500 appenders: SingletonImmutableList<AppenderFactory<IAccessEvent>> = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c]\n        \u2502   \n        \u2514\u2500\u2500 gzip: GzipHandlerFactory\n            \u251c\u2500\u2500 enabled: Boolean = true\n            \u251c\u2500\u2500 minimumEntitySize: Size = 256 bytes\n            \u251c\u2500\u2500 bufferSize: Size = 8 kilobytes\n            \u251c\u2500\u2500 excludedUserAgentPatterns: HashSet<String> = []\n            \u251c\u2500\u2500 compressedMimeTypes: Set<String> = null\n            \u251c\u2500\u2500 includedMethods: Set<String> = null\n            \u251c\u2500\u2500 deflateCompressionLevel: Integer = -1\n            \u251c\u2500\u2500 gzipCompatibleInflation: Boolean = true\n            \u2514\u2500\u2500 syncFlush: Boolean = false\n\n\n    Configuration object bindings:\n        @Config ComplexGenericCase\n        @Config Configuration\n\n\n    Unique sub configuration objects bindings:\n\n        ComplexGenericCase.sub\n            @Config ComplexGenericCase.Sub<String> = null\n\n        Configuration.logging\n            @Config LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]}\n\n        Configuration.metrics\n            @Config MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]}\n\n        Configuration.server\n            @Config ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/}\n\n        Configuration.server.gzip\n            @Config GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6\n\n        Configuration.server.requestLog\n            @Config RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571\n\n        Configuration.server.serverPush\n            @Config ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4\n\n\n    Configuration paths bindings:\n\n        ComplexGenericCase:\n            @Config(\"sub\") ComplexGenericCase.Sub<String> = null\n            @Config(\"sub.smth\") String = null\n\n        Configuration:\n            @Config(\"logging\") LoggingFactory (with actual type DefaultLoggingFactory) = DefaultLoggingFactory{level=INFO, loggers={}, appenders=[io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]}\n            @Config(\"logging.appenders\") List<AppenderFactory<ILoggingEvent>> (with actual type SingletonImmutableList<AppenderFactory<ILoggingEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@1b7332a7]\n            @Config(\"logging.level\") String = \"INFO\"\n            @Config(\"logging.loggers\") Map<String, JsonNode> (with actual type RegularImmutableMap<String, JsonNode>) = {}\n            @Config(\"metrics\") MetricsFactory = MetricsFactory{frequency=1 minute, reporters=[]}\n            @Config(\"metrics.frequency\") Duration = 1 minute\n            @Config(\"metrics.reporters\") List<ReporterFactory> (with actual type RegularImmutableList<ReporterFactory>) = []\n            @Config(\"server\") ServerFactory (with actual type DefaultServerFactory) = DefaultServerFactory{applicationConnectors=[io.dropwizard.jetty.HttpConnectorFactory@33063f5b], adminConnectors=[io.dropwizard.jetty.HttpConnectorFactory@227a47], adminMaxThreads=64, adminMinThreads=1, applicationContextPath=/, adminContextPath=/}\n            @Config(\"server.adminConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@227a47]\n            @Config(\"server.adminContextPath\") String = \"/\"\n            @Config(\"server.adminMaxThreads\") Integer = 64\n            @Config(\"server.adminMinThreads\") Integer = 1\n            @Config(\"server.allowedMethods\") Set<String> (with actual type HashSet<String>) = [HEAD, DELETE, POST, GET, OPTIONS, PUT, PATCH]\n            @Config(\"server.applicationConnectors\") List<ConnectorFactory> (with actual type ArrayList<ConnectorFactory>) = [io.dropwizard.jetty.HttpConnectorFactory@33063f5b]\n            @Config(\"server.applicationContextPath\") String = \"/\"\n            @Config(\"server.detailedJsonProcessingExceptionMapper\") Boolean = false\n            @Config(\"server.enableThreadNameFilter\") Boolean = true\n            @Config(\"server.gid\") Integer = null\n            @Config(\"server.group\") String = null\n            @Config(\"server.gzip\") GzipHandlerFactory = io.dropwizard.jetty.GzipHandlerFactory@15405bd6\n            @Config(\"server.gzip.bufferSize\") Size = 8 kilobytes\n            @Config(\"server.gzip.compressedMimeTypes\") Set<String> = null\n            @Config(\"server.gzip.deflateCompressionLevel\") Integer = -1\n            @Config(\"server.gzip.enabled\") Boolean = true\n            @Config(\"server.gzip.excludedUserAgentPatterns\") Set<String> (with actual type HashSet<String>) = []\n            @Config(\"server.gzip.gzipCompatibleInflation\") Boolean = true\n            @Config(\"server.gzip.includedMethods\") Set<String> = null\n            @Config(\"server.gzip.minimumEntitySize\") Size = 256 bytes\n            @Config(\"server.gzip.syncFlush\") Boolean = false\n            @Config(\"server.idleThreadTimeout\") Duration = 1 minute\n            @Config(\"server.maxQueuedRequests\") Integer = 1024\n            @Config(\"server.maxThreads\") Integer = 1024\n            @Config(\"server.minThreads\") Integer = 8\n            @Config(\"server.nofileHardLimit\") Integer = null\n            @Config(\"server.nofileSoftLimit\") Integer = null\n            @Config(\"server.registerDefaultExceptionMappers\") Boolean = true\n            @Config(\"server.requestLog\") RequestLogFactory<RequestLog> (with actual type LogbackAccessRequestLogFactory) = io.dropwizard.request.logging.LogbackAccessRequestLogFactory@6de30571\n            @Config(\"server.requestLog.appenders\") List<AppenderFactory<IAccessEvent>> (with actual type SingletonImmutableList<AppenderFactory<IAccessEvent>>) = [io.dropwizard.logging.ConsoleAppenderFactory@58a2b4c]\n            @Config(\"server.rootPath\") Optional<String> = Optional.empty\n            @Config(\"server.serverPush\") ServerPushFilterFactory = io.dropwizard.jetty.ServerPushFilterFactory@3240b2a4\n            @Config(\"server.serverPush.associatePeriod\") Duration = 4 seconds\n            @Config(\"server.serverPush.enabled\") Boolean = false\n            @Config(\"server.serverPush.maxAssociations\") Integer = 16\n            @Config(\"server.serverPush.refererHosts\") List<String> = null\n            @Config(\"server.serverPush.refererPorts\") List<Integer> = null\n            @Config(\"server.shutdownGracePeriod\") Duration = 30 seconds\n            @Config(\"server.startsAsRoot\") Boolean = null\n            @Config(\"server.uid\") Integer = null\n            @Config(\"server.umask\") String = null\n            @Config(\"server.user\") String = null",
            "title": "Configuration bindings report"
        },
        {
            "location": "/guide/bindings/#introspected-configuration",
            "text": "ConfigurationTree  object provides access for introspected configuration tree:   getRootTypes()  - all classes in configuration hierarchy (including interfaces)  getPaths()  - all paths (including all steps (\"sub\", \"sub.value\"))  getUniqueTypePaths()  - paths of unique sub configuration types   Each path item ( ConfigPath ) contains:   Root path reference (\"sub.value\" reference \"sub\")  Child sub-paths (\"sub\" reference \"sub.value\")  Declaration class (type used in configuration class)  Value type (type of actual value; when value null - declaration type (but they still could be different for collections))  Current path name  Current path value  Generics for declaration and value types (may be incomplete for value type)  Custom type marker: contains sub paths or just looks like sub configuration  Declaration type (class where property was declared - configuration object containing property)   You can traverse up or down from any path (tree structure).  ConfigurationTree  provides basic search methods (more as usage example):   findByPath(String)  - search path by case-insensitive match  findAllByType(Class)  - find all paths with assignable declared value  findAllFrom(Class<? extends Configuration>)  - find all paths, started in specified configuration class  findAllRootPaths()  - get all root paths (1 st  level paths)   findAllRootPathsFrom(Class<? extends Configuration>)  - all 1 st  level paths of configuration class  valueByPath(String)  - return path value or null if value null or path not exists  valuesByType(Class)  - all not null values with assignable type  valueByType(Class)  - first not null value with assignable type  valueByUniqueDeclaredType(Class)  - value of unique sub conifguration or null if value is null or config is not unique   Paths are sorted by configuration class (to put custom properties upper) and by path name\n(for predictable paths order).",
            "title": "Introspected configuration"
        },
        {
            "location": "/guide/bindings/#environment-binding",
            "text": "Dropwizard  io.dropwizard.setup.Environment  is bound to guice context.  It is mostly useful to perform additional configurations in guice bean for features not covered with installers. \nFor example:  public   class   MyBean   { \n\n     @Inject \n     public   MyBean ( Environment   environment )   { \n         environment . lifecycle (). addServerLifecycleListener ( new   ServerLifecycleListener   { \n             public   void   serverStarted ( Server   server )   { \n                 callSomeMethod (); \n             } \n         }) \n     }  }   It's not the best example, but it illustrates usage (and such things usually helps to quick-test something).   See also  authentication configuration example .",
            "title": "Environment binding"
        },
        {
            "location": "/guide/bindings/#jersey-specific-bindings",
            "text": "Jersey bindings are not immediately available, because HK2 context starts after guice, \nso use  Provider  to inject these bindings.  These bindings available after HK2 context start:   javax.ws.rs.core.Application  javax.ws.rs.ext.Providers  org.glassfish.hk2.api.ServiceLocator  org.glassfish.jersey.server.internal.inject.MultivaluedParameterExtractorProvider   Request-scoped bindings:   javax.ws.rs.core.UriInfo  javax.ws.rs.container.ResourceInfo  javax.ws.rs.core.HttpHeaders  javax.ws.rs.core.SecurityContext  javax.ws.rs.core.Request  org.glassfish.jersey.server.ContainerRequest  org.glassfish.jersey.server.internal.process.AsyncContext    Tip  Read about jersey bindings implementation in  lifecycle section .",
            "title": "Jersey specific bindings"
        },
        {
            "location": "/guide/bindings/#request-and-response",
            "text": "By default,  GuiceFilter  is enabled on both contexts (admin and main). So you can inject\nrequest and response objects and use under filter, servlet or resources calls (guice filter wraps all web interactions).  If you disable guice filter with  .noGuiceFilter()  then\nguicey will bridge objects from HK2 context:   javax.servlet.http.HttpServletRequest  javax.servlet.http.HttpServletResponse    This means you can still inject them, but request and response will\nonly be available under resource calls (the only part managed by jersey).   Example usage:  @Inject   Provider < HttpServletRequest >   requestProvider ;    Note  Pay attention, that in guice-managed resources  @Context  field bindings  must be replaced with providers .",
            "title": "Request and response"
        },
        {
            "location": "/guide/bindings/#options",
            "text": "ru.vyarus.dropwizard.guice.module.context.option.Options  binding provides access to  guicey options : @Inject   Options   options ;   Example usage:  Preconditions . checkState ( options . get ( GuiceyOptions . UseHkBridge ),  \n                                  \"HK2 guice bridge is required!\" )",
            "title": "Options"
        },
        {
            "location": "/guide/bindings/#guicey-configuration",
            "text": "ru.vyarus.dropwizard.guice.module.GuiceyConfigurationInfo  binding provides access\nto  guicey configuration details :  @Inject   GuiceyConfigurationInfo   info",
            "title": "Guicey configuration"
        },
        {
            "location": "/guide/bindings/#binding-scope",
            "text": "As you know, guice assume prototype scope by default (when no scope annotation declared).  Guice scope annotations:   @Singleton  - single instance per context  @RequestScoped  - object per request (if guice filter support is  not disabled  @Prototype  - prototype scope annotation (useful for jersey services to override force singleton scope)   Jersey extensions ( resources ,  providers )  force\nsingleton scope  for extensions without explicit binding annotation (but this could be disabled with  an option ).\nUse explicit scope annotations where singletons are not required.",
            "title": "Binding scope"
        },
        {
            "location": "/guide/bindings/#request-scope-transition",
            "text": "This is guice feature, it is just mentioned here.   Guice could access request scoped bindings only in current thread. If you need to access \nrequest scoped binding in different thread, you need to transfer request scope into that thread:  @Singleton   public   class   RequestBean   { \n\n     // provider will not work in other thread because of request scope \n     @Inject \n     Provider < UriInfo >   uri ; \n\n     public   void   doSomethingInRequestScope ()   { \n             // wrap logic that require request scope  \n             Callable < String >   action   =   ServletScopes . transferRequest (()   ->   { \n                 // access request scoped binding in different thread  \n                 return   uri . get (). getQueryParameters (). getFirst ( \"q\" ); \n             });             \n             CompletableFuture . runAsync (()   ->   { \n                 try   { \n                     // execute action in different thread \n                     action . call (); \n                 }   catch   ( Exception   e )   { \n                     e . printStackTrace (); \n                 } \n             }); \n     }  }",
            "title": "Request scope transition"
        },
        {
            "location": "/guide/bindings/#extensions-initialisation",
            "text": "All guicey extensions are bound to guice context ( .bind(ExtType) , to be compatible with  .requireExplicitBindings()  strict option) \nthat means that all singleton scoped extensions will be initialized in time of injector creation\n(because by default,  Stage.PRODCUTION  used).   Tip  You can change guice injector stage to  Stage.DEVELOPMENT  in the  main bundle \nto avoid singletons initialization during context creation (only  .asEagerSingleton() )\nbindings will be initialized). But don't do it without a  really good reason \n(for example, legacy codebase required development stage).           Also, you can avoid extension binding by annotating it with  @LazyBinding : this \nway extension will not be bound to guice context and so will initialize only\non first usage (obtaining from context).",
            "title": "Extensions initialisation"
        },
        {
            "location": "/guide/bindings/#hk2-scope",
            "text": "By default, all jersey extensions (resources, providers) are managed by guice. But you can switch it to be managed by HK2 by default  GuiceBundle . builder () \n     ... \n    . useHK2ForJerseyExtensions () \n    . build ()     Warning  You will not be able to use guice AOP on HK2 managed beans.    Depending on default mode selected, you can use annotations to change extension DI:   @HK2Managed  - extension managed by HK2 (useful in default mode when all beans created by guice)  @GuiceManaged  - extension managed by guice (default, useful only when  .useHK2ForJerseyExtensions()  enabled)",
            "title": "HK2 scope"
        },
        {
            "location": "/guide/bindings/#bindings-override",
            "text": "Guicey provides direct support for  overriding bindings \nand even  override overridden bindings in tests .",
            "title": "Bindings override"
        },
        {
            "location": "/guide/scan/",
            "text": "Classpath scan\n\u00b6\n\n\n\n\nSummary\n\n\nUse scan only for application package. When part of application extracted to it's own library (usually already mature part) \ncreate \nguicey bundle\n for it with explicit extensions definition. Use \nmanual bundles installation\n \nor \nbundle lookup mechanism\n to install custom bundles.\n\n\n\n\nConfiguration\n\u00b6\n\n\nClasspath scanning is activated by specifying package to scan in bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nenableAutoConfig\n(\n\"package.to.scan\"\n)\n\n\n\n\n\nOr multiple packages:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nenableAutoConfig\n(\n\"com.mycompany.pkg1\"\n,\n \n\"com.mycompany.pkg2\"\n)\n\n\n\n\n\nHow it works\n\u00b6\n\n\nWhen auto scan enabled:\n\n\n\n\nExtension installers are searched in classpath (classes implementing \nFeatureInstaller\n).\n\n\nExtensions are searched using registered installers (\nFeatureInstaller#matches\n method).\n\n\nIf commands search is enabled (\n.searchCommands()\n), performs search for all classes extending \nCommand\n and \ninstall them into\nbootstrap\n.\n\n\n\n\nClasses are searched in specified packages and all their subpackages.\nAbstract classes are ignored. \n\n\nInner static classes are also resolved:\n\n\npublic\n \nabstract\n \nclass\n \nAbstractExceptionMapper\n<\nT\n \nextends\n \nException\n>\n \nimplements\n \nExceptionMapper\n<\nT\n>\n \n{\n\n\n    \n@Provider\n\n    \npublic\n \nstatic\n \nclass\n \nFooExceptionMapper\n \nextends\n \nAbstractExceptionMapper\n<\nIOException\n>\n \n{\n \n...\n \n}\n\n\n    \n@Provider\n\n    \npublic\n \nstatic\n \nclass\n \nBarExceptionMapper\n \nextends\n \nAbstractExceptionMapper\n<\nServletException\n>\n \n{\n \n...\n \n}\n\n\n}\n\n\n\n\n\nFooExceptionMapper\n and \nBarExceptionMapper\n would be detected and installed.\n\n\nHide class from scan\n\u00b6\n\n\n@InvisibleForScanner\n annotation hides class from scanner (for example, to install it manually or to avoid installation at all)\n\n\n@Provider\n\n\n@InvisibleForScanner\n\n\npublic\n \nstatic\n \nclass\n \nFooExceptionMapper\n \nextends\n \nAbstractExceptionMapper\n<\nIOException\n>\n \n{\n \n...\n \n}\n\n\n\n\n\nIn this case \nFooExceptionMapper\n will be ignored by classpath scanner. But you still can install extension manually.\n\n\n\n\nTip\n\n\nIf you can't use annotation on extension for some reson, you can simply \ndisable extension\n \n\n\n\n\nMotivation\n\u00b6\n\n\nUsually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case). \n\n\nClasspath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like \nreflections\n, \n\nfast scanner\n or even jersey's internal classpath scan parse class structure instead of loading classes. \nIn general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. \nMoreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple).\n\n\nUsing classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer.\nActual application configuration could always be checked with \ndiagnostic output\n),\nso there should not be any problems for using classpath scan for production too.\n\n\n\n\nWarning\n\n\nIt's a bad idea to use classpath scan for resolving extensions from 3\nrd\n party jars. Group extensions from external \njars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, \nso it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions.\nIf you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup \n(enabled by default) which could load bundles with \nservice loader definition\n.",
            "title": "Classpath scan"
        },
        {
            "location": "/guide/scan/#classpath-scan",
            "text": "Summary  Use scan only for application package. When part of application extracted to it's own library (usually already mature part) \ncreate  guicey bundle  for it with explicit extensions definition. Use  manual bundles installation  \nor  bundle lookup mechanism  to install custom bundles.",
            "title": "Classpath scan"
        },
        {
            "location": "/guide/scan/#configuration",
            "text": "Classpath scanning is activated by specifying package to scan in bundle:  GuiceBundle . builder () \n     . enableAutoConfig ( \"package.to.scan\" )   Or multiple packages:  GuiceBundle . builder () \n     . enableAutoConfig ( \"com.mycompany.pkg1\" ,   \"com.mycompany.pkg2\" )",
            "title": "Configuration"
        },
        {
            "location": "/guide/scan/#how-it-works",
            "text": "When auto scan enabled:   Extension installers are searched in classpath (classes implementing  FeatureInstaller ).  Extensions are searched using registered installers ( FeatureInstaller#matches  method).  If commands search is enabled ( .searchCommands() ), performs search for all classes extending  Command  and  install them into\nbootstrap .   Classes are searched in specified packages and all their subpackages.\nAbstract classes are ignored.   Inner static classes are also resolved:  public   abstract   class   AbstractExceptionMapper < T   extends   Exception >   implements   ExceptionMapper < T >   { \n\n     @Provider \n     public   static   class   FooExceptionMapper   extends   AbstractExceptionMapper < IOException >   {   ...   } \n\n     @Provider \n     public   static   class   BarExceptionMapper   extends   AbstractExceptionMapper < ServletException >   {   ...   }  }   FooExceptionMapper  and  BarExceptionMapper  would be detected and installed.",
            "title": "How it works"
        },
        {
            "location": "/guide/scan/#hide-class-from-scan",
            "text": "@InvisibleForScanner  annotation hides class from scanner (for example, to install it manually or to avoid installation at all)  @Provider  @InvisibleForScanner  public   static   class   FooExceptionMapper   extends   AbstractExceptionMapper < IOException >   {   ...   }   In this case  FooExceptionMapper  will be ignored by classpath scanner. But you still can install extension manually.   Tip  If you can't use annotation on extension for some reson, you can simply  disable extension",
            "title": "Hide class from scan"
        },
        {
            "location": "/guide/scan/#motivation",
            "text": "Usually, dropwizard applications are not so big (middle to small) and all classes in application package are used (so you will load all of them in any case).   Classpath scan looks for all classes in provided package(s) and loads all found classes. Usual solutions like  reflections ,  fast scanner  or even jersey's internal classpath scan parse class structure instead of loading classes. \nIn general cases, it is better solution, but, as we use all application classes in any case, loading all of them a bit earlier is not a big deal. \nMoreover, operations with loaded classes are much simpler then working with class structure (and so installers matching logic becomes very simple).  Using classpath scan is very handy during development: you simply add features (resources, tasks, servlets etc) and they are automatically discovered and installer.\nActual application configuration could always be checked with  diagnostic output ),\nso there should not be any problems for using classpath scan for production too.   Warning  It's a bad idea to use classpath scan for resolving extensions from 3 rd  party jars. Group extensions from external \njars into bundles. Usually, external libraries are well defined and all used extensions are already known and unlikely to change often, \nso it's better to manually install them through custom guicey bundle: bundle \"documents\" extensions.\nIf you want plug-n-play behaviour (bundle installed when jar appear in classpath) then use bundle lookup \n(enabled by default) which could load bundles with  service loader definition .",
            "title": "Motivation"
        },
        {
            "location": "/guide/installers/",
            "text": "Installers\n\u00b6\n\n\nInstaller is a core integration concept: every extension point has it's own installer. Installers used for both \nauto scan\n and manual modes\n(the only difference is in manual mode classes specified manually).\nInstallers itself are resolved using classpath scanning, so it's very easy to add custom installers (and possibly override default one by disabling it and registering alternative).\n\n\nAll default installers are registered by \nCoreInstallersBundle\n\n\nHow it works\n\u00b6\n\n\nWhen installer recognize class, it binds it into guice \nbinder.bind(foundClass)\n (or bind by installer if it \nsupport binding\n).\nBut extensions annotated with \n@LazyBinding\n are not bound to guice context. This may be useful to \ndelay bean creation\n:\nby default, guice production stage will instantiate all registered beans.\n\n\nOn run phase (after injector created) all found or manually provided extensions are installed by type or instantiated (\ninjector.getInstance(foundClass)\n) and passed to installer \nto register extension within dropwizard (installation type is defined by installer).\n\n\nInstallers are \nordered\n.\n\n\n\n\nEach extension is installed by only one installer!\n\n\nIf extension could be recognized by more then one installers, it will be installed only by first \nmatching installer (according to installers order). \n\n\n\n\nWriting custom installer\n\u00b6\n\n\nInstaller should implement \nFeatureInstaller\n\ninterface. It will be automatically registered if auto scan is enabled. To register manually use \n.installers()\n bundle option.\n\n\nInstaller \nmatches\n method implements feature detection logic. You can use \nFeatureUtils\n for type checks, because it's denies\nabstract classes. Method is called for classes found during scan to detect installable features and for classes directly specified\nwith \n.extensions()\n bundle option to detect installer.\n\n\nThree types of installation supported. Installer should implement one or more of these interfaces:\n\n\n\n\nBindingInstaller\n allows custom guice bindings. If installer doesn't implement this interface simple \nbind(type)\n will be called to register in guice.\n\n\nTypeInstaller\n used for registration based on type (no instance created during installation).\n\n\nInstanceInstaller\n used for instance registration. Instance created using \ninjector.getInstance(type)\n.\n\n\nJerseyInstaller\n used for registration of bindings in HK2 context.\n\n\n\n\nNote that extensions may use \n@LazyBinding\n annotation. In general case such extensions will not be registered in guice.\nIn case of \nBindingInstaller\n, special hint will be passed and installer should decide how to handle it (may throw exception as not supported).\n\n\nBindingInstaller\n called in time of injector creation, whereas \nTypeInstaller\n and \nInstanceInstaller\n are called just after injector creation.\n\nJerseyInstaller\n is called on jersey start.\n\n\n\n\nInstallers are not guice beans! So injections can't be used inside them. \nThis is because installers also used during initialization phase and instantiated before injector creation.\n\n\n\n\nExample installer:\n\n\npublic\n \nclass\n \nCustomInstaller\n \nimplements\n \nFeatureInstaller\n<\nCustomFeature\n>\n \n{\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nmatches\n(\nfinal\n \nClass\n<?>\n \ntype\n)\n \n{\n\n        \nreturn\n \nFeatureUtils\n.\nis\n(\ntype\n,\n \nCustomFeature\n.\nclass\n);\n\n    \n}\n    \n\n}\n\n\n\n\n\nFinds all CustomFeature derived classes and register them in guice (implicit registration - all classes matched by installer are registered in injector). Note that no installer interfaces were used, \nbecause guice registration is enough.\n\n\nNow suppose CustomFeature is a base class for our jersey extensions. Then installer will be:\n\n\npublic\n \nclass\n \nCustomInstaller\n \nimplements\n \nFeatureInstaller\n<\nCustomFeature\n>,\n \nJerseyInstaller\n<\nCustomFeature\n>\n \n{\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nmatches\n(\nfinal\n \nClass\n<?>\n \ntype\n)\n \n{\n\n        \nreturn\n \nFeatureUtils\n.\nis\n(\ntype\n,\n \nCustomFeature\n.\nclass\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninstall\n(\nfinal\n \nAbstractBinder\n \nbinder\n,\n \nfinal\n \nClass\n<\nCustomFeature\n>\n \ntype\n)\n \n{\n\n        \nJerseyBinding\n.\nbindComponent\n(\nbinder\n,\n \ntype\n,\n \nfalse\n,\n \nfalse\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nreport\n()\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nTip\n\n\nFor jersey installers see \nAbstractJerseyInstaller\n base class, containing common utilities.\n\n\n\n\nOrdering\n\u00b6\n\n\nIn order to support \nordering\n, installer must implement \nOrdered\n interface.\nIf installer doesn't implement it extensions will not be sorted, even if extensions has \n@Order\n annotations. \n\n\nAs example, see \nManagedInstaller\n\n\nOptions\n\u00b6\n\n\nInstaller could also use \nguicey options\n: \n* it must implement \nWithOptions\n marker interface\n* or extend form \nInstallerOptionsSupport\n base class (implemented boilerplate)\n\n\nReporting\n\u00b6\n\n\nInstallers \nreport()\n method will be called after it finish installation of all found extensions. Report provides\nuser visibility of installed extensions. \n\n\nTo simplify reporting use predefined \nReporter\n class. \nSee example usage in \nManagedInstaller\n\n\nINFO  [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.support.feature.DummyManaged)\n\n\n\n\nFor complex cases, reporter may be extended to better handle installed extensions. As examples see \n\nplugin installer reporter\n\nand \nprovider installer reporter\n\n\nINFO  [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins =\n\n    Set<PluginInterface>\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1)\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2)\n\n    Map<DummyPluginKey, PluginInterface>\n        ONE        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1)\n        TWO        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2)\n\n\n\n\nGenerics\n\u00b6\n\n\nGuicey brings \ngenerics-resolver\n which you \ncan use in installers implementation.\n\n\nFor example, to get extension interface parametrization:\n\n\ninterface\n \nExtension\n<\nV\n>\n \n{}\n\n\n\nclass\n \nListExtension\n \nimplements\n \nExtension\n<\nList\n<\nString\n>>\n \n{}\n\n\n\nGenericsResolver\n.\nresolve\n(\nListExtension\n.\nclass\n)\n\n        \n.\ntype\n(\nExtension\n.\nclass\n)\n\n        \n.\ngenericType\n(\n\"V\"\n)\n \n==\n \nList\n<\nString\n>\n \n// (ParameterizedType) \n\n\n\n\n\nGuicey itself use it for:\n\n\n\n\ntypes resolution during configuration introspection (\nConfigTreeBuilder\n)\n\n\nto introspect type hierarchy and recognize all jersey extensions (\nJerseyProviderInstaller\n)\n\n\nformat type for console reporting (\nProviderReporter\n) \n\n\nbing jersey extensions to correct types (\nJerseyBinding\n)",
            "title": "Installers"
        },
        {
            "location": "/guide/installers/#installers",
            "text": "Installer is a core integration concept: every extension point has it's own installer. Installers used for both  auto scan  and manual modes\n(the only difference is in manual mode classes specified manually).\nInstallers itself are resolved using classpath scanning, so it's very easy to add custom installers (and possibly override default one by disabling it and registering alternative).  All default installers are registered by  CoreInstallersBundle",
            "title": "Installers"
        },
        {
            "location": "/guide/installers/#how-it-works",
            "text": "When installer recognize class, it binds it into guice  binder.bind(foundClass)  (or bind by installer if it  support binding ).\nBut extensions annotated with  @LazyBinding  are not bound to guice context. This may be useful to  delay bean creation :\nby default, guice production stage will instantiate all registered beans.  On run phase (after injector created) all found or manually provided extensions are installed by type or instantiated ( injector.getInstance(foundClass) ) and passed to installer \nto register extension within dropwizard (installation type is defined by installer).  Installers are  ordered .   Each extension is installed by only one installer!  If extension could be recognized by more then one installers, it will be installed only by first \nmatching installer (according to installers order).",
            "title": "How it works"
        },
        {
            "location": "/guide/installers/#writing-custom-installer",
            "text": "Installer should implement  FeatureInstaller \ninterface. It will be automatically registered if auto scan is enabled. To register manually use  .installers()  bundle option.  Installer  matches  method implements feature detection logic. You can use  FeatureUtils  for type checks, because it's denies\nabstract classes. Method is called for classes found during scan to detect installable features and for classes directly specified\nwith  .extensions()  bundle option to detect installer.  Three types of installation supported. Installer should implement one or more of these interfaces:   BindingInstaller  allows custom guice bindings. If installer doesn't implement this interface simple  bind(type)  will be called to register in guice.  TypeInstaller  used for registration based on type (no instance created during installation).  InstanceInstaller  used for instance registration. Instance created using  injector.getInstance(type) .  JerseyInstaller  used for registration of bindings in HK2 context.   Note that extensions may use  @LazyBinding  annotation. In general case such extensions will not be registered in guice.\nIn case of  BindingInstaller , special hint will be passed and installer should decide how to handle it (may throw exception as not supported).  BindingInstaller  called in time of injector creation, whereas  TypeInstaller  and  InstanceInstaller  are called just after injector creation. JerseyInstaller  is called on jersey start.   Installers are not guice beans! So injections can't be used inside them. \nThis is because installers also used during initialization phase and instantiated before injector creation.   Example installer:  public   class   CustomInstaller   implements   FeatureInstaller < CustomFeature >   { \n     @Override \n     public   boolean   matches ( final   Class <?>   type )   { \n         return   FeatureUtils . is ( type ,   CustomFeature . class ); \n     }      }   Finds all CustomFeature derived classes and register them in guice (implicit registration - all classes matched by installer are registered in injector). Note that no installer interfaces were used, \nbecause guice registration is enough.  Now suppose CustomFeature is a base class for our jersey extensions. Then installer will be:  public   class   CustomInstaller   implements   FeatureInstaller < CustomFeature >,   JerseyInstaller < CustomFeature >   { \n     @Override \n     public   boolean   matches ( final   Class <?>   type )   { \n         return   FeatureUtils . is ( type ,   CustomFeature . class ); \n     } \n\n     @Override \n     public   void   install ( final   AbstractBinder   binder ,   final   Class < CustomFeature >   type )   { \n         JerseyBinding . bindComponent ( binder ,   type ,   false ,   false ); \n     } \n\n     @Override \n     public   void   report ()   { \n     }  }    Tip  For jersey installers see  AbstractJerseyInstaller  base class, containing common utilities.",
            "title": "Writing custom installer"
        },
        {
            "location": "/guide/installers/#ordering",
            "text": "In order to support  ordering , installer must implement  Ordered  interface.\nIf installer doesn't implement it extensions will not be sorted, even if extensions has  @Order  annotations.   As example, see  ManagedInstaller",
            "title": "Ordering"
        },
        {
            "location": "/guide/installers/#options",
            "text": "Installer could also use  guicey options : \n* it must implement  WithOptions  marker interface\n* or extend form  InstallerOptionsSupport  base class (implemented boilerplate)",
            "title": "Options"
        },
        {
            "location": "/guide/installers/#reporting",
            "text": "Installers  report()  method will be called after it finish installation of all found extensions. Report provides\nuser visibility of installed extensions.   To simplify reporting use predefined  Reporter  class. \nSee example usage in  ManagedInstaller  INFO  [2016-08-21 23:49:49,534] ru.vyarus.dropwizard.guice.module.installer.feature.ManagedInstaller: managed =\n\n    (ru.vyarus.dropwizard.guice.support.feature.DummyManaged)  For complex cases, reporter may be extended to better handle installed extensions. As examples see  plugin installer reporter \nand  provider installer reporter  INFO  [2016-08-21 23:49:49,535] ru.vyarus.dropwizard.guice.module.installer.feature.plugin.PluginInstaller: plugins =\n\n    Set<PluginInterface>\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin1)\n        (ru.vyarus.dropwizard.guice.support.feature.DummyPlugin2)\n\n    Map<DummyPluginKey, PluginInterface>\n        ONE        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin1)\n        TWO        (ru.vyarus.dropwizard.guice.support.feature.DummyNamedPlugin2)",
            "title": "Reporting"
        },
        {
            "location": "/guide/installers/#generics",
            "text": "Guicey brings  generics-resolver  which you \ncan use in installers implementation.  For example, to get extension interface parametrization:  interface   Extension < V >   {}  class   ListExtension   implements   Extension < List < String >>   {}  GenericsResolver . resolve ( ListExtension . class ) \n         . type ( Extension . class ) \n         . genericType ( \"V\" )   ==   List < String >   // (ParameterizedType)    Guicey itself use it for:   types resolution during configuration introspection ( ConfigTreeBuilder )  to introspect type hierarchy and recognize all jersey extensions ( JerseyProviderInstaller )  format type for console reporting ( ProviderReporter )   bing jersey extensions to correct types ( JerseyBinding )",
            "title": "Generics"
        },
        {
            "location": "/guide/ordering/",
            "text": "Ordering\n\u00b6\n\n\nGuicey \n@Order\n annotation should be used to order extensions and installers.\n\n\nGeneral\n\u00b6\n\n\nOrder is natural. For example, \n@Order(10)\n will be before \n@Order(20)\n.\n\n\nWhen no annotation present, class order set to \nInteger\n.\nMAX_VALUE\n, so\nall classes without order annotation are always goes last.\n\n\nExtensions order\n\u00b6\n\n\n\n\nNote\n\n\nNot all extensions supports ordering: look specific installer page for details.\nFor example, managed, lifecycle, servlets and filters installers support order.\n\n\n\n\n\n\nTip\n\n\nInstallers supporting ordering implement \nOrdered\n interface.\n\n\n\n\nThe most common case for ordering is ordering managed objects. For example:\n\n\n@Order\n(\n20\n)\n\n\npublic\n \nclass\n \nManaged1\n \nimplements\n \nManaged\n \n{\n \n...\n \n}\n\n\n\n@Order\n(\n10\n)\n\n\npublic\n \nclass\n \nManaged2\n \nimplements\n \nManaged\n \n{\n \n...\n \n}\n\n\n\npublic\n \nclass\n \nManaged3\n \nimplements\n \nManaged\n \n{\n \n...\n \n}\n\n\n\n\n\nWill be ordered as: \nManaged2\n, \nManaged1\n, \nManaged3\n\n\n\n\nNote\n\n\nGuicey remembers extensions registration order:\n\n.\nextensions\n(\nExt1\n.\nclass\n,\n \nExt2\n.\nclass\n)\n\n\n\nSo when no explicit ordering defined (or for elements with the same order value)\nregistration order will be preserved.\n\n\n\n\n\n\nTip\n\n\nConsole reporters for most extensions report extensions in correct order.\nYou can use diagnostic reporting to be sure about actual extensions order. \n\n\n\n\nInstallers order\n\u00b6\n\n\nAll bundled \ninstallers\n are ordered from 0 to ~110 with gap 10 between them to let you easily\nput your installers between (if required).\n\n\nUse \n@Order\n annotation to order custom installer, otherwise it will go after all\ndefault installers.\n\n\nBundles order\n\u00b6\n\n\n\n\nAttention\n\n\nGuicey bundles does not support ordering.\n\n\n\n\nIt makes no sense to order \nguicey bundles\n because they simply register other extensions and installers.\nYou can always order installers and extensions registered by bundles.\n\n\nMoreover, bundles are transitive, so it would be extremely hard to understand actual order:\nfor example, when bundle registered both transitively and manually.\n\n\nThere are implicit order of bundle processing:\n\n\n\n\nManually registered bundles (including transitive)\n\n\nDropwizard bundles (when recognition enabled)\n\n\nBundles lookup\n\n\n\n\nBut, again, don't count on this order because, for example, bundle resolved through lookup\nmechanism could be also manually registered and so installed as manual bundle.\n\n\nModules order\n\u00b6\n\n\n\n\nAttention\n\n\nGuicey does not support modules ordering.\n\n\n\n\nIt makes no sense to order guice modules because they simply register bindings.\nAccording to guice guice: \nmodules should not contain conditional logic\n\n\nSo all that modules should do is registering bindings and order does not matter in that case.\n\n\nModules, registered directly in guice bundle, must be executed before modules, registered in bundles \n(because registration order is preserved).",
            "title": "Ordering"
        },
        {
            "location": "/guide/ordering/#ordering",
            "text": "Guicey  @Order  annotation should be used to order extensions and installers.",
            "title": "Ordering"
        },
        {
            "location": "/guide/ordering/#general",
            "text": "Order is natural. For example,  @Order(10)  will be before  @Order(20) .  When no annotation present, class order set to  Integer . MAX_VALUE , so\nall classes without order annotation are always goes last.",
            "title": "General"
        },
        {
            "location": "/guide/ordering/#extensions-order",
            "text": "Note  Not all extensions supports ordering: look specific installer page for details.\nFor example, managed, lifecycle, servlets and filters installers support order.    Tip  Installers supporting ordering implement  Ordered  interface.   The most common case for ordering is ordering managed objects. For example:  @Order ( 20 )  public   class   Managed1   implements   Managed   {   ...   }  @Order ( 10 )  public   class   Managed2   implements   Managed   {   ...   }  public   class   Managed3   implements   Managed   {   ...   }   Will be ordered as:  Managed2 ,  Managed1 ,  Managed3   Note  Guicey remembers extensions registration order: . extensions ( Ext1 . class ,   Ext2 . class )  \nSo when no explicit ordering defined (or for elements with the same order value)\nregistration order will be preserved.    Tip  Console reporters for most extensions report extensions in correct order.\nYou can use diagnostic reporting to be sure about actual extensions order.",
            "title": "Extensions order"
        },
        {
            "location": "/guide/ordering/#installers-order",
            "text": "All bundled  installers  are ordered from 0 to ~110 with gap 10 between them to let you easily\nput your installers between (if required).  Use  @Order  annotation to order custom installer, otherwise it will go after all\ndefault installers.",
            "title": "Installers order"
        },
        {
            "location": "/guide/ordering/#bundles-order",
            "text": "Attention  Guicey bundles does not support ordering.   It makes no sense to order  guicey bundles  because they simply register other extensions and installers.\nYou can always order installers and extensions registered by bundles.  Moreover, bundles are transitive, so it would be extremely hard to understand actual order:\nfor example, when bundle registered both transitively and manually.  There are implicit order of bundle processing:   Manually registered bundles (including transitive)  Dropwizard bundles (when recognition enabled)  Bundles lookup   But, again, don't count on this order because, for example, bundle resolved through lookup\nmechanism could be also manually registered and so installed as manual bundle.",
            "title": "Bundles order"
        },
        {
            "location": "/guide/ordering/#modules-order",
            "text": "Attention  Guicey does not support modules ordering.   It makes no sense to order guice modules because they simply register bindings.\nAccording to guice guice:  modules should not contain conditional logic  So all that modules should do is registering bindings and order does not matter in that case.  Modules, registered directly in guice bundle, must be executed before modules, registered in bundles \n(because registration order is preserved).",
            "title": "Modules order"
        },
        {
            "location": "/guide/bundles/",
            "text": "Guicey bundles\n\u00b6\n\n\nBy analogy with dropwizard bundles, guicey has it's own \nGuiceyBundle\n. These bundles contains almost the same options as \nmain \nGuiceBundle\n builder. The main purpose is to group installers, extensions and guice modules related to specific \nfeature.\n\n\nGuicey bundles are initialized during dropwizard \nrun\n phase. All guice modules registered in bundles will also be checked \nfor required \ndropwizard objects autowiring\n.\n\n\nFor example, custom integration with some scheduler framework will require installers to register tasks and guice module\nto configure framework. GuiceyBundle will allow reduce integration to just one bundle installation.\n\n\npublic\n \nclass\n \nXLibIntegrationBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nfinal\n \nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nbootstrap\n.\ninstallers\n(\n\n                \nXLibFeature1Installer\n.\nclass\n,\n\n                \nXLibFeature2Installer\n.\nclass\n,\n                \n        \n)\n\n        \n.\nmodules\n(\nnew\n \nXLibGuiceModule\n());\n\n    \n}\n\n\n}\n\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundles\n(\nnew\n \nXLibIntegrationBundle\n())\n\n        \n.\nenableAutoConfig\n(\n\"package.to.scan\"\n)\n\n        \n.\nbuild\n()\n\n\n);\n\n\n\n\n\n\n\nTip\n\n\nGuiceyBootstrap\n object used not only for registration, but also provides access to\n\nBootstrap\n, \nConfiguration\n, \nConfigurationTree\n, \nEnvironment\n and \nOptions\n objects.\n\n\n\n\nBundles may be used to group application features: e.g. ResourcesBundle, TasksBundle (for example, when auto-scan not enabled to decompose configuration).\n\n\nBundles are transitive - bundle can install other bundles. \nDuplicate bundles are detected using bundle type, so infinite configuration loops or duplicate configurations are not possible.\n\n\n\n\nWarning\n\n\nBe careful if bundle is parameterizable (requires constructor arguments). If two such bundles will be registered, only\nfirst registration will be actually used and other instance ignored. Note that application configurations (using main GuiceBundle methods) \nperformed before bundles processing and so bundle instance with correct parameters could be registered there.\n\n\n\n\nTransitive bundles (or simply a lot of bundles) may cause confusion. Use \ndiagnostic info\n to see how guicey was actually configured.  \n\n\nPredefined bundles\n\u00b6\n\n\nGuicey ships with few predefined bundles.\n\n\nCore installers bundle\n\u00b6\n\n\nDefault installers are grouped into \nCoreInstallersBundle\n. This bundle is always installed implicitly (so you always have default installers).\nIt may be disabled using \n.noDefaultInstallers()\n.\n\n\nWeb installers bundle\n\u00b6\n\n\nWebInstallersBundle\n provides installers for servlets, filters and listeners installation \nusing servlet api annotations\n\n(\n@WebServlet\n, \n@WebFilter\n, \n@WebListener\n). \n\n\n\n\nWarning\n\n\nBundle is not installed by default to avoid confusion. May be enabled using \n.useWebInstallers()\n. \n\n\n\n\n\n\nTip\n\n\nIf web installers used, then you may not need guice \nServletModule\n support. To remove \nGuiceFilter\n registrations \nand \nServletModule\n support use \n.noGuiceFilter()\n.\n\n\n\n\nHK2 debug bundle\n\u00b6\n\n\nHK2DebugBundle\n is special debug bundle to check that beans properly instantiated by guice or HK2 \n(and no beans are instantiated by both).\n\n\nOnly beans installed by installers implementing \nJerseyInstaller\n (\nResourceInstaller\n, \nJerseyProviderInstaller\n).\nAll beans must be created by guice and only beans annotated with \n@HK2Managed\n must be instantiated by HK2.\n\n\nBundle may be used in tests. For example using \nguicey.bundles\n property (see bundles lookup below).\n\n\nMay be enabled by \n.strictScopeControl()\n.\n\n\n\n\nNote\n\n\nWorks in both guice-first or \nHK2-first\n modes.\n\n\n\n\nDiagnostic bundle\n\u00b6\n\n\nBundle renders collected guicey \ndiagnostic information\n.\n\n\nOutput is highly configurable, use: \nDiagnosticBundle.builder()\n to configure reporting (if required).\n\n\nBundle may be registered with \nbundle lookup mechanism\n. For example:\n\n\nPropertyBundleLookup\n.\nenableBundles\n(\nDiagnosticBundle\n.\nclass\n);\n\n\n\n\n\nMay be enabled by \n.printDiagnosticInfo()\n shortcut method.\n\n\nSpecial shortcut \n.printAvailableInstallers()\n register diagnostic bundle configured for \nshowing only installers\n. Useful when you looking for available features.\n\n\n\n\nOnly one bundle instance accepted, both options can't be enabled at the same time.\n\n\n\n\nDropwizard bundles unification\n\u00b6\n\n\nGuicey bundles and dropwizard bundles may be unified providing single (standard) extension point for both \ndropwizard and guicey features:\n\n\npublic\n \nclass\n \nMixedBundle\n \nimplements\n \nConfiguredBundle\n,\n \nGuiceyBundle\n \n{\n\n\n    \npublic\n \nvoid\n \ninitialize\n(\nBootstrap\n<?>\n \nbootstrap\n)\n \n{\n\n        \n// do something in init phase\n\n    \n}\n   \n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \n// apply guicey configurations\n\n    \n}\n \n\n    \npublic\n \nvoid\n \nrun\n(\nT\n \nconfiguration\n,\n \nEnvironment\n \nenvironment\n)\n \nthrows\n \nException\n \n{\n\n        \n// not needed because everything could be done in guicey bundle's method\n\n    \n}\n \n\n}\n \n\n\n\n\nFeature is disabled by default, to enable it use \n.configureFromDropwizardBundles()\n method.\n\n\nbootstrap\n.\naddBundle\n(\nnew\n \nMixedBundle\n());\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n        \n.\nconfigureFromDropwizardBundles\n(\ntrue\n)\n\n        \n.\nbuild\n()\n\n\n);\n\n\n\n\n\nWhen active, all registered dropwizard bundles are checked if they implement \nGuiceyBundle\n.\nWorks with both \nBundle\n and \nConfiguredBundle\n dropwizard bundle types. \n\n\n\n\nWarning\n\n\nDon't assume if guicey bundle's \ninitialize\n method will be called before/after dropwizard bundle's \nrun\n method. \nBoth are possible (it depends if bundle registered before or after GuiceBundle).\n\n\n\n\nBundle lookup\n\u00b6\n\n\nBundle lookup mechanism used to lookup guicey bundles in various sources. It may be used to activate specific bundles\nin tests (e.g. HK2DebugBundle) or to install 3\nrd\n party extensions from classpath.\n\n\nBundle lookup is equivalent to registering bundle directly using builder \nbundles\n method.\n\n\nBy default, 2 lookup mechanisms active. All found bundles are logged into console.\nDuplicate bundles are removed (using bundle class to detect duplicate).\n\n\nTo disable default lookups use \ndisableBundleLookup\n:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\ndisableBundleLookup\n()\n\n        \n.\nbuild\n()\n\n\n\n\n\nSystem property lookup\n\u00b6\n\n\nSystem property \nguicey.bundles\n could contain comma separated list of guicey bundle classes. These bundles \nmust have no-args constructor.\n\n\nFor example, activate HK2 debug bundle for tests:\n\n\njava ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle\n\n\n\n\nAlternatively, system property may be set in code:\n\n\nPropertyBundleLookup\n.\nenableBundles\n(\nHK2DebugBundle\n.\nclass\n)\n\n\n\n\n\nService loader lookup\n\u00b6\n\n\nUsing default java \nServiceLoader\n \nmechanism, loads all GuiceyBundle services.\n\n\nThis is useful for automatically install 3\nrd\n party extensions (additional installers, extensions, guice modules).\n\n\n3\nrd\n party jar must contain services file:\n\n\nMETA-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle\n\n\n\n\nFile contain one or more (per line) GuiceyBundle implementations. E.g.\n\n\ncom.foo.Bundle1\ncom.foo.Bundle2\n\n\n\n\nThen Bundle1, Bundle2 would be loaded automatically on startup.\n\n\nCustomizing lookup mechanism\n\u00b6\n\n\nCustom bundle lookup must implement \nGuiceyBundleLookup\n interface:\n\n\npublic\n \nclass\n \nCustomBundleLookup\n \nimplements\n \nGuiceyBundleLookup\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nList\n<\nGuiceyBundle\n>\n \nlookup\n()\n \n{\n\n        \nList\n<\nGuiceyBundle\n>\n \nbundles\n \n=\n \nLists\n.\nnewArrayList\n();\n\n        \n...\n\n        \nreturn\n \nbundles\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nCustom lookup implementation may be registered through:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundleLookup\n(\nnew\n \nCustomBundleLookup\n())\n\n        \n.\nbuild\n()\n\n\n\n\n\nBut it's better to register it through default implementation \nDefaultBundleLookup\n, which performs composition \nof multiple lookup implementations and logs resolved bundles to console.\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundleLookup\n(\nnew\n \nDefaultBundleLookup\n().\naddLookup\n(\nnew\n \nCustomBundleLookup\n()))\n\n        \n.\nbuild\n()\n\n\n\n\n\nTo override list of default lookups:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.<\nTestConfiguration\n>\nbuilder\n()\n\n        \n.\nbundleLookup\n(\nnew\n \nDefaultBundleLookup\n(\nnew\n \nServiceLoaderBundleLookup\n(),\n \nnew\n \nCustomBundleLookup\n()))\n\n        \n.\nbuild\n()\n\n\n\n\n\nHere two lookup mechanisms registered (property lookup is not registered and will not be implicitly added).\n\n\nOptions\n\u00b6\n\n\nOptions\n could be used in guicey bundes:\n\n\npublic\n \nclass\n \nMyBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nif\n \n(\nbootstrap\n.\noption\n(\nGuiceyOptions\n.\nUseHkBridge\n))\n \n{\n\n            \n// show warning that bridge required\n\n        \n}\n \n    \n}\n\n\n}\n\n\n\n\n\nOr it could be some \ncustom options\n usage.\n\n\nApply modifications\n\u00b6\n\n\nBundles could not only register new items, but also disable other.\n\n\nbootstrap\n\n    \n.\ndisableInstallers\n(..)\n\n    \n.\ndisableExtensions\n(..)\n\n    \n.\ndisableModules\n()\n\n\n\n\n\n\n\nNote\n\n\nBundles can't disable other bundles (because target bundle could be already processed at this point).\n\n\n\n\nThis could be used to register different versions instead of disabled items.\n\n\nAlso, bundle could directly \noverride guice bindings\n with:\n\n\nbootstrap\n\n    \n.\nmodulesOverride\n(\nnew\n \nOverridingModule\n())\n\n\n\n\n\nConfiguration access\n\u00b6\n\n\nUnique feature config\n\u00b6\n\n\nWhen working with re-usable bundles, it could be handy to rely on unique configuration \nobject:\n\n\npublic\n \nclass\n \nXFeatureBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nXFeatureConfig\n \nconf\n \n=\n \nbootstrap\n.\nconfiguration\n(\nXFeatureConfig\n.\nclass\n);\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nNote that this bundle doesn't known exact type of user configuration, it just \nassumes that XFeatureConfig is declared somewhere in configuration (on any level)\njust once. For example:\n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n\n    \n@JsonProperty\n\n    \nprivate\n \nXFeatureConfig\n \nxfeature\n;\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\nImportant\n\n\nObject uniqueness checked by exact type match, so if configuration also \ncontains some extending class (\nXFeatureConfigExt\n) it will be different unique config. \n\n\n\n\nAccess by path\n\u00b6\n\n\nWhen you are not sure that configuration is unique, you can rely on exact path definition:\n\n\npublic\n \nclass\n \nXFeatureBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n    \nprivate\n \nString\n \npath\n;\n\n\n    \npublic\n \nXFeatureBundle\n(\nString\n \npath\n)\n \n{\n\n        \nthis\n.\npath\n \n=\n \npath\n;\n\n    \n}\n \n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nXFeatureConfig\n \nconf\n \n=\n \nbootstrap\n.\nconfiguration\n(\npath\n);\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nPath is declared by bundle user, who knows required configuration location:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nbundles\n(\nnew\n \nXFeatureBundle\n(\n\"sub.feature\"\n))\n\n    \n...\n\n    \n.\nbuild\n()\n\n\n\n\n\nWhere \n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n\n    \n@JsonProperty\n\n    \nprivate\n \nSubConfig\n \nsub\n \n=\n \n{\n \n// pseudo code to combine class declarations\n\n         \n@JsonProperty\n\n         \nprivate\n \nXFeatureConfig\n \nfeature\n;\n   \n    \n}\n\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\nWarning\n\n\nRemember that you can't register 2 bundles with the same class\n\n\n\n\nMultiple configs\n\u00b6\n\n\nIn case, when multiple config objects could be declared in user configuration,\nyou can access all of them: \n\n\npublic\n \nclass\n \nXFeatureBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nList\n<\nXFeatureConfig\n>\n \nconfs\n \n=\n \nconfigurations\n(\nXFeatureConfig\n.\nclass\n);\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nFor configuration\n\n\npublic\n \nclass\n \nMyConfig\n \nextends\n \nConfiguration\n \n{\n\n\n    \n@JsonProperty\n\n    \nprivate\n \nXFeatureConfig\n \nxfeature\n;\n\n    \n@JsonProperty\n\n    \nprivate\n \nXFeatureConfig\n \nxfeature2\n;\n\n\n    \n...\n\n\n}\n\n\n\n\n\nIt wil return both objects: \n[xfeature, xfeature2]\n\n\n\n\nImportant\n\n\nIn contrast to unique configurations, this method returns all subclasses too.\nSo if there are \nXFeatureConfigExt\n declared somewhere it will also be returned.\n\n\n\n\nCustom configuration analysis\n\u00b6\n\n\nIn all other cases (with more complex requirements) you can use \nConfigurationTree\n object which\nrepresents introspected configuration paths.  \n\n\npublic\n \nclass\n \nXFeatureBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n         \n// get all properties of custom configuration (ignoring properties from base classes)\n\n        \nList\n<\nConfigPath\n>\n \npaths\n \n=\n \nbootstrap\n.\nconfigurationTree\n()\n\n                \n.\nfindAllRootPathsFrom\n(\nMyConfig\n.\nclass\n);\n\n\n        \n// search for not null values of marked (annotated) classes            \n\n        \nList\n \nmarkedTypes\n \n=\n \npaths\n.\nstream\n()\n\n            \n.\nfilter\n(\nit\n \n->\n \nit\n.\ngetValue\n()\n \n!=\n \nnull\n \n                    \n&&\n \nit\n.\ngetType\n().\ngetValueType\n().\nhasAnnotation\n(\nMyMarker\n.\nclass\n))\n\n            \n.\nmap\n(\nit\n \n->\n \nit\n.\ngetValue\n())\n\n            \n.\ncollect\n(\nCollectors\n.\ntoList\n());\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nIn this example, bundle search for properties declared directly in MyConfig configuration\nclass with not null value and annotated (classes annotated, not properties!) with custom marker (\n@MyMarker\n).  \n\n\nSee introspected configuration \nstructure description",
            "title": "Bundles (Guicey)"
        },
        {
            "location": "/guide/bundles/#guicey-bundles",
            "text": "By analogy with dropwizard bundles, guicey has it's own  GuiceyBundle . These bundles contains almost the same options as \nmain  GuiceBundle  builder. The main purpose is to group installers, extensions and guice modules related to specific \nfeature.  Guicey bundles are initialized during dropwizard  run  phase. All guice modules registered in bundles will also be checked \nfor required  dropwizard objects autowiring .  For example, custom integration with some scheduler framework will require installers to register tasks and guice module\nto configure framework. GuiceyBundle will allow reduce integration to just one bundle installation.  public   class   XLibIntegrationBundle   implements   GuiceyBundle   { \n\n     @Override \n     public   void   initialize ( final   GuiceyBootstrap   bootstrap )   { \n         bootstrap . installers ( \n                 XLibFeature1Installer . class , \n                 XLibFeature2Installer . class ,                 \n         ) \n         . modules ( new   XLibGuiceModule ()); \n     }  }  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundles ( new   XLibIntegrationBundle ()) \n         . enableAutoConfig ( \"package.to.scan\" ) \n         . build ()  );    Tip  GuiceyBootstrap  object used not only for registration, but also provides access to Bootstrap ,  Configuration ,  ConfigurationTree ,  Environment  and  Options  objects.   Bundles may be used to group application features: e.g. ResourcesBundle, TasksBundle (for example, when auto-scan not enabled to decompose configuration).  Bundles are transitive - bundle can install other bundles. \nDuplicate bundles are detected using bundle type, so infinite configuration loops or duplicate configurations are not possible.   Warning  Be careful if bundle is parameterizable (requires constructor arguments). If two such bundles will be registered, only\nfirst registration will be actually used and other instance ignored. Note that application configurations (using main GuiceBundle methods) \nperformed before bundles processing and so bundle instance with correct parameters could be registered there.   Transitive bundles (or simply a lot of bundles) may cause confusion. Use  diagnostic info  to see how guicey was actually configured.",
            "title": "Guicey bundles"
        },
        {
            "location": "/guide/bundles/#predefined-bundles",
            "text": "Guicey ships with few predefined bundles.",
            "title": "Predefined bundles"
        },
        {
            "location": "/guide/bundles/#core-installers-bundle",
            "text": "Default installers are grouped into  CoreInstallersBundle . This bundle is always installed implicitly (so you always have default installers).\nIt may be disabled using  .noDefaultInstallers() .",
            "title": "Core installers bundle"
        },
        {
            "location": "/guide/bundles/#web-installers-bundle",
            "text": "WebInstallersBundle  provides installers for servlets, filters and listeners installation  using servlet api annotations \n( @WebServlet ,  @WebFilter ,  @WebListener ).    Warning  Bundle is not installed by default to avoid confusion. May be enabled using  .useWebInstallers() .     Tip  If web installers used, then you may not need guice  ServletModule  support. To remove  GuiceFilter  registrations \nand  ServletModule  support use  .noGuiceFilter() .",
            "title": "Web installers bundle"
        },
        {
            "location": "/guide/bundles/#hk2-debug-bundle",
            "text": "HK2DebugBundle  is special debug bundle to check that beans properly instantiated by guice or HK2 \n(and no beans are instantiated by both).  Only beans installed by installers implementing  JerseyInstaller  ( ResourceInstaller ,  JerseyProviderInstaller ).\nAll beans must be created by guice and only beans annotated with  @HK2Managed  must be instantiated by HK2.  Bundle may be used in tests. For example using  guicey.bundles  property (see bundles lookup below).  May be enabled by  .strictScopeControl() .   Note  Works in both guice-first or  HK2-first  modes.",
            "title": "HK2 debug bundle"
        },
        {
            "location": "/guide/bundles/#diagnostic-bundle",
            "text": "Bundle renders collected guicey  diagnostic information .  Output is highly configurable, use:  DiagnosticBundle.builder()  to configure reporting (if required).  Bundle may be registered with  bundle lookup mechanism . For example:  PropertyBundleLookup . enableBundles ( DiagnosticBundle . class );   May be enabled by  .printDiagnosticInfo()  shortcut method.  Special shortcut  .printAvailableInstallers()  register diagnostic bundle configured for  showing only installers . Useful when you looking for available features.   Only one bundle instance accepted, both options can't be enabled at the same time.",
            "title": "Diagnostic bundle"
        },
        {
            "location": "/guide/bundles/#dropwizard-bundles-unification",
            "text": "Guicey bundles and dropwizard bundles may be unified providing single (standard) extension point for both \ndropwizard and guicey features:  public   class   MixedBundle   implements   ConfiguredBundle ,   GuiceyBundle   { \n\n     public   void   initialize ( Bootstrap <?>   bootstrap )   { \n         // do something in init phase \n     }    \n\n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n         // apply guicey configurations \n     }  \n\n     public   void   run ( T   configuration ,   Environment   environment )   throws   Exception   { \n         // not needed because everything could be done in guicey bundle's method \n     }   }    Feature is disabled by default, to enable it use  .configureFromDropwizardBundles()  method.  bootstrap . addBundle ( new   MixedBundle ());  bootstrap . addBundle ( GuiceBundle . builder () \n         . configureFromDropwizardBundles ( true ) \n         . build ()  );   When active, all registered dropwizard bundles are checked if they implement  GuiceyBundle .\nWorks with both  Bundle  and  ConfiguredBundle  dropwizard bundle types.    Warning  Don't assume if guicey bundle's  initialize  method will be called before/after dropwizard bundle's  run  method. \nBoth are possible (it depends if bundle registered before or after GuiceBundle).",
            "title": "Dropwizard bundles unification"
        },
        {
            "location": "/guide/bundles/#bundle-lookup",
            "text": "Bundle lookup mechanism used to lookup guicey bundles in various sources. It may be used to activate specific bundles\nin tests (e.g. HK2DebugBundle) or to install 3 rd  party extensions from classpath.  Bundle lookup is equivalent to registering bundle directly using builder  bundles  method.  By default, 2 lookup mechanisms active. All found bundles are logged into console.\nDuplicate bundles are removed (using bundle class to detect duplicate).  To disable default lookups use  disableBundleLookup :  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . disableBundleLookup () \n         . build ()",
            "title": "Bundle lookup"
        },
        {
            "location": "/guide/bundles/#system-property-lookup",
            "text": "System property  guicey.bundles  could contain comma separated list of guicey bundle classes. These bundles \nmust have no-args constructor.  For example, activate HK2 debug bundle for tests:  java ... -Dguicey.bundles=ru.vyarus.dropwizard.guice.module.jersey.debug.HK2DebugBundle  Alternatively, system property may be set in code:  PropertyBundleLookup . enableBundles ( HK2DebugBundle . class )",
            "title": "System property lookup"
        },
        {
            "location": "/guide/bundles/#service-loader-lookup",
            "text": "Using default java  ServiceLoader  \nmechanism, loads all GuiceyBundle services.  This is useful for automatically install 3 rd  party extensions (additional installers, extensions, guice modules).  3 rd  party jar must contain services file:  META-INF/services/ru.vyarus.dropwizard.guice.module.installer.bundle.GuiceyBundle  File contain one or more (per line) GuiceyBundle implementations. E.g.  com.foo.Bundle1\ncom.foo.Bundle2  Then Bundle1, Bundle2 would be loaded automatically on startup.",
            "title": "Service loader lookup"
        },
        {
            "location": "/guide/bundles/#customizing-lookup-mechanism",
            "text": "Custom bundle lookup must implement  GuiceyBundleLookup  interface:  public   class   CustomBundleLookup   implements   GuiceyBundleLookup   { \n\n     @Override \n     public   List < GuiceyBundle >   lookup ()   { \n         List < GuiceyBundle >   bundles   =   Lists . newArrayList (); \n         ... \n         return   bundles ; \n     }  }   Custom lookup implementation may be registered through:  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundleLookup ( new   CustomBundleLookup ()) \n         . build ()   But it's better to register it through default implementation  DefaultBundleLookup , which performs composition \nof multiple lookup implementations and logs resolved bundles to console.  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundleLookup ( new   DefaultBundleLookup (). addLookup ( new   CustomBundleLookup ())) \n         . build ()   To override list of default lookups:  bootstrap . addBundle ( GuiceBundle .< TestConfiguration > builder () \n         . bundleLookup ( new   DefaultBundleLookup ( new   ServiceLoaderBundleLookup (),   new   CustomBundleLookup ())) \n         . build ()   Here two lookup mechanisms registered (property lookup is not registered and will not be implicitly added).",
            "title": "Customizing lookup mechanism"
        },
        {
            "location": "/guide/bundles/#options",
            "text": "Options  could be used in guicey bundes:  public   class   MyBundle   implements   GuiceyBundle   { \n     @Override \n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n         if   ( bootstrap . option ( GuiceyOptions . UseHkBridge ))   { \n             // show warning that bridge required \n         }  \n     }  }   Or it could be some  custom options  usage.",
            "title": "Options"
        },
        {
            "location": "/guide/bundles/#apply-modifications",
            "text": "Bundles could not only register new items, but also disable other.  bootstrap \n     . disableInstallers (..) \n     . disableExtensions (..) \n     . disableModules ()    Note  Bundles can't disable other bundles (because target bundle could be already processed at this point).   This could be used to register different versions instead of disabled items.  Also, bundle could directly  override guice bindings  with:  bootstrap \n     . modulesOverride ( new   OverridingModule ())",
            "title": "Apply modifications"
        },
        {
            "location": "/guide/bundles/#configuration-access",
            "text": "",
            "title": "Configuration access"
        },
        {
            "location": "/guide/bundles/#unique-feature-config",
            "text": "When working with re-usable bundles, it could be handy to rely on unique configuration \nobject:  public   class   XFeatureBundle   implements   GuiceyBundle   { \n     @Override \n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n         XFeatureConfig   conf   =   bootstrap . configuration ( XFeatureConfig . class ); \n         ... \n     }  }   Note that this bundle doesn't known exact type of user configuration, it just \nassumes that XFeatureConfig is declared somewhere in configuration (on any level)\njust once. For example:  public   class   MyConfig   extends   Configuration   { \n\n     @JsonProperty \n     private   XFeatureConfig   xfeature ; \n\n     ...  }    Important  Object uniqueness checked by exact type match, so if configuration also \ncontains some extending class ( XFeatureConfigExt ) it will be different unique config.",
            "title": "Unique feature config"
        },
        {
            "location": "/guide/bundles/#access-by-path",
            "text": "When you are not sure that configuration is unique, you can rely on exact path definition:  public   class   XFeatureBundle   implements   GuiceyBundle   { \n     private   String   path ; \n\n     public   XFeatureBundle ( String   path )   { \n         this . path   =   path ; \n     }  \n\n     @Override \n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n         XFeatureConfig   conf   =   bootstrap . configuration ( path ); \n         ... \n     }  }   Path is declared by bundle user, who knows required configuration location:  GuiceBundle . builder () \n     . bundles ( new   XFeatureBundle ( \"sub.feature\" )) \n     ... \n     . build ()   Where   public   class   MyConfig   extends   Configuration   { \n\n     @JsonProperty \n     private   SubConfig   sub   =   {   // pseudo code to combine class declarations \n          @JsonProperty \n          private   XFeatureConfig   feature ;    \n     } \n\n     ...  }    Warning  Remember that you can't register 2 bundles with the same class",
            "title": "Access by path"
        },
        {
            "location": "/guide/bundles/#multiple-configs",
            "text": "In case, when multiple config objects could be declared in user configuration,\nyou can access all of them:   public   class   XFeatureBundle   implements   GuiceyBundle   { \n     @Override \n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n         List < XFeatureConfig >   confs   =   configurations ( XFeatureConfig . class ); \n         ... \n     }  }   For configuration  public   class   MyConfig   extends   Configuration   { \n\n     @JsonProperty \n     private   XFeatureConfig   xfeature ; \n     @JsonProperty \n     private   XFeatureConfig   xfeature2 ; \n\n     ...  }   It wil return both objects:  [xfeature, xfeature2]   Important  In contrast to unique configurations, this method returns all subclasses too.\nSo if there are  XFeatureConfigExt  declared somewhere it will also be returned.",
            "title": "Multiple configs"
        },
        {
            "location": "/guide/bundles/#custom-configuration-analysis",
            "text": "In all other cases (with more complex requirements) you can use  ConfigurationTree  object which\nrepresents introspected configuration paths.    public   class   XFeatureBundle   implements   GuiceyBundle   { \n     @Override \n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n          // get all properties of custom configuration (ignoring properties from base classes) \n         List < ConfigPath >   paths   =   bootstrap . configurationTree () \n                 . findAllRootPathsFrom ( MyConfig . class ); \n\n         // search for not null values of marked (annotated) classes             \n         List   markedTypes   =   paths . stream () \n             . filter ( it   ->   it . getValue ()   !=   null  \n                     &&   it . getType (). getValueType (). hasAnnotation ( MyMarker . class )) \n             . map ( it   ->   it . getValue ()) \n             . collect ( Collectors . toList ()); \n         ... \n     }  }   In this example, bundle search for properties declared directly in MyConfig configuration\nclass with not null value and annotated (classes annotated, not properties!) with custom marker ( @MyMarker ).    See introspected configuration  structure description",
            "title": "Custom configuration analysis"
        },
        {
            "location": "/guide/options/",
            "text": "Options\n\u00b6\n\n\nOptions are low level configurations. In contrast to dropwizard configuration (file), which is user specific,\noptions are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours.\n\n\nOptions are declared with enums. Enums used to naturally group options (also cause pretty reporting). \nEnums must implement \nOption\n interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum),\nbut provides required option info).\n\n\nGuicey use options to share guice bundle configurations (configured packages to scan, search commands enabling etc) through \nGuiceyOptions\n enum\n(for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle).\nAnother use is in web installers to change default behaviour though \nInstallersOptions\n enum. \n\n\nCustom options may be defined for 3\nrd\n party bundle or even application. Options is a general mechanism providing configuration and access points with \nstandard reporting (part of \ndiagnostic reporting\n). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize\napplication state in tests (just to name a few).\n\n\nUsage\n\u00b6\n\n\nOptions may be set only in main GuiceBundle using \n.option\n method. This is important to let configuration parts to see the same values.\nFor example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and,\nfor sure, this will eventually lead to inconsistent behaviour.\n\n\nOption could not be set to null. Option could be null only if it's default value is null and custom value not set.\nCustom option value is checked for compatibility with option type (from option definition) and error thrown if does not match.\nOf course, type checking is limited to top class and generics are ignored (so \nList<String>\n could not be specified and so\ncan't be checked), but it's a compromise between complexity and easy of use (the same as \nEnum & Option\n pair).\n\n\nOptions could be accessed by:\n\n\n\n\nGuicey bundles using \nbootstrap.option()\n\n\nInstaller by implementing \nWithOptions\n interface \n\n\nAny guice bean could inject \nOptions\n bean and use it to access options.\n\n\nGuice module could access options by implementing \nOptionsAwareModule\n marker interface\n\n\n\n\nGuicey tracks options definition and usage and report all used options as part of \ndiagnostic reporting\n.\nPay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options.\n\n\nActual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used.\nTry to consume options closer to actual usage to let user be aware if option not used with current configuration. For example,\nGuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used.\n\n\nCustom options\n\u00b6\n\n\nOptions must be enum and implement \nOption\n interface, like this:\n\n\nenum\n \nMyOptions\n \nimplements\n \nOption\n \n{\n\n\n    \nDoExtraWork\n(\nBoolean\n,\n \ntrue\n),\n\n    \nEnableDebug\n(\nBoolean\n,\n \nfalse\n),\n\n    \nInternalConfig\n(\nString\n[],\n \nnew\n \nString\n[]{\n\"one\"\n,\n \n\"two\"\n,\n \n\"three\"\n});\n\n\n    \nprivate\n \nClass\n \ntype\n\n    \nprivate\n \nObject\n \nvalue\n\n\n    \n// generic used only to check type - value correctness\n\n    \n<\nT\n>\n \nSampleOptions\n(\nClass\n<\nT\n>\n \ntype\n,\n \nT\n \nvalue\n)\n \n{\n\n        \nthis\n.\ntype\n \n=\n \ntype\n\n        \nthis\n.\nvalue\n \n=\n \nvalue\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nClass\n \ngetType\n()\n \n{\n\n        \nreturn\n \ntype\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nObject\n \ngetDefaultValue\n()\n \n{\n\n        \nreturn\n \nvalue\n\n    \n}\n\n\n}\n\n\n\n\n\nEach enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value.\nThis will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []).\n\n\nNow you can use option, for example, in bean:\n\n\nimport static\n \nMyOptions.DoExtraWork\n;\n\n\n\npublic\n \nclass\n \nMyBean\n \n{\n\n    \n@Inject\n \nOptions\n \noptions\n;\n\n\n    \npulic\n \nvoid\n \nsomeMethod\n()\n \n{\n\n        \n...\n \n        \nif\n \n(\noptions\n.\nget\n(\nDoExtraWork\n))\n \n{\n\n            \n// extra work impl\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nTo provide custom option value:\n\n\n    \nGuiceBundle\n.\nbuilder\n()\n\n        \n.\noption\n(\nDoExtraWork\n,\n \nfalse\n)\n\n        \n...\n\n\n\n\n\nOptions lookup\n\u00b6\n\n\nGuicey provides simple mapping utility to map properties to system properties, environment variables \nor simply bind from string (obtained manually somewhere). \n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n...\n\n    \n.\noptions\n(\nnew\n \nOptionsMapper\n()\n\n                    \n.\nprop\n(\n\"myprop\"\n,\n \nMyoptions\n.\nSomeOption\n)\n\n                    \n.\nenv\n(\n\"STAGE\"\n,\n \nGuiceyOptions\n.\nInjectorStage\n)\n\n                    \n.\nstring\n(\nMyoptions\n.\nSomeOtherOption\n,\n \n\"property value\"\n)\n\n                    \n.\nmap\n())\n \n    \n.\nbuild\n()\n                \n\n\n\n\nHere:\n\n\n\n\nMyoptions.SomeOption\n could be changed with \"myprop\" system property (\n-Dmyprop=something\n)\n\n\nGuiceyOptions.InjectorStage\n could be changed with environment variable \"STAGE\"\n\n\nMyoptions.SomeOtherOption\n set from string (string could be obtained somewhere else manually) \n\n\n\n\n\n\nImportant\n\n\nMissed mappings are ignored: e.g. if system property or environment variable is not \ndefined - option will remain with default value (null will not be set!)\n\n\n\n\nSupported conversions\n\u00b6\n\n\n\n\nEach option declares required option type\n\n\n\n\nMapper could automatically convert string to:\n\n\n\n\nString\n\n\nBoolean\n\n\nInteger\n\n\nDouble\n\n\nShort\n\n\nByte\n\n\nEnum constant: \n\n\nIf option type is exact enum then value must be constant name\n\n\nIf option type is generic \nEnum\n then value must be 'fullEnumClass.constantName'\n\n\n\n\n\n\nArray or any type (from above): values must be separated by comma (\"one, two, three\")\n\n\nEnumSet: value must be comma separated list with fully qualified enum constants ('fullEnumClass.constantName')   \n\n\n\n\n\n\nTip\n\n\nYou can use sting conversion directly somewhere else, if required:\n\nStringConverter.convert(TargetType, stringValue)\n\n\n\n\nException is thrown when type is not supported for conversion. In this case use manual converter:\n\n\nnew\n \nOptionsMapper\n()\n\n            \n.\nprop\n(\n\"myprop\"\n,\n \nMyoptions\n.\nSomeOption\n,\n \nval\n \n->\n \nconvertVal\n(\nval\n))\n\n            \n.\nmap\n()\n\n\n\n\n\nConverter is actually any \njava.util.Function\n (here, lambda with method call (\n::convertVal\n)).\n\n\nSystem properties\n\u00b6\n\n\nAs shown before, you can bind single system property to option. But you can allso allow\nto set any option with system property:\n\n\nnew\n \nOptionsMapper\n().\nprops\n().\nmap\n()\n\n\n\n\n\nIt will bind all properties in format: \noption.enumClasName.enumValue\n.\nFor example, \n-Doption.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge=true\n \n\n\nDifferent prefix could be used: \n.props(\"myprefix\")\n \n\n\n\n\nWarning\n\n\nAll properties with matched prefix must be mappable to option (target enum exists),\notherwise error will be thrown.\n\n\n\n\nIf any property requires custom value conversion then bind it \nbefore\n with converter\nand it will be ignored during mass mapping by prefix:\n\n\nnew\n \nOptionsMapper\n()\n\n        \n.\nprop\n(\n\"option.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge\"\n,\n \n                \nGuiceyOptions\n.\nUseHkBridge\n,\n \nval\n \n-\n \n>\n \nconvert\n(\nval\n))\n\n        \n.\nprops\n()\n\n        \n.\nmap\n()\n\n\n\n\n\nDebug\n\u00b6\n\n\nYou can enable mapped options print with \n.printMappings()\n:\n\n\nnew\n \nOptionsMapper\n()\n\n            \n.\nprop\n(\n\"myprop\"\n,\n \nMyoptions\n.\nSomeOption\n,\n \nval\n \n->\n \nconvertVal\n(\nval\n))\n\n            \n.\nprintMappings\n()\n\n            \n.\nmap\n()\n\n\n\n\n\nWhen enabled, all mapped options will be printed to console (logger is not used becuase it's not yet initialized).\n\n\nExample output:\n\n    env: VAR                   Opts.OptInt = 1\n    prop: foo                  Opts.OptStr = bar\n                               Opts.OptBool = true\n\n\n\nfor mapper:\n\nnew\n \nOptionsMapper\n()\n\n        \n.\nprintMappings\n()\n\n        \n.\nenv\n(\n\"VAR\"\n,\n \nOpts\n.\nOptInt\n)\n\n        \n.\nenv\n(\n\"VAR2\"\n,\n \nOpts\n.\nOptDbl\n)\n\n        \n.\nprop\n(\n\"foo\"\n,\n \nOpts\n.\nOptStr\n)\n\n        \n.\nprop\n(\n\"foo2\"\n,\n \nOpts\n.\nOptShort\n)\n\n        \n.\nstring\n(\nOpts\n.\nOptBool\n,\n \n\"true\"\n)\n\n        \n.\nmap\n()\n\n\n\n\nHere \"VAR2\" env. variable and \"foo2\" system property wasn't declared and so not mapped. \n\n\nCustom lookup\n\u00b6\n\n\nYou can directly specify map of options (\n.options(Map<Enum, Object>)\n) or write your own lookup mechanism:\n\n\n    \nGuiceBundle\n.\nbuilder\n()\n\n        \n.\noptions\n(\nnew\n \nMyOptionsLookup\n().\ngetOptions\n())\n\n        \n...\n\n\n\n\n\n\n\n.options()\n method contract simplified for just \nEnum\n, excluding \nOption\n for \nsimpler usage, but still only option enums must be provided",
            "title": "Options"
        },
        {
            "location": "/guide/options/#options",
            "text": "Options are low level configurations. In contrast to dropwizard configuration (file), which is user specific,\noptions are set during development and represent developer decisions. Often, options allow to change opinionated default behaviours.  Options are declared with enums. Enums used to naturally group options (also cause pretty reporting). \nEnums must implement  Option  interface (this makes enum declaration more verbose (because it is impossible to use abstract class in enum),\nbut provides required option info).  Guicey use options to share guice bundle configurations (configured packages to scan, search commands enabling etc) through  GuiceyOptions  enum\n(for simplicity, main guicey options usages are already implemented as shortcut methods in guice bundle).\nAnother use is in web installers to change default behaviour though  InstallersOptions  enum.   Custom options may be defined for 3 rd  party bundle or even application. Options is a general mechanism providing configuration and access points with \nstandard reporting (part of  diagnostic reporting ). It may be used as feature triggers (like guicey do), to enable debug behaviour or to specialize\napplication state in tests (just to name a few).",
            "title": "Options"
        },
        {
            "location": "/guide/options/#usage",
            "text": "Options may be set only in main GuiceBundle using  .option  method. This is important to let configuration parts to see the same values.\nFor example, if guicey bundles would be allowed to change options then one bundles would see one value and other bundles - different value and,\nfor sure, this will eventually lead to inconsistent behaviour.  Option could not be set to null. Option could be null only if it's default value is null and custom value not set.\nCustom option value is checked for compatibility with option type (from option definition) and error thrown if does not match.\nOf course, type checking is limited to top class and generics are ignored (so  List<String>  could not be specified and so\ncan't be checked), but it's a compromise between complexity and easy of use (the same as  Enum & Option  pair).  Options could be accessed by:   Guicey bundles using  bootstrap.option()  Installer by implementing  WithOptions  interface   Any guice bean could inject  Options  bean and use it to access options.  Guice module could access options by implementing  OptionsAwareModule  marker interface   Guicey tracks options definition and usage and report all used options as part of  diagnostic reporting .\nPay attention that defined (value set) but not used (not consumed) options are marked as NOT_USED to indicate possibly redundant options.  Actual application may use options in different time and so option may be defined as NOT_USE even if its actually \"not yet\" used.\nTry to consume options closer to actual usage to let user be aware if option not used with current configuration. For example,\nGuiceyOptions.BindConfigurationInterfaces will not appear in report at all if no custom configuration class used.",
            "title": "Usage"
        },
        {
            "location": "/guide/options/#custom-options",
            "text": "Options must be enum and implement  Option  interface, like this:  enum   MyOptions   implements   Option   { \n\n     DoExtraWork ( Boolean ,   true ), \n     EnableDebug ( Boolean ,   false ), \n     InternalConfig ( String [],   new   String []{ \"one\" ,   \"two\" ,   \"three\" }); \n\n     private   Class   type \n     private   Object   value \n\n     // generic used only to check type - value correctness \n     < T >   SampleOptions ( Class < T >   type ,   T   value )   { \n         this . type   =   type \n         this . value   =   value \n     } \n\n     @Override \n     public   Class   getType ()   { \n         return   type \n     } \n\n     @Override \n     public   Object   getDefaultValue ()   { \n         return   value \n     }  }   Each enum value declares option with exact type and default value. Option type is not limited, but implement proper toString for custom object used as option value.\nThis will require for pretty reporting, as simple toString used for option value (except collections and arrays are rendered as []).  Now you can use option, for example, in bean:  import static   MyOptions.DoExtraWork ;  public   class   MyBean   { \n     @Inject   Options   options ; \n\n     pulic   void   someMethod ()   { \n         ...  \n         if   ( options . get ( DoExtraWork ))   { \n             // extra work impl \n         } \n     }  }   To provide custom option value:       GuiceBundle . builder () \n         . option ( DoExtraWork ,   false ) \n         ...",
            "title": "Custom options"
        },
        {
            "location": "/guide/options/#options-lookup",
            "text": "Guicey provides simple mapping utility to map properties to system properties, environment variables \nor simply bind from string (obtained manually somewhere).   GuiceBundle . builder () \n     ... \n     . options ( new   OptionsMapper () \n                     . prop ( \"myprop\" ,   Myoptions . SomeOption ) \n                     . env ( \"STAGE\" ,   GuiceyOptions . InjectorStage ) \n                     . string ( Myoptions . SomeOtherOption ,   \"property value\" ) \n                     . map ())  \n     . build ()                   Here:   Myoptions.SomeOption  could be changed with \"myprop\" system property ( -Dmyprop=something )  GuiceyOptions.InjectorStage  could be changed with environment variable \"STAGE\"  Myoptions.SomeOtherOption  set from string (string could be obtained somewhere else manually)     Important  Missed mappings are ignored: e.g. if system property or environment variable is not \ndefined - option will remain with default value (null will not be set!)",
            "title": "Options lookup"
        },
        {
            "location": "/guide/options/#supported-conversions",
            "text": "Each option declares required option type   Mapper could automatically convert string to:   String  Boolean  Integer  Double  Short  Byte  Enum constant:   If option type is exact enum then value must be constant name  If option type is generic  Enum  then value must be 'fullEnumClass.constantName'    Array or any type (from above): values must be separated by comma (\"one, two, three\")  EnumSet: value must be comma separated list with fully qualified enum constants ('fullEnumClass.constantName')       Tip  You can use sting conversion directly somewhere else, if required: StringConverter.convert(TargetType, stringValue)   Exception is thrown when type is not supported for conversion. In this case use manual converter:  new   OptionsMapper () \n             . prop ( \"myprop\" ,   Myoptions . SomeOption ,   val   ->   convertVal ( val )) \n             . map ()   Converter is actually any  java.util.Function  (here, lambda with method call ( ::convertVal )).",
            "title": "Supported conversions"
        },
        {
            "location": "/guide/options/#system-properties",
            "text": "As shown before, you can bind single system property to option. But you can allso allow\nto set any option with system property:  new   OptionsMapper (). props (). map ()   It will bind all properties in format:  option.enumClasName.enumValue .\nFor example,  -Doption.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge=true    Different prefix could be used:  .props(\"myprefix\")     Warning  All properties with matched prefix must be mappable to option (target enum exists),\notherwise error will be thrown.   If any property requires custom value conversion then bind it  before  with converter\nand it will be ignored during mass mapping by prefix:  new   OptionsMapper () \n         . prop ( \"option.ru.vyarus.dropwizard.guice.GuiceyOptions.UseHkBridge\" ,  \n                 GuiceyOptions . UseHkBridge ,   val   -   >   convert ( val )) \n         . props () \n         . map ()",
            "title": "System properties"
        },
        {
            "location": "/guide/options/#debug",
            "text": "You can enable mapped options print with  .printMappings() :  new   OptionsMapper () \n             . prop ( \"myprop\" ,   Myoptions . SomeOption ,   val   ->   convertVal ( val )) \n             . printMappings () \n             . map ()   When enabled, all mapped options will be printed to console (logger is not used becuase it's not yet initialized).  Example output:     env: VAR                   Opts.OptInt = 1\n    prop: foo                  Opts.OptStr = bar\n                               Opts.OptBool = true  for mapper: new   OptionsMapper () \n         . printMappings () \n         . env ( \"VAR\" ,   Opts . OptInt ) \n         . env ( \"VAR2\" ,   Opts . OptDbl ) \n         . prop ( \"foo\" ,   Opts . OptStr ) \n         . prop ( \"foo2\" ,   Opts . OptShort ) \n         . string ( Opts . OptBool ,   \"true\" ) \n         . map ()   Here \"VAR2\" env. variable and \"foo2\" system property wasn't declared and so not mapped.",
            "title": "Debug"
        },
        {
            "location": "/guide/options/#custom-lookup",
            "text": "You can directly specify map of options ( .options(Map<Enum, Object>) ) or write your own lookup mechanism:       GuiceBundle . builder () \n         . options ( new   MyOptionsLookup (). getOptions ()) \n         ...    .options()  method contract simplified for just  Enum , excluding  Option  for \nsimpler usage, but still only option enums must be provided",
            "title": "Custom lookup"
        },
        {
            "location": "/guide/diagnostic/",
            "text": "Diagnostic info\n\u00b6\n\n\nDuring startup guicey records startup metrics and remembers all details of configuration process. \nAll this information is available through \nGuiceyConfigurationInfo\n bean in guice context. \n\n\nDiagnostic service\n\u00b6\n\n\nDefault diagnostic info rendering is provided to assist configuration problems resolution and better guicey internals understanding.\n\n\nThe simplest way to enable diagnostic reporting is using bundle \n.printDiagnosticInfo()\n option. \nThis registers \nDiagnosticBundle\n with default reporting configuration. \nBundle could be registered directly in order to customize output.\n\n\n\n\nTip\n\n\nYou can use diagnostic logs with \nlifecycle phases logging\n\nand \nconfiguration bindings report\n\n\n\n\nWhen \n.printDiagnosticInfo()\n enabled, the following kind of logs will be printed after server startup:\n\n\nINFO  [2016-08-01 21:22:50,898] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Startup stats = \n\n    GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    \u2502   \n    \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms\n    \u2502   \n    \u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs\n    \u2502   \n    \u2514\u2500\u2500 [1,1%] remaining 5 ms\n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Options = \n\n    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]                 \n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN, GUICE_ENABLED\n\n\n    BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP\n\n\n    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n\n\n    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceBootstrapModule         (r.v.d.guice.module)       \n\nINFO  [2016-08-01 21:22:50,909] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceBootstrapModule         (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n    \u2502       \u2514\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     *IGNORED\n    \u2502   \n    \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n    \u2502   \u251c\u2500\u2500 extension  HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n    \u2502   \u2514\u2500\u2500 module     HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n    \u2502   \n    \u251c\u2500\u2500 DiagnosticBundle             (r.v.d.g.m.c.debug)        \n    \u2502   \u2514\u2500\u2500 module     DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n    \u2502   \n    \u251c\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     *IGNORED\n    \u2502   \u2514\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n    \u2502   \n    \u251c\u2500\u2500 BUNDLES LOOKUP\n    \u2502   \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        *IGNORED\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n    \u2502       \u2514\u2500\u2500 module     GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n    \u2502   \n    \u2514\u2500\u2500 CLASSPATH SCAN\n        \u2514\u2500\u2500 extension  FooResource                  (r.v.d.g.d.s.features)  \n\n\n\n\nDefault reporting contains 4 sections:\n\n\n\n\nHow guicey spent time\n\n\nWhat options used\n\n\nWhat was configured\n\n\nFrom where configuration items come from\n\n\n\n\nTimings\n\u00b6\n\n\nStartup timings\n\u00b6\n\n\n    GUICEY started in 453.3 ms\n\n\n\n\nOverall guicey time measured: GuiceBundle methods plus part of HK2 configuration time (HK2 started after bundle).\nAll items below represent guicey time detalization. Items always detail time of direct parent.\n\n\nMost of this time actually spent on class loading. For example, report above represent \ntest\n direct execution. \nBut when this test executed as part of suit time become  \nGUICEY started in 52.95 ms\n because most classes were pre-loaded by other tests.\n\n\nClasspath scan\n\u00b6\n\n\n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n\n\n\n\nClasspath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions. \n\n\nscanned 5 classes\n means that 5 classed were found (overall) in configured packages. \nrecognized 4 classes\n Show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command).\n\n\nNOTE: classpath scan time will be obviously bigger for larger classes count. But most of this time are actually class loading time. If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time move to other some place (for example, to injector creation). \n\n\nCommands\n\u00b6\n\n\n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n\n\n\n\nCommands time includes time spent on commands search (in classes from classpath scan; if enabled .searchCommands()) and calling .injectMemebers on configured environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled)\n\n\nBundles\n\u00b6\n\n\n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n\n\n\n\nBundles time includes bundles lookup time (if not .disableBundleLookup()), dropwizard bunles lookup (if .configureFromDropwizardBundles()) and bundles execution.\n\n\n2 resolved in 8.149 ms\n indicated bundles resolved with guicey bundle lookup or from dropwizard bundles.\n\n6 processed\n - overall processed bundles (all registered bundles, including just resolved).\n\n\nInjector\n\u00b6\n\n\n    \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms\n\n\n\n\nAll installers and extensions operations (except jersey related features) performed inside of guice module and so included into overall injector creation time.\n\n\ninstallers prepared in 13.79 ms\n include installers search in classpath (if scan enabled), instantiation and preparing for usage (remove duplicates, sort).\n\n\nextensions recognized in 9.259 ms\n - all manually configured extensions and all classes from classpath scan (\nfrom 7 classes\n) are recognized by all registered installers (\nusing 11 installers\n) using installer match method. Recognized installers bound to guice context (or custom action performed for binding installers).\n\n\n3 extensions installed in 4.188 ms\n - all recognized extensions are installed with installers install methods.\n\n\n\n\nNote\n\n\nMost time of injector creation is internal guice logic. You can enable guice logs to see more details (see below)\n\n\n\n\nHK2\n\u00b6\n\n\n    \u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs\n\n\n\n\nJersey starts after dropwizard bundles processing and so after GuiceBundle execution. This time is tracked as (overall) guicey time. Here guicey register required HK2 bindings and (some HK2 beans in guice) and executes jersey installers (installers implement JerseyInstaller) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires HK2 specific bindings).\n\n\nNote that installation time (\n2 jersey extensions installed in 660.9 \u03bcs\n) is so tiny just because empty resources (without methods) were used. In real application installation time will be bigger.\n\n\nRemaining\n\u00b6\n\n\n    \u2514\u2500\u2500 [1,1%] remaining 5 ms\n\n\n\n\nRepresent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown.\n\n\nUsed options\n\u00b6\n\n\nShows all set or requested (by application logic) options. If you use your own options here they will also be printed.\n\n\n    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]     \n\n\n\n\nUsed markers:\n* CUSTOM - option value set by user\n* NOT_USED - option was set by user but never used\n\n\nNot used marker just indicated that option is \"not yet\" used. Options may be consumed lazilly by application logic, so\nit is possible that its not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario).\n\n\nConfiguration diagnostic info\n\u00b6\n\n\nSection intended to compactly show all configuration (to quickly see what was configured).\n\n\nThis and the next sections used condensed package notion:\n\n\nCoreInstallersBundle         (r.v.d.g.m.installer)    \n\n\n\n\nAssumed that all classes in application will be uniquely identifiable by name and package info shown just to be able to \nunderstand exact class location. Logback shrinker used.\n\n\nReport also indicates duplicate registrations by REG(N) marker, where N - amount of installations \n(ignored installations will be visible in configuration tree). Counted:\n\n\n\n\nitem registration in different places (e.g. different bundles)\n\n\nduplicate registrations in simgle place (e.g. \n.extensions(MyExt.class, MyExt.class)\n)\n\n\n\n\nGeneral\n\u00b6\n\n\nAll configuration items (commands, modules, installers, extension, bundles) are identified by class. Duplicate entities are not allowed and simply ignored.\n\n\nFor example, if extension registered manually and by classpath scan then it will be registered once, but internally guicey will remember both configuration sources.\n\n\nIn contrast to other items, bundles and modules are registered by instance, but still uniqueness is checked by type: only first instance registered and other instances considered as duplicate.\n\n\nCommands\n\u00b6\n\n\n    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN,GUICE_ENABLED\n\n\n\n\nShows commands resolved with classpath scan (enabled with .searchCommands()).\n\n\nThe following markers used:\n\n\n\n\nSCAN - item from classpath scan (always)\n\n\nGUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts)\n\n\n\n\nBundles\n\u00b6\n\n\n    BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP\n\n\n\n\nAll registered bundles are shown as a tree (to indicate transitive bundles).\n\n\nThe following markers used:\n\n\n\n\nLOOKUP - bundle resolved with bundle lookup mechanism\n\n\nDW - bundle recognized from registered dropwizard bundle\n\n\n\n\nInstallers and extensions\n\u00b6\n\n\n    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n\n\n\n\nShows used installers (only installers which install extensions) and installed extensions. \n\n\nBoth installers and extensions are shown in the processing order (sorted according to @Order annotations).\n\n\nThe following markers used:\n\n\n\n\nSCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan)\n\n\nLAZY - extensions annotated with \n@LazyBinding\n\n\nHK2 - extension annotated with \n@HK2Managed\n\n\nHOOK - registered by \nconfiguration hook\n\n\n\n\nModules\n\u00b6\n\n\n    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceBootstrapModule         (r.v.d.guice.module)  \n\n\n\n\nAll registered guice modules.\n\n\nConfiguration context tree\n\u00b6\n\n\nConfiguration tree is useful to understand from where configuration items come from.\n\n\nInstaller disables are shown like:\n\n\n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature) \n\n\n\n\nDuplicate registrations (ignored by guicey) are shown like:\n\n\n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n\n\n\n\nIf number in configuration report (e.g.REG(3)) doesn't match registration appearances, then item registered\nmultiple times in one of this places.\n\n\nNote that CoreInstallersBundle are always below all other bundles. This is because it always registered last \n(to be able to disable it's registration). It doesn't affect anything other than reporting (because bundles order does \nnot change anything except this tree).\n\n\nRe-using\n\u00b6\n\n\nDiagnostic info rendering may be used for custom rendering (showing in web page or some other staff).\nRendering is performed with 3 beans, available for injection (when bundle registered):\n\n\n\n\nStatsRenderer\n\n\nOptionsRenderer\n\n\nDiagnosticRenderer\n\n\nContextTreeRenderer\n \n\n\n\n\n\n\nNote\n\n\nRenderers are also available in \nevent objects\n (for events fired after injection creation) \n\n\n\n\nInstallers mode\n\u00b6\n\n\nThere is a special option in GuiceBundle \n.printAvailableInstallers()\n for printing only installers information. \nIt also use DiagnosticBundle, but with different configuration. \n\n\n\n\nWarning\n\n\nBoth options can't be used together (but it should never be required as they serve different purposes).\n\n\n\n\nExample output:\n\n\nINFO  [2016-08-22 00:49:33,557] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    INSTALLERS in processing order = \n        lifecycle            (r.v.d.g.m.i.f.LifeCycleInstaller)     \n        managed              (r.v.d.g.m.i.feature.ManagedInstaller) \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) \n        jerseyprovider       (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n        eagersingleton       (r.v.d.g.m.i.f.e.EagerSingletonInstaller) \n        healthcheck          (r.v.d.g.m.i.f.h.HealthCheckInstaller) \n        task                 (r.v.d.g.m.i.feature.TaskInstaller)    \n        plugin               (r.v.d.g.m.i.f.plugin.PluginInstaller) \n        webservlet           (r.v.d.g.m.i.f.w.WebServletInstaller)  \n        webfilter            (r.v.d.g.m.i.f.web.WebFilterInstaller) \n        weblistener          (r.v.d.g.m.i.f.w.l.WebListenerInstaller) \n\nINFO  [2016-08-22 00:49:33,563] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u2502   \n    \u251c\u2500\u2500 WebInstallersBundle          (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  WebFilterInstaller           (r.v.d.g.m.i.f.web)        \n    \u2502   \u251c\u2500\u2500 installer  WebServletInstaller          (r.v.d.g.m.i.f.web)        \n    \u2502   \u2514\u2500\u2500 installer  WebListenerInstaller         (r.v.d.g.m.i.f.w.listener) \n    \u2502   \n    \u2514\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n        \u251c\u2500\u2500 installer  LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  ManagedInstaller             (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  JerseyProviderInstaller      (r.v.d.g.m.i.f.j.provider) \n        \u251c\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  EagerSingletonInstaller      (r.v.d.g.m.i.f.eager)      \n        \u251c\u2500\u2500 installer  HealthCheckInstaller         (r.v.d.g.m.i.f.health)     \n        \u251c\u2500\u2500 installer  TaskInstaller                (r.v.d.g.m.i.feature)      \n        \u2514\u2500\u2500 installer  PluginInstaller              (r.v.d.g.m.i.f.plugin)     \n\n\n\n\n\n\nImportant\n\n\nComparing to complete diagnostic, it shows all installers (\neven not used\n). \nIn diagnostic reporting not used installers are hidden, because usually it means they are not needed.\n\n\n\n\nGuice injector creation timings\n\u00b6\n\n\nYou will see in guicey timings that almost all time spent creating guice injector. \nTo see some guice internal timings enable guice debug logs:\n\n\nlogging:\n  loggers:\n    com.google.inject.internal.util: DEBUG\n\n\n\n\nLogs will be something like this:\n\n\nDEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Module execution: 272ms\nDEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Interceptors creation: 1ms\nDEBUG [2016-08-03 21:09:45,965] com.google.inject.internal.util.Stopwatch: TypeListeners & ProvisionListener creation: 2ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Scopes creation: 1ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Converters creation: 0ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Binding creation: 26ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Module annotated method scanners creation: 0ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Private environment creation: 1ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Injector construction: 0ms\nDEBUG [2016-08-03 21:09:46,170] com.google.inject.internal.util.Stopwatch: Binding initialization: 177ms\nDEBUG [2016-08-03 21:09:46,171] com.google.inject.internal.util.Stopwatch: Binding indexing: 1ms\nDEBUG [2016-08-03 21:09:46,172] com.google.inject.internal.util.Stopwatch: Collecting injection requests: 1ms\nDEBUG [2016-08-03 21:09:46,179] com.google.inject.internal.util.Stopwatch: Binding validation: 7ms\nDEBUG [2016-08-03 21:09:46,183] com.google.inject.internal.util.Stopwatch: Static validation: 4ms\nDEBUG [2016-08-03 21:09:46,191] com.google.inject.internal.util.Stopwatch: Instance member validation: 8ms\nDEBUG [2016-08-03 21:09:46,192] com.google.inject.internal.util.Stopwatch: Provider verification: 1ms\nDEBUG [2016-08-03 21:09:46,201] com.google.inject.internal.util.Stopwatch: Static member injection: 9ms\nDEBUG [2016-08-03 21:09:46,204] com.google.inject.internal.util.Stopwatch: Instance injection: 3ms\nDEBUG [2016-08-03 21:09:46,427] com.google.inject.internal.util.Stopwatch: Preloading singletons: 223ms\n\n\n\n\n\n\nNote\n\n\n'Preloading singletons' line will be logged \nlong after\n other guice log messages, so search it at the end of your startup log.",
            "title": "Diagnostic"
        },
        {
            "location": "/guide/diagnostic/#diagnostic-info",
            "text": "During startup guicey records startup metrics and remembers all details of configuration process. \nAll this information is available through  GuiceyConfigurationInfo  bean in guice context.",
            "title": "Diagnostic info"
        },
        {
            "location": "/guide/diagnostic/#diagnostic-service",
            "text": "Default diagnostic info rendering is provided to assist configuration problems resolution and better guicey internals understanding.  The simplest way to enable diagnostic reporting is using bundle  .printDiagnosticInfo()  option. \nThis registers  DiagnosticBundle  with default reporting configuration. \nBundle could be registered directly in order to customize output.   Tip  You can use diagnostic logs with  lifecycle phases logging \nand  configuration bindings report   When  .printDiagnosticInfo()  enabled, the following kind of logs will be printed after server startup:  INFO  [2016-08-01 21:22:50,898] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Startup stats = \n\n    GUICEY started in 453.3 ms\n    \u2502   \n    \u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)\n    \u2502   \n    \u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands\n    \u2502   \n    \u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed\n    \u2502   \n    \u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms\n    \u2502   \n    \u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs\n    \u2502   \n    \u2514\u2500\u2500 [1,1%] remaining 5 ms\n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Options = \n\n    Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]                 \n\nINFO  [2016-08-01 21:22:50,901] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN, GUICE_ENABLED\n\n\n    BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP\n\n\n    INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN\n\n\n    GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceBootstrapModule         (r.v.d.guice.module)       \n\nINFO  [2016-08-01 21:22:50,909] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       \n    \u251c\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     \n    \u251c\u2500\u2500 module     GuiceBootstrapModule         (r.v.d.guice.module)       \n    \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n    \u2502   \n    \u251c\u2500\u2500 Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED\n    \u2502   \u251c\u2500\u2500 module     FooBundleModule              (r.v.d.g.d.s.bundle)       \n    \u2502   \u251c\u2500\u2500 -disable   ManagedInstaller             (r.v.d.g.m.i.feature)      \n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n    \u2502       \u2514\u2500\u2500 module     FooModule                    (r.v.d.g.d.s.features)     *IGNORED\n    \u2502   \n    \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n    \u2502   \u251c\u2500\u2500 extension  HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n    \u2502   \u2514\u2500\u2500 module     HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n    \u2502   \n    \u251c\u2500\u2500 DiagnosticBundle             (r.v.d.g.m.c.debug)        \n    \u2502   \u2514\u2500\u2500 module     DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n    \u2502   \n    \u251c\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     *IGNORED\n    \u2502   \u2514\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n    \u2502   \n    \u251c\u2500\u2500 BUNDLES LOOKUP\n    \u2502   \u251c\u2500\u2500 HK2DebugBundle               (r.v.d.g.m.j.debug)        *IGNORED\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n    \u2502       \u2514\u2500\u2500 module     GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n    \u2502   \n    \u2514\u2500\u2500 CLASSPATH SCAN\n        \u2514\u2500\u2500 extension  FooResource                  (r.v.d.g.d.s.features)    Default reporting contains 4 sections:   How guicey spent time  What options used  What was configured  From where configuration items come from",
            "title": "Diagnostic service"
        },
        {
            "location": "/guide/diagnostic/#timings",
            "text": "",
            "title": "Timings"
        },
        {
            "location": "/guide/diagnostic/#startup-timings",
            "text": "GUICEY started in 453.3 ms  Overall guicey time measured: GuiceBundle methods plus part of HK2 configuration time (HK2 started after bundle).\nAll items below represent guicey time detalization. Items always detail time of direct parent.  Most of this time actually spent on class loading. For example, report above represent  test  direct execution. \nBut when this test executed as part of suit time become   GUICEY started in 52.95 ms  because most classes were pre-loaded by other tests.",
            "title": "Startup timings"
        },
        {
            "location": "/guide/diagnostic/#classpath-scan",
            "text": "\u251c\u2500\u2500 [0,88%] CLASSPATH scanned in 4.282 ms\n    \u2502   \u251c\u2500\u2500 scanned 5 classes\n    \u2502   \u2514\u2500\u2500 recognized 4 classes (80% of scanned)  Classpath scan performed just once. Represents only time spent resolving all classes in configured packages. Guicey will later use this resolved classes to search commands (if enabled), installers and extensions.   scanned 5 classes  means that 5 classed were found (overall) in configured packages.  recognized 4 classes  Show effectiveness of classpath scanning (how many classes were actually used as installer, extension or command).  NOTE: classpath scan time will be obviously bigger for larger classes count. But most of this time are actually class loading time. If you use all these classes then they will be loaded in any case. If you disable classpath scan to save time then this time move to other some place (for example, to injector creation).",
            "title": "Classpath scan"
        },
        {
            "location": "/guide/diagnostic/#commands",
            "text": "\u251c\u2500\u2500 [4,2%] COMMANDS processed in 19.10 ms\n    \u2502   \u2514\u2500\u2500 registered 2 commands  Commands time includes time spent on commands search (in classes from classpath scan; if enabled .searchCommands()) and calling .injectMemebers on configured environment commands (last part is always performed, but it's very fast so most likely commands section will not appear if .searchCommands() is not enabled)",
            "title": "Commands"
        },
        {
            "location": "/guide/diagnostic/#bundles",
            "text": "\u251c\u2500\u2500 [6,4%] BUNDLES processed in 29.72 ms\n    \u2502   \u251c\u2500\u2500 2 resolved in 8.149 ms\n    \u2502   \u2514\u2500\u2500 6 processed  Bundles time includes bundles lookup time (if not .disableBundleLookup()), dropwizard bunles lookup (if .configureFromDropwizardBundles()) and bundles execution.  2 resolved in 8.149 ms  indicated bundles resolved with guicey bundle lookup or from dropwizard bundles. 6 processed  - overall processed bundles (all registered bundles, including just resolved).",
            "title": "Bundles"
        },
        {
            "location": "/guide/diagnostic/#injector",
            "text": "\u251c\u2500\u2500 [86%] INJECTOR created in 390.3 ms\n    \u2502   \u251c\u2500\u2500 installers prepared in 13.79 ms\n    \u2502   \u2502   \n    \u2502   \u251c\u2500\u2500 extensions recognized in 9.259 ms\n    \u2502   \u2502   \u251c\u2500\u2500 using 11 installers\n    \u2502   \u2502   \u2514\u2500\u2500 from 7 classes\n    \u2502   \u2502   \n    \u2502   \u2514\u2500\u2500 3 extensions installed in 4.188 ms  All installers and extensions operations (except jersey related features) performed inside of guice module and so included into overall injector creation time.  installers prepared in 13.79 ms  include installers search in classpath (if scan enabled), instantiation and preparing for usage (remove duplicates, sort).  extensions recognized in 9.259 ms  - all manually configured extensions and all classes from classpath scan ( from 7 classes ) are recognized by all registered installers ( using 11 installers ) using installer match method. Recognized installers bound to guice context (or custom action performed for binding installers).  3 extensions installed in 4.188 ms  - all recognized extensions are installed with installers install methods.   Note  Most time of injector creation is internal guice logic. You can enable guice logs to see more details (see below)",
            "title": "Injector"
        },
        {
            "location": "/guide/diagnostic/#hk2",
            "text": "\u251c\u2500\u2500 [1,3%] HK2 bridged in 6.583 ms\n    \u2502   \u251c\u2500\u2500 using 2 jersey installers\n    \u2502   \u2514\u2500\u2500 2 jersey extensions installed in 660.9 \u03bcs  Jersey starts after dropwizard bundles processing and so after GuiceBundle execution. This time is tracked as (overall) guicey time. Here guicey register required HK2 bindings and (some HK2 beans in guice) and executes jersey installers (installers implement JerseyInstaller) to process jersey specific features. For example, all resources and jersey extensions installed here (because requires HK2 specific bindings).  Note that installation time ( 2 jersey extensions installed in 660.9 \u03bcs ) is so tiny just because empty resources (without methods) were used. In real application installation time will be bigger.",
            "title": "HK2"
        },
        {
            "location": "/guide/diagnostic/#remaining",
            "text": "\u2514\u2500\u2500 [1,1%] remaining 5 ms  Represent not explicitly tracked time, spent by guicey for other small operations. Shown on tree to indicate that all major parts were shown.",
            "title": "Remaining"
        },
        {
            "location": "/guide/diagnostic/#used-options",
            "text": "Shows all set or requested (by application logic) options. If you use your own options here they will also be printed.      Guicey                    (r.v.dropwizard.guice.GuiceyOptions)\n        ScanPackages                   = [ru.vyarus.dropwizard.guice.diagnostic.support.features] *CUSTOM\n        SearchCommands                 = true                           *CUSTOM\n        UseCoreInstallers              = true                           \n        ConfigureFromDropwizardBundles = false                          \n        InjectorStage                  = PRODUCTION                     \n        GuiceFilterRegistration        = [REQUEST]       Used markers:\n* CUSTOM - option value set by user\n* NOT_USED - option was set by user but never used  Not used marker just indicated that option is \"not yet\" used. Options may be consumed lazilly by application logic, so\nit is possible that its not used at reporting time. There is no such cases with guicey options, but may be with your custom options (it all depends on usage scenario).",
            "title": "Used options"
        },
        {
            "location": "/guide/diagnostic/#configuration-diagnostic-info",
            "text": "Section intended to compactly show all configuration (to quickly see what was configured).  This and the next sections used condensed package notion:  CoreInstallersBundle         (r.v.d.g.m.installer)      Assumed that all classes in application will be uniquely identifiable by name and package info shown just to be able to \nunderstand exact class location. Logback shrinker used.  Report also indicates duplicate registrations by REG(N) marker, where N - amount of installations \n(ignored installations will be visible in configuration tree). Counted:   item registration in different places (e.g. different bundles)  duplicate registrations in simgle place (e.g.  .extensions(MyExt.class, MyExt.class) )",
            "title": "Configuration diagnostic info"
        },
        {
            "location": "/guide/diagnostic/#general",
            "text": "All configuration items (commands, modules, installers, extension, bundles) are identified by class. Duplicate entities are not allowed and simply ignored.  For example, if extension registered manually and by classpath scan then it will be registered once, but internally guicey will remember both configuration sources.  In contrast to other items, bundles and modules are registered by instance, but still uniqueness is checked by type: only first instance registered and other instances considered as duplicate.",
            "title": "General"
        },
        {
            "location": "/guide/diagnostic/#commands_1",
            "text": "COMMANDS = \n        Cli                          (r.v.d.g.d.s.features)     *SCAN\n        EnvCommand                   (r.v.d.g.d.s.features)     *SCAN,GUICE_ENABLED  Shows commands resolved with classpath scan (enabled with .searchCommands()).  The following markers used:   SCAN - item from classpath scan (always)  GUICE_ENABLED - marks environment command, which could contain guice injections (other commands simply doesn't trigger application run and so injector never starts)",
            "title": "Commands"
        },
        {
            "location": "/guide/diagnostic/#bundles_1",
            "text": "BUNDLES = \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n        Foo2Bundle                   (r.v.d.g.d.s.bundle)       \n            FooBundleRelative2Bundle     (r.v.d.g.d.s.bundle)       \n        HK2DebugBundle               (r.v.d.g.m.j.debug)        *LOOKUP, REG(2)\n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     *LOOKUP  All registered bundles are shown as a tree (to indicate transitive bundles).  The following markers used:   LOOKUP - bundle resolved with bundle lookup mechanism  DW - bundle recognized from registered dropwizard bundle",
            "title": "Bundles"
        },
        {
            "location": "/guide/diagnostic/#installers-and-extensions",
            "text": "INSTALLERS and EXTENSIONS in processing order = \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) *REG(2)\n            HK2DebugFeature              (r.v.d.g.m.j.d.service)    \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n            FooBundleResource            (r.v.d.g.d.s.bundle)       *REG(3)\n            FooResource                  (r.v.d.g.d.s.features)     *SCAN  Shows used installers (only installers which install extensions) and installed extensions.   Both installers and extensions are shown in the processing order (sorted according to @Order annotations).  The following markers used:   SCAN - item from classpath scan (even if extension or installer were registered manually also to indicate item presence in classpath scan)  LAZY - extensions annotated with  @LazyBinding  HK2 - extension annotated with  @HK2Managed  HOOK - registered by  configuration hook",
            "title": "Installers and extensions"
        },
        {
            "location": "/guide/diagnostic/#modules",
            "text": "GUICE MODULES = \n        FooModule                    (r.v.d.g.d.s.features)     *REG(2)\n        FooBundleModule              (r.v.d.g.d.s.bundle)       \n        HK2DebugModule               (r.v.d.g.m.j.d.HK2DebugBundle) \n        DiagnosticModule             (r.v.d.g.m.c.d.DiagnosticBundle) \n        GRestrictModule              (r.v.d.g.s.u.GuiceRestrictedConfigBundle) \n        GuiceBootstrapModule         (r.v.d.guice.module)    All registered guice modules.",
            "title": "Modules"
        },
        {
            "location": "/guide/diagnostic/#configuration-context-tree",
            "text": "Configuration tree is useful to understand from where configuration items come from.  Installer disables are shown like:      \u251c\u2500\u2500 -disable   LifeCycleInstaller           (r.v.d.g.m.i.feature)   Duplicate registrations (ignored by guicey) are shown like:      \u2502   \u251c\u2500\u2500 extension  FooBundleResource            (r.v.d.g.d.s.bundle)       *IGNORED  If number in configuration report (e.g.REG(3)) doesn't match registration appearances, then item registered\nmultiple times in one of this places.  Note that CoreInstallersBundle are always below all other bundles. This is because it always registered last \n(to be able to disable it's registration). It doesn't affect anything other than reporting (because bundles order does \nnot change anything except this tree).",
            "title": "Configuration context tree"
        },
        {
            "location": "/guide/diagnostic/#re-using",
            "text": "Diagnostic info rendering may be used for custom rendering (showing in web page or some other staff).\nRendering is performed with 3 beans, available for injection (when bundle registered):   StatsRenderer  OptionsRenderer  DiagnosticRenderer  ContextTreeRenderer      Note  Renderers are also available in  event objects  (for events fired after injection creation)",
            "title": "Re-using"
        },
        {
            "location": "/guide/diagnostic/#installers-mode",
            "text": "There is a special option in GuiceBundle  .printAvailableInstallers()  for printing only installers information. \nIt also use DiagnosticBundle, but with different configuration.    Warning  Both options can't be used together (but it should never be required as they serve different purposes).   Example output:  INFO  [2016-08-22 00:49:33,557] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration diagnostic info = \n\n    INSTALLERS in processing order = \n        lifecycle            (r.v.d.g.m.i.f.LifeCycleInstaller)     \n        managed              (r.v.d.g.m.i.feature.ManagedInstaller) \n        jerseyfeature        (r.v.d.g.m.i.f.j.JerseyFeatureInstaller) \n        jerseyprovider       (r.v.d.g.m.i.f.j.p.JerseyProviderInstaller) \n        resource             (r.v.d.g.m.i.f.j.ResourceInstaller)    \n        eagersingleton       (r.v.d.g.m.i.f.e.EagerSingletonInstaller) \n        healthcheck          (r.v.d.g.m.i.f.h.HealthCheckInstaller) \n        task                 (r.v.d.g.m.i.feature.TaskInstaller)    \n        plugin               (r.v.d.g.m.i.f.plugin.PluginInstaller) \n        webservlet           (r.v.d.g.m.i.f.w.WebServletInstaller)  \n        webfilter            (r.v.d.g.m.i.f.web.WebFilterInstaller) \n        weblistener          (r.v.d.g.m.i.f.w.l.WebListenerInstaller) \n\nINFO  [2016-08-22 00:49:33,563] ru.vyarus.dropwizard.guice.module.context.debug.report.DiagnosticReporter: Configuration context tree = \n\n    APPLICATION\n    \u2502   \n    \u251c\u2500\u2500 WebInstallersBundle          (r.v.d.g.m.installer)      \n    \u2502   \u251c\u2500\u2500 installer  WebFilterInstaller           (r.v.d.g.m.i.f.web)        \n    \u2502   \u251c\u2500\u2500 installer  WebServletInstaller          (r.v.d.g.m.i.f.web)        \n    \u2502   \u2514\u2500\u2500 installer  WebListenerInstaller         (r.v.d.g.m.i.f.w.listener) \n    \u2502   \n    \u2514\u2500\u2500 CoreInstallersBundle         (r.v.d.g.m.installer)      \n        \u251c\u2500\u2500 installer  LifeCycleInstaller           (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  ManagedInstaller             (r.v.d.g.m.i.feature)      \n        \u251c\u2500\u2500 installer  JerseyFeatureInstaller       (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  JerseyProviderInstaller      (r.v.d.g.m.i.f.j.provider) \n        \u251c\u2500\u2500 installer  ResourceInstaller            (r.v.d.g.m.i.f.jersey)     \n        \u251c\u2500\u2500 installer  EagerSingletonInstaller      (r.v.d.g.m.i.f.eager)      \n        \u251c\u2500\u2500 installer  HealthCheckInstaller         (r.v.d.g.m.i.f.health)     \n        \u251c\u2500\u2500 installer  TaskInstaller                (r.v.d.g.m.i.feature)      \n        \u2514\u2500\u2500 installer  PluginInstaller              (r.v.d.g.m.i.f.plugin)        Important  Comparing to complete diagnostic, it shows all installers ( even not used ). \nIn diagnostic reporting not used installers are hidden, because usually it means they are not needed.",
            "title": "Installers mode"
        },
        {
            "location": "/guide/diagnostic/#guice-injector-creation-timings",
            "text": "You will see in guicey timings that almost all time spent creating guice injector. \nTo see some guice internal timings enable guice debug logs:  logging:\n  loggers:\n    com.google.inject.internal.util: DEBUG  Logs will be something like this:  DEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Module execution: 272ms\nDEBUG [2016-08-03 21:09:45,963] com.google.inject.internal.util.Stopwatch: Interceptors creation: 1ms\nDEBUG [2016-08-03 21:09:45,965] com.google.inject.internal.util.Stopwatch: TypeListeners & ProvisionListener creation: 2ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Scopes creation: 1ms\nDEBUG [2016-08-03 21:09:45,966] com.google.inject.internal.util.Stopwatch: Converters creation: 0ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Binding creation: 26ms\nDEBUG [2016-08-03 21:09:45,992] com.google.inject.internal.util.Stopwatch: Module annotated method scanners creation: 0ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Private environment creation: 1ms\nDEBUG [2016-08-03 21:09:45,993] com.google.inject.internal.util.Stopwatch: Injector construction: 0ms\nDEBUG [2016-08-03 21:09:46,170] com.google.inject.internal.util.Stopwatch: Binding initialization: 177ms\nDEBUG [2016-08-03 21:09:46,171] com.google.inject.internal.util.Stopwatch: Binding indexing: 1ms\nDEBUG [2016-08-03 21:09:46,172] com.google.inject.internal.util.Stopwatch: Collecting injection requests: 1ms\nDEBUG [2016-08-03 21:09:46,179] com.google.inject.internal.util.Stopwatch: Binding validation: 7ms\nDEBUG [2016-08-03 21:09:46,183] com.google.inject.internal.util.Stopwatch: Static validation: 4ms\nDEBUG [2016-08-03 21:09:46,191] com.google.inject.internal.util.Stopwatch: Instance member validation: 8ms\nDEBUG [2016-08-03 21:09:46,192] com.google.inject.internal.util.Stopwatch: Provider verification: 1ms\nDEBUG [2016-08-03 21:09:46,201] com.google.inject.internal.util.Stopwatch: Static member injection: 9ms\nDEBUG [2016-08-03 21:09:46,204] com.google.inject.internal.util.Stopwatch: Instance injection: 3ms\nDEBUG [2016-08-03 21:09:46,427] com.google.inject.internal.util.Stopwatch: Preloading singletons: 223ms   Note  'Preloading singletons' line will be logged  long after  other guice log messages, so search it at the end of your startup log.",
            "title": "Guice injector creation timings"
        },
        {
            "location": "/guide/events/",
            "text": "Guicey lifecycle events\n\u00b6\n\n\nGuicey broadcast lifecycle events in all major points. Each event \nprovides access to all available state at this point.\n\n\nEvents could be used for configuration analysis or to add some special post processing\n(e.g. post process modules before injector creation). \n\n\n\n\nImportant\n\n\nEvent listeners could not modify configuration itself\n(can't add new extensions, installers, bundles or disable anything).   \n\n\n\n\nDebug\n\u00b6\n\n\nUse \nbundle.printLifecyclePhases()\n to see lifecycle events in logs.\nCould be very helpful during problems investigation. Also, it shows startup timer to easily see where most startup time is spent.\n\n\nExample output:\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.008 ]____________________________________________________/  1 hooks processed  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.104 ]____________________________________________________/  2 commands installed  \\____\n\nINFO  [2018-06-15 04:09:56,978] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /\nINFO  [2018-06-15 04:09:56,981] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.881 ]____________________________________________________/  Configured from 3 (-1) GuiceyBundles  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.886 ]____________________________________________________/  Staring guice with 3/0 (-1) modules...  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.980 ]____________________________________________________/  8 (-1) installers initialized  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:01.008 ]____________________________________________________/  13 (-1) extensions found  \\____\n\n...\n\n\n\n\nNote that \n(-1)\n in some events means disabled items and actual displayed count did not count disabled items.\nUse detailed output (\nbundle.printLifecyclePhasesDetailed()\n) to see more details. \n\n\nExample detailed output (for one event):\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.893 ]____________________________________________________/  Configured from 3 (-1) GuiceyBundles  \\____\n\n    bundles = \n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n\n    disabled = \n        HK2DebugBundle               (r.v.d.g.m.j.debug)      \n\n\n\n\n\n\nImportant\n\n\nLifecycle logs are printed to system out instead of logger because logger is not yet initialized on first events. \nAnyway, these logs intended to be used for problems resolution and so console only output should not be a problem. \n\n\n\n\nRegistration\n\u00b6\n\n\nEvents listener could be registered only through main bundle: \n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nlisten\n(\nnew\n \nMyListener\n(),\n \nnew\n \nMyOtherListener\n())\n\n    \n...\n\n    \n.\nbuild\n()\n\n\n\n\n\nAll events are listed in \nGuiceyLifecycle\n enum in execution order. \n\n\nEvent listener could implement generic event interface \nGuiceyLifecycleListener\n and use\nenum to differentiate required events:\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nGuiceyLifecycleListener\n \n{\n\n\n    \npublic\n \nvoid\n \nonEvent\n(\nGuiceyLifecycleEvent\n \nevent\n)\n \n{\n\n        \nswitch\n \n(\nevent\n.\ngetType\n())\n \n{\n\n            \ncase\n \nInjectorCreation\n:\n\n                \nInjectorCreationEvent\n \ne\n \n=\n \n(\nInjectorCreationEvent\n)\n \nevent\n;\n\n                \n...\n\n        \n}\n\n    \n}\n\n\n}\n  \n\n\n\n\nOr use \nGuiceyLifecycleAdapter\n adapter and override only required methods:\n\n\npublic\n \nclass\n \nMyListener\n \nextends\n \nGuiceyLifecycleAdapter\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \ninjectorCreation\n(\nfinal\n \nInjectorCreationEvent\n \nevent\n)\n \n{\n\n           \n...\n\n    \n}\n        \n\n}\n\n\n\n\n\nBundles\n\u00b6\n\n\nEvent listeners could also be registered in guicey bundle, but not all events will be received by such events\n(as bundles processing is not first lifecycle phase).\n\n\nAslo, such bundles can't be configuration hooks (because all hooks are already processed at this point). \n\n\nContext modification\n\u00b6\n\n\nEvent listeners are not allowed to modify configuration, only observe it and, if required, \npost process instances (modules, bundles etc).\n\n\nBut, if listener needs to register any additional extension it can implement \nGuiceyConfigrator\n interface\nto be automatically registered as configuration hook:\n\n\npublic\n \nclass\n \nMyDebuggingListener\n \nextends\n \nGuiceyLifecycleAdapter\n \n                                  \nimplements\n \nGuiceyConfigurationHook\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nconfigure\n(\nGuiceBundle\n.\nBuilder\n \nbuilder\n)\n \n{\n\n        \nbuilder\n\n            \n.\nextensions\n(\nDebugExtension\n.\nclass\n)\n\n            \n.\nbundles\n(\nnew\n \nDebugBundle\n())\n\n            \n...\n        \n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \ninjectorCreation\n(\nfinal\n \nInjectorCreationEvent\n \nevent\n)\n \n{\n\n           \n...\n\n    \n}\n        \n\n}\n\n\n\n\n\nEvent structure\n\u00b6\n\n\nAll events inherit from base event classes. Event classes are extending each other:\nas initialisation phases go more objects become available. So you can access any available (at this point) object\nfrom event instance. \n\n\n\n\n\n\n\n\nBase event\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGuiceyLifecycleEvent\n\n\nThe lowest event type. Initialization dropwizard phase. Provides access to event type and options.\n\n\n\n\n\n\nRunPhaseEvent\n\n\nDropwizard run phase. Available Bootstrap, Configuration, ConfigurationTree, Environment. Shortcut for configuration bindings report renderer\n\n\n\n\n\n\nInjectorPhaseEvent\n\n\nGuice injector created. Available injector and GuiceyCofigurationInfo (guicey configuration). Shortcuts for configuration reports renderer\n\n\n\n\n\n\nHK2PhaseEvent\n\n\nJersey starting. ServiceLocator available.\n\n\n\n\n\n\n\n\nEvents\n\u00b6\n\n\nNote that some events may not been called - (?).\n\n\n\n\n\n\n\n\nEvent\n\n\nDescription\n\n\nPossible usage\n\n\n\n\n\n\n\n\n\n\nDropwizard initialization phase\n\n\n\n\n\n\n\n\n\n\nHooksProcessed(?)\n\n\nCalled after all registered GuiceyConfigurationHook processing\n\n\nOnly for info\n\n\n\n\n\n\nInitialization\n\n\nCalled after GuiceBundle initialization. If commands search is enabled then all found commands will be provided in event.\n\n\nConvenient moment to apply registrations into dropwizard Bootstrap object.\n\n\n\n\n\n\nDropwizard run phase\n\n\n\n\n\n\n\n\n\n\nBeforeRun\n\n\nMeta event, called before guicey configuration just to indicate first point where Environment, Configuration and introspected configuration are available\n\n\nFor example, used by \nbundle.printConfigurationBindings()\n to print configuration bindings before injector start (help with missed bindings debug)\n\n\n\n\n\n\nBundlesFromDwResolved(?)\n\n\nCalled if configuration from dw bundles enabled and at least one bundle recognized  (note: some of these bundles could be actually disabled and not used further)\n\n\nLogging or post processing of recognized bundles.\n\n\n\n\n\n\nBundlesFromLookupResolved(?)\n\n\nCalled if at least one bundle recognized using bundles lookup (note: some of these bundles could be disabled and not used further)\n\n\nLogging or post processing of found bundles.\n\n\n\n\n\n\nBundlesResolved\n\n\nCalled to indicate all top-level bundles (registered manually, from lookup and recognized dropwizard bundles). Called even if no bundles registered to indicate configuration state.\n\n\nLogging or post processing of top-level bundles.\n\n\n\n\n\n\nBundlesProcessed(?)\n\n\nCalled after bundles processing. Note that bundles could register other bundles and so resulted list of installed bundles could be bigger (than in resolution event). Called only when at lest one bundle registered and not disabled.\n\n\nLogging of all used bundles or storing bundles list for modules (for example).\n\n\n\n\n\n\nInjectorCreation\n\n\nCalled just before guice injector creation. Provides all configured modules (main and override) and all disabled modules. Always called, event if no modules registered.\n\n\nLogging or post processing modules (can't add or remove modules, but can manipulate module instance)\n\n\n\n\n\n\nInstallersResolved\n\n\nCalled when installers resolved (from classpath scan, if enabled) and initialized. Injector is under creation at that moment.\n\n\nLogging or post processing of installers (e.g. set list of modules or bundles to some installer)\n\n\n\n\n\n\nExtensionsResolved\n\n\nCalled when all extensions detected (from classpath scan, if enabled). Injector is under creation at that moment.\n\n\nLogging or remembering list of all enabled extensions (classes only)\n\n\n\n\n\n\nGuice injector created\n\n\n\n\n\n\n\n\n\n\nExtensionsInstalledBy\n\n\nCalled when installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty). Note: jersey extensions are processed later.\n\n\nLogging of installed extensions. Extension instance could be obtained from injector and post processed.\n\n\n\n\n\n\nExtensionsInstalled(?)\n\n\nCalled after all installers install related extensions. Not called when no installed extensions (nothing registered or all disabled)\n\n\nLogging or extensions post processing\n\n\n\n\n\n\nApplicationRun\n\n\nCalled when guice injector started, extensions installed (except jersey extensions because neither jersey nor jetty is't start yet) and all guice singletons initialized. Point is just before \nApplication.run\n method.\n\n\nIdeal point for jersey and jetty listeners installation (with shortcut methods in event).\n\n\n\n\n\n\nJersey initialization (HK2)\n\n\n\n\n\n\n\n\n\n\nHK2Configuration\n\n\nHK2 context starting. Both jersey and jetty are starting.\n\n\nFirst point where ServiceLocator become available\n\n\n\n\n\n\nHK2ExtensionsInstalledBy\n\n\nCalled when jersey installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty)\n\n\nLogging of installed extensions. Extension instance could be obtained from injector/locator and post processed.\n\n\n\n\n\n\nHK2ExtensionsInstalled(?)\n\n\nCalled after all jersey installers install related extensions. Not called when no installed extensions (nothing registered or all disabled). At this point HK2 is not completely started yet (and so extensions)\n\n\nLogging or extensions post processing",
            "title": "Lifecycle events"
        },
        {
            "location": "/guide/events/#guicey-lifecycle-events",
            "text": "Guicey broadcast lifecycle events in all major points. Each event \nprovides access to all available state at this point.  Events could be used for configuration analysis or to add some special post processing\n(e.g. post process modules before injector creation).    Important  Event listeners could not modify configuration itself\n(can't add new extensions, installers, bundles or disable anything).",
            "title": "Guicey lifecycle events"
        },
        {
            "location": "/guide/events/#debug",
            "text": "Use  bundle.printLifecyclePhases()  to see lifecycle events in logs.\nCould be very helpful during problems investigation. Also, it shows startup timer to easily see where most startup time is spent.  Example output:                                                                           \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.008 ]____________________________________________________/  1 hooks processed  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.104 ]____________________________________________________/  2 commands installed  \\____\n\nINFO  [2018-06-15 04:09:56,978] io.dropwizard.server.DefaultServerFactory: Registering jersey handler with root path prefix: /\nINFO  [2018-06-15 04:09:56,981] io.dropwizard.server.DefaultServerFactory: Registering admin handler with root path prefix: /\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.881 ]____________________________________________________/  Configured from 3 (-1) GuiceyBundles  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.886 ]____________________________________________________/  Staring guice with 3/0 (-1) modules...  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.980 ]____________________________________________________/  8 (-1) installers initialized  \\____\n\n\n\n                                                                         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:01.008 ]____________________________________________________/  13 (-1) extensions found  \\____\n\n...  Note that  (-1)  in some events means disabled items and actual displayed count did not count disabled items.\nUse detailed output ( bundle.printLifecyclePhasesDetailed() ) to see more details.   Example detailed output (for one event):                                                                           \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n__[ 00:00:00.893 ]____________________________________________________/  Configured from 3 (-1) GuiceyBundles  \\____\n\n    bundles = \n        DiagnosticBundle             (r.v.d.g.m.c.debug)        \n        GuiceRestrictedConfigBundle  (r.v.d.g.support.util)     \n        CoreInstallersBundle         (r.v.d.g.m.installer)      \n\n    disabled = \n        HK2DebugBundle               (r.v.d.g.m.j.debug)         Important  Lifecycle logs are printed to system out instead of logger because logger is not yet initialized on first events. \nAnyway, these logs intended to be used for problems resolution and so console only output should not be a problem.",
            "title": "Debug"
        },
        {
            "location": "/guide/events/#registration",
            "text": "Events listener could be registered only through main bundle:   GuiceBundle . builder () \n     . listen ( new   MyListener (),   new   MyOtherListener ()) \n     ... \n     . build ()   All events are listed in  GuiceyLifecycle  enum in execution order.   Event listener could implement generic event interface  GuiceyLifecycleListener  and use\nenum to differentiate required events:  public   class   MyListener   implements   GuiceyLifecycleListener   { \n\n     public   void   onEvent ( GuiceyLifecycleEvent   event )   { \n         switch   ( event . getType ())   { \n             case   InjectorCreation : \n                 InjectorCreationEvent   e   =   ( InjectorCreationEvent )   event ; \n                 ... \n         } \n     }  }     Or use  GuiceyLifecycleAdapter  adapter and override only required methods:  public   class   MyListener   extends   GuiceyLifecycleAdapter   { \n\n     @Override \n     protected   void   injectorCreation ( final   InjectorCreationEvent   event )   { \n            ... \n     }          }",
            "title": "Registration"
        },
        {
            "location": "/guide/events/#bundles",
            "text": "Event listeners could also be registered in guicey bundle, but not all events will be received by such events\n(as bundles processing is not first lifecycle phase).  Aslo, such bundles can't be configuration hooks (because all hooks are already processed at this point).",
            "title": "Bundles"
        },
        {
            "location": "/guide/events/#context-modification",
            "text": "Event listeners are not allowed to modify configuration, only observe it and, if required, \npost process instances (modules, bundles etc).  But, if listener needs to register any additional extension it can implement  GuiceyConfigrator  interface\nto be automatically registered as configuration hook:  public   class   MyDebuggingListener   extends   GuiceyLifecycleAdapter  \n                                   implements   GuiceyConfigurationHook   { \n\n     @Override \n     public   void   configure ( GuiceBundle . Builder   builder )   { \n         builder \n             . extensions ( DebugExtension . class ) \n             . bundles ( new   DebugBundle ()) \n             ...         \n     } \n\n     @Override \n     protected   void   injectorCreation ( final   InjectorCreationEvent   event )   { \n            ... \n     }          }",
            "title": "Context modification"
        },
        {
            "location": "/guide/events/#event-structure",
            "text": "All events inherit from base event classes. Event classes are extending each other:\nas initialisation phases go more objects become available. So you can access any available (at this point) object\nfrom event instance.      Base event  Description      GuiceyLifecycleEvent  The lowest event type. Initialization dropwizard phase. Provides access to event type and options.    RunPhaseEvent  Dropwizard run phase. Available Bootstrap, Configuration, ConfigurationTree, Environment. Shortcut for configuration bindings report renderer    InjectorPhaseEvent  Guice injector created. Available injector and GuiceyCofigurationInfo (guicey configuration). Shortcuts for configuration reports renderer    HK2PhaseEvent  Jersey starting. ServiceLocator available.",
            "title": "Event structure"
        },
        {
            "location": "/guide/events/#events",
            "text": "Note that some events may not been called - (?).     Event  Description  Possible usage      Dropwizard initialization phase      HooksProcessed(?)  Called after all registered GuiceyConfigurationHook processing  Only for info    Initialization  Called after GuiceBundle initialization. If commands search is enabled then all found commands will be provided in event.  Convenient moment to apply registrations into dropwizard Bootstrap object.    Dropwizard run phase      BeforeRun  Meta event, called before guicey configuration just to indicate first point where Environment, Configuration and introspected configuration are available  For example, used by  bundle.printConfigurationBindings()  to print configuration bindings before injector start (help with missed bindings debug)    BundlesFromDwResolved(?)  Called if configuration from dw bundles enabled and at least one bundle recognized  (note: some of these bundles could be actually disabled and not used further)  Logging or post processing of recognized bundles.    BundlesFromLookupResolved(?)  Called if at least one bundle recognized using bundles lookup (note: some of these bundles could be disabled and not used further)  Logging or post processing of found bundles.    BundlesResolved  Called to indicate all top-level bundles (registered manually, from lookup and recognized dropwizard bundles). Called even if no bundles registered to indicate configuration state.  Logging or post processing of top-level bundles.    BundlesProcessed(?)  Called after bundles processing. Note that bundles could register other bundles and so resulted list of installed bundles could be bigger (than in resolution event). Called only when at lest one bundle registered and not disabled.  Logging of all used bundles or storing bundles list for modules (for example).    InjectorCreation  Called just before guice injector creation. Provides all configured modules (main and override) and all disabled modules. Always called, event if no modules registered.  Logging or post processing modules (can't add or remove modules, but can manipulate module instance)    InstallersResolved  Called when installers resolved (from classpath scan, if enabled) and initialized. Injector is under creation at that moment.  Logging or post processing of installers (e.g. set list of modules or bundles to some installer)    ExtensionsResolved  Called when all extensions detected (from classpath scan, if enabled). Injector is under creation at that moment.  Logging or remembering list of all enabled extensions (classes only)    Guice injector created      ExtensionsInstalledBy  Called when installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty). Note: jersey extensions are processed later.  Logging of installed extensions. Extension instance could be obtained from injector and post processed.    ExtensionsInstalled(?)  Called after all installers install related extensions. Not called when no installed extensions (nothing registered or all disabled)  Logging or extensions post processing    ApplicationRun  Called when guice injector started, extensions installed (except jersey extensions because neither jersey nor jetty is't start yet) and all guice singletons initialized. Point is just before  Application.run  method.  Ideal point for jersey and jetty listeners installation (with shortcut methods in event).    Jersey initialization (HK2)      HK2Configuration  HK2 context starting. Both jersey and jetty are starting.  First point where ServiceLocator become available    HK2ExtensionsInstalledBy  Called when jersey installer installed all related extensions (for each installer) and only for installers actually performed installations (extensions list never empty)  Logging of installed extensions. Extension instance could be obtained from injector/locator and post processed.    HK2ExtensionsInstalled(?)  Called after all jersey installers install related extensions. Not called when no installed extensions (nothing registered or all disabled). At this point HK2 is not completely started yet (and so extensions)  Logging or extensions post processing",
            "title": "Events"
        },
        {
            "location": "/guide/commands/",
            "text": "Dropwizard commands support\n\u00b6\n\n\nGuice injections\n\u00b6\n\n\nGuicey calls \ninjector.injectMembers(command)\n for all registered \nEnvironmentCommand\n's, so you can inject guice beans directly:\n\n\npublic\n \nclass\n \nMyCommand\n \nextends\n \nEnvironmentCommand\n<\nMyConfiguration\n>\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nmyservice\n;\n\n\n    \npublic\n \nMyCommand\n(\nApplication\n \napplication\n)\n \n{\n\n        \nsuper\n(\napplication\n,\n \n\"mycli\"\n,\n \n\"my super useful cli\"\n);\n\n    \n}\n\n\n    \n@Override\n\n        \nprotected\n \nvoid\n \nrun\n(\nEnvironment\n \nenvironment\n,\n \n                             \nNamespace\n \nnamespace\n,\n \n                             \nMyConfiguration\n \nconfiguration\n)\n \nthrows\n \nException\n \n{\n \n            \nmyservice\n.\ndoSomething\n();\n        \n        \n}\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nIt doesn't matter if command was registered manually, by some bundle or with commands search (see below).\n\n\n\n\n\n\nWarning\n\n\nYou can use guice injections only in \nEnvironmentCommand\n's because only these commands start bundles (and so launch guice context creation).\n\n\n\n\nAutomatic installation\n\u00b6\n\n\nAutomatic scan for commands is disabled by default. It could be enabled by: \n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nenableAutoConfig\n(\n\"package.to.scan\"\n)\n\n    \n.\nsearchCommands\n()\n\n\n\n\n\nWhen enabled, all classes extending \nCommand\n are instantiated using default constructor and registered in dropwizard bootstrap object. \n\n\nSimple commands\n\u00b6\n\n\nFor example, if command below would be inside scanned package, then guicey will automatically register it.\n\n\npublic\n \nclass\n \nMyCommand\n \nextends\n \nCommand\n \n{\n\n\n    \npublic\n \nMyCommand\n()\n \n{\n\n        \nsuper\n(\n\"hello\"\n,\n \n\"Prints a greeting\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nrun\n(\nBootstrap\n<?>\n \nbootstrap\n,\n \nNamespace\n \nnamespace\n)\n \nthrows\n \nException\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\"Hello world\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nEnvironment commands\n\u00b6\n\n\n\n\nImportant\n\n\nEnvironmentCommand\n must have constructor with \nApplication\n argument.\n\n\n\n\npublic\n \nclass\n \nSyncCommand\n \nextends\n \nEnvironmentCommand\n<\nAppConfiguration\n>\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nRemoteSynchronizer\n \nsynchronizer\n;\n\n    \n@Inject\n\n    \nprivate\n \nDbManager\n \nmanager\n;\n\n\n    \npublic\n \nSyncCommand\n(\nApplication\n<\nAppConfiguration\n>\n \napplication\n)\n \n{\n\n        \nsuper\n(\napplication\n,\n \n\"sync\"\n,\n \n\"Perform remote synchronization\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nrun\n(\nEnvironment\n \nenvironment\n,\n \n                        \nNamespace\n \nnamespace\n,\n \n                        \nAppConfiguration\n \nconfiguration\n)\n \nthrows\n \nException\n \n{\n\n        \nmanager\n.\nstart\n();\n\n        \ntry\n \n{\n\n            \nsynchronizer\n.\nsynchronize\n();\n\n        \n}\n \nfinally\n \n{\n\n            \nmanager\n.\nstop\n();\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nThis example shows workaround for managed initialization in commnads: \nDbManager\n is some \nManaged\n bean which would run automatically \nin server mode. But commands never call managed objects, so we have to manually start and stop them.",
            "title": "Commands"
        },
        {
            "location": "/guide/commands/#dropwizard-commands-support",
            "text": "",
            "title": "Dropwizard commands support"
        },
        {
            "location": "/guide/commands/#guice-injections",
            "text": "Guicey calls  injector.injectMembers(command)  for all registered  EnvironmentCommand 's, so you can inject guice beans directly:  public   class   MyCommand   extends   EnvironmentCommand < MyConfiguration >   { \n\n     @Inject \n     private   MyService   myservice ; \n\n     public   MyCommand ( Application   application )   { \n         super ( application ,   \"mycli\" ,   \"my super useful cli\" ); \n     } \n\n     @Override \n         protected   void   run ( Environment   environment ,  \n                              Namespace   namespace ,  \n                              MyConfiguration   configuration )   throws   Exception   {  \n             myservice . doSomething ();         \n         }  }    Note  It doesn't matter if command was registered manually, by some bundle or with commands search (see below).    Warning  You can use guice injections only in  EnvironmentCommand 's because only these commands start bundles (and so launch guice context creation).",
            "title": "Guice injections"
        },
        {
            "location": "/guide/commands/#automatic-installation",
            "text": "Automatic scan for commands is disabled by default. It could be enabled by:   GuiceBundle . builder () \n     . enableAutoConfig ( \"package.to.scan\" ) \n     . searchCommands ()   When enabled, all classes extending  Command  are instantiated using default constructor and registered in dropwizard bootstrap object.",
            "title": "Automatic installation"
        },
        {
            "location": "/guide/commands/#simple-commands",
            "text": "For example, if command below would be inside scanned package, then guicey will automatically register it.  public   class   MyCommand   extends   Command   { \n\n     public   MyCommand ()   { \n         super ( \"hello\" ,   \"Prints a greeting\" ); \n     } \n\n     @Override \n     public   void   run ( Bootstrap <?>   bootstrap ,   Namespace   namespace )   throws   Exception   { \n         System . out . println ( \"Hello world\" ); \n     }  }",
            "title": "Simple commands"
        },
        {
            "location": "/guide/commands/#environment-commands",
            "text": "Important  EnvironmentCommand  must have constructor with  Application  argument.   public   class   SyncCommand   extends   EnvironmentCommand < AppConfiguration >   { \n\n     @Inject \n     private   RemoteSynchronizer   synchronizer ; \n     @Inject \n     private   DbManager   manager ; \n\n     public   SyncCommand ( Application < AppConfiguration >   application )   { \n         super ( application ,   \"sync\" ,   \"Perform remote synchronization\" ); \n     } \n\n     @Override \n     protected   void   run ( Environment   environment ,  \n                         Namespace   namespace ,  \n                         AppConfiguration   configuration )   throws   Exception   { \n         manager . start (); \n         try   { \n             synchronizer . synchronize (); \n         }   finally   { \n             manager . stop (); \n         } \n     }  }   This example shows workaround for managed initialization in commnads:  DbManager  is some  Managed  bean which would run automatically \nin server mode. But commands never call managed objects, so we have to manually start and stop them.",
            "title": "Environment commands"
        },
        {
            "location": "/guide/web/",
            "text": "Web features\n\u00b6\n\n\nGuice ServletModule support\n\u00b6\n\n\nBy default, \nGuiceFilter\n is registered for both application and admin contexts. And so request and session scopes will be \nbe available in both contexts. Also it makes injection of request and response objects available with provider (in any bean).\n\n\nTo register servlets and filters for main context use \nServletModule\n, e.g.\n\n\npublic\n \nclass\n \nWebModule\n \nextends\n \nServletModule\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigureServlets\n()\n \n{\n\n        \nfilter\n(\n\"/*\"\n).\nthrough\n(\nMyFilter\n.\nclass\n)\n\n        \nserve\n(\n\"/myservlet\"\n).\nwith\n(\nMyServlet\n.\nclass\n)\n\n    \n}\n\n\n}\n\n\n\n\n\nRequest scoped beans\n\u00b6\n\n\nYou can use request scoped beans in both main and admin contexts. \n\n\n@RequestScoped\n\n\npublic\n \nclass\n \nMyRequestScopedBean\n \n{\n \n...\n \n}\n\n\n\n\n\nTo obtain bean reference use provider:\n\n\nProvider\n<\nMyRequestScopedBean\n>\n \nmyBeanProvider\n;\n\n\n\n\n\nYou can inject request and response objects in any bean:\n\n\nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n\n\nProvider\n<\nHttpServletResponse\n>\n \nresponseProvider\n\n\n\n\n\nLimitations\n\u00b6\n\n\nBy default, \nGuiceFilter\n is registered with \nREQUEST\n dispatcher type. If you need to use other types use option:\n\n\n    \n.\noption\n(\nGuiceyOptions\n.\nGuiceFilterRegistration\n,\n \nEnumSet\n.\nof\n(\nREQUEST\n,\n \nFORWARD\n))\n\n\n\n\n\n\n\nWarning\n\n\nNote that async servlets and filters can't be used with guice servlet module (and so it is impossible to register \nGuiceFilter\n for \nASYNC\n type). \nUse \nweb installers\n for such cases. \n\n\n\n\n\n\nWarning\n\n\nGuiceFilter\n dispatch all requests for filters and servlets registered by \nServletModule\n internally and there may be problems combining servlets from \nServletModule\n\nand filters in main scope.\n\n\n\n\nDisable ServletModule support\n\u00b6\n\n\nIf you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support:\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nnoGuiceFilter\n()\n\n\n\n\nIt will:\n\n\n\n\nAvoid registration of \nGuiceFilter\n in both contexts\n\n\nRemove request and session guice scopes support (because no ServletModule registered)\n\n\nPrevent installation of any \nServletModule\n (error will be thrown indicating duplicate binding)\n\n\nHttpServletRequest\n and \nHttpServletResponse\n still may be injected in resources with \nProvider\n \n(but it will not be possible to use such injections in servlets, filters or any other place)\n\n\n\n\nDisabling saves about ~50ms of startup time. \n\n\nWeb installers\n\u00b6\n\n\nServlet api 3.0 provides \n@WebServlet\n, \n@WebFilter\n and \n@WebListener\n annotations, but they are not recognized in dropwizard\n(because dropwizard does not depend on jersey-annotations module). Web installers recognize this annotations and register guice-managed filters, servlets and listeners \ninstances.\n\n\nWeb installers are disabled by default. To eable:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nuseWebInstallers\n()\n\n\n\n\n\nIt will register \nWebInstallersBundle\n.\n\n\n\n\nWeb installers are not enabled by default, because dropwizard is primarily rest oriented framework and you may not use custom servlets and filters at all\n(so no need to spent time trying to recognize them). Moreover, using standard servlet api annotations may confuse users and so \nit must be user decision to enable such support. Other developers should be guided bu option name and its javadoc (again to avoid confusion, no matter that\nit will work exactly as expected)\n\n\n\n\nDifferences with GuiceServlet module\n\u00b6\n\n\nThere is a difference between using web installers and registering servlets and filters with \nguice servlet module\n.\nGuice servlet module handles registered servlets and filters internally in \nGuiceFilter\n (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\nWeb installers use guice only for filter or servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).  \n\n\nIn many cases, annotations are more convenient way to declare servlet or filter registration comparing to servlet module. \n\n\n\n\nTip\n\n\nUsing annotations you can register async \nservlets\n and \nfilters\n (with annotations \nasyncSupported=true\n option).\nIn contrast, it is impossible to register async with guice servlet module.\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, web installers (servlet, filter, listener) target application context. If you want to install into admin context then use \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextneds\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\nWill install servlet in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextneds\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\nIn example above, servlet registered in both contexts.",
            "title": "Web"
        },
        {
            "location": "/guide/web/#web-features",
            "text": "",
            "title": "Web features"
        },
        {
            "location": "/guide/web/#guice-servletmodule-support",
            "text": "By default,  GuiceFilter  is registered for both application and admin contexts. And so request and session scopes will be \nbe available in both contexts. Also it makes injection of request and response objects available with provider (in any bean).  To register servlets and filters for main context use  ServletModule , e.g.  public   class   WebModule   extends   ServletModule   { \n\n     @Override \n     protected   void   configureServlets ()   { \n         filter ( \"/*\" ). through ( MyFilter . class ) \n         serve ( \"/myservlet\" ). with ( MyServlet . class ) \n     }  }",
            "title": "Guice ServletModule support"
        },
        {
            "location": "/guide/web/#request-scoped-beans",
            "text": "You can use request scoped beans in both main and admin contexts.   @RequestScoped  public   class   MyRequestScopedBean   {   ...   }   To obtain bean reference use provider:  Provider < MyRequestScopedBean >   myBeanProvider ;   You can inject request and response objects in any bean:  Provider < HttpServletRequest >   requestProvider  Provider < HttpServletResponse >   responseProvider",
            "title": "Request scoped beans"
        },
        {
            "location": "/guide/web/#limitations",
            "text": "By default,  GuiceFilter  is registered with  REQUEST  dispatcher type. If you need to use other types use option:       . option ( GuiceyOptions . GuiceFilterRegistration ,   EnumSet . of ( REQUEST ,   FORWARD ))    Warning  Note that async servlets and filters can't be used with guice servlet module (and so it is impossible to register  GuiceFilter  for  ASYNC  type). \nUse  web installers  for such cases.     Warning  GuiceFilter  dispatch all requests for filters and servlets registered by  ServletModule  internally and there may be problems combining servlets from  ServletModule \nand filters in main scope.",
            "title": "Limitations"
        },
        {
            "location": "/guide/web/#disable-servletmodule-support",
            "text": "If you don't use servlet modules (for example, because web installers cover all needs) you can disable guice servlet modules support: GuiceBundle . builder () \n     . noGuiceFilter ()   It will:   Avoid registration of  GuiceFilter  in both contexts  Remove request and session guice scopes support (because no ServletModule registered)  Prevent installation of any  ServletModule  (error will be thrown indicating duplicate binding)  HttpServletRequest  and  HttpServletResponse  still may be injected in resources with  Provider  \n(but it will not be possible to use such injections in servlets, filters or any other place)   Disabling saves about ~50ms of startup time.",
            "title": "Disable ServletModule support"
        },
        {
            "location": "/guide/web/#web-installers",
            "text": "Servlet api 3.0 provides  @WebServlet ,  @WebFilter  and  @WebListener  annotations, but they are not recognized in dropwizard\n(because dropwizard does not depend on jersey-annotations module). Web installers recognize this annotations and register guice-managed filters, servlets and listeners \ninstances.  Web installers are disabled by default. To eable:  GuiceBundle . builder () \n     . useWebInstallers ()   It will register  WebInstallersBundle .   Web installers are not enabled by default, because dropwizard is primarily rest oriented framework and you may not use custom servlets and filters at all\n(so no need to spent time trying to recognize them). Moreover, using standard servlet api annotations may confuse users and so \nit must be user decision to enable such support. Other developers should be guided bu option name and its javadoc (again to avoid confusion, no matter that\nit will work exactly as expected)",
            "title": "Web installers"
        },
        {
            "location": "/guide/web/#differences-with-guiceservlet-module",
            "text": "There is a difference between using web installers and registering servlets and filters with  guice servlet module .\nGuice servlet module handles registered servlets and filters internally in  GuiceFilter  (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\nWeb installers use guice only for filter or servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).    In many cases, annotations are more convenient way to declare servlet or filter registration comparing to servlet module.    Tip  Using annotations you can register async  servlets  and  filters  (with annotations  asyncSupported=true  option).\nIn contrast, it is impossible to register async with guice servlet module.",
            "title": "Differences with GuiceServlet module"
        },
        {
            "location": "/guide/web/#admin-context",
            "text": "By default, web installers (servlet, filter, listener) target application context. If you want to install into admin context then use  @AdminContext  annotation.  For example:   @AdminContext  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extneds   HttpServlet   {   ...   }   Will install servlet in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extneds   HttpServlet   {   ...   }   In example above, servlet registered in both contexts.",
            "title": "Admin context"
        },
        {
            "location": "/guide/test/",
            "text": "Testing\n\u00b6\n\n\nTest support require \nio.dropwizard:dropwizard-testing:1.3.0\n dependency.\n\n\nGeneral test support\n\u00b6\n\n\nConfiguration hooks\n\u00b6\n\n\nGuicey provides \nhooks mechanism\n to be able to modify\napplication configuration in tests.\n\n\nUsing hooks you can disable installers, extensions, guicey bundles\n\nor override guice bindings.\n\n\nIt may also be useful to register additional extensions (e.g. to validate some internal behaviour).\n\n\nExample hook:\n\n\npublic\n \nclass\n \nMyHook\n \nimplements\n \nGuiceyConfigurationHook\n \n{\n\n\n    \npublic\n \nvoid\n \nconfigure\n(\nGuiceBundle\n.\nBuilder\n \nbuilder\n)\n \n{\n\n        \nbuilder\n\n            \n.\ndisableModules\n(\nFeatureXModule\n.\nclass\n)\n\n            \n.\ndisable\n(\ninPackage\n(\n\"com.foo.feature\"\n))\n\n            \n.\nmodulesOverride\n(\nnew\n \nMockDaoModule\n())\n\n            \n.\noption\n(\nMyoptions\n.\nDebugOption\n,\n \ntrue\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nYou can modify \noptions\n in hook and so could enable some custom\ndebug/monitoring options specifically for test.\n\n\n\n\nThere are special spock and junit extensions for hooks registrations.\n\n\nDisables\n\u00b6\n\n\nYou can use hooks to disable all not needed features in test:\n\n\n\n\ninstallers\n \n\n\nextensions\n \n\n\nguice modules\n\n\nguicey bundles\n \n\n\n\n\nThis way you can isolate (as possible) some feature for testing. \n\n\nThe most helpful should be bundles disable (if you use bundles for features grouping)\nand guice modules.\n\n\nUse \npredicate disabling\n.\n\n\n\n\nNote\n\n\nIt is supposed that disabling will be used instead of mocking - you simply remove what\nyou don't need and register replacements, if required.\n\n\n\n\nGuice bindings override\n\u00b6\n\n\nIt is quite common requirement to override bindings for testing. For example, \nyou may want to mock database access.\n\n\nGuicey could use guice \nModules.override()\n to help you override required bindings.\nTo use it prepare module only with changed bindings (bindings that must override existing).\nFor example, you want to replace ServiceX. You have few options:\n\n\n\n\nIf it implement interface, implement your own service and bind as \n\nbind(ServiceContract.class).to(MyServiceXImpl.class)\n\n\nIf service is a class, you can modify its behaviour with extended class\n\nbind(ServiceX.class).to(MyServiceXExt.class)\n\n\nOr you can simply register some mock instance\n\nbind(ServiceX.class).toInstance(myMockInstance)\n\n\n\n\npublic\n \nclass\n \nMyOverridingModule\n \nextends\n \nAbstractModule\n \n{\n\n\n    \nprotected\n \nconfigure\n()\n \n{\n\n        \nbind\n(\nServiceX\n.\nclass\n).\nto\n(\nMyServiceXExt\n.\nclass\n);\n        \n    \n}\n\n\n}\n\n\n\n\n\nAnd register overriding module in hook:\n\n\npublic\n \nclass\n \nMyHook\n \nimplements\n \nGuiceyConfigurationHook\n \n{\n\n    \npublic\n \nvoid\n \nconfigure\n(\nGuiceBundle\n.\nBuilder\n \nbuilder\n)\n \n{\n\n        \nbuilder\n\n            \n.\nmodulesOverride\n(\nnew\n \nMyOverridingModule\n());\n\n    \n}\n\n\n}\n\n\n\n\n\nDebug bundles\n\u00b6\n\n\nYou can also use special guicey bundles, which modify application behaviour.\nBundles could contain additional listeners or services to gather additional metrics during\ntests or validate behaviour.\n\n\nFor example, guicey tests use bundle to enable restricted guice options like \n\ndisableCircularProxies\n.\n\n\nBundles are also able to:\n\n\n\n\ndisable installers, extensions, gucie modules\n\n\noverride guice bindings\n\n\n\n\nYou can use lookup mechanism to load bundles in tests. For example, \n\nsystem properties lookup\n. \n\n\nJunit\n\u00b6\n\n\nTesting core logic\n\u00b6\n\n\nFor integration testing of guice specific logic you can use \nGuiceyAppRule\n. It works almost like \n\nDropwizardAppRule\n,\nbut \ndoesn't start jetty\n (and so jersey and guice web modules will not be initialized). \nManaged and lifecycle objects supported.\n\n\npublic\n \nclass\n \nMyTest\n \n{\n\n\n    \n@Rule\n\n    \nGuiceyAppRule\n<\nMyConfiguration\n>\n \nRULE\n \n=\n \nnew\n \nGuiceyAppRule\n<>(\nMyApplication\n.\nclass\n,\n \n\"path/to/configuration.yaml\"\n);\n\n\n    \npublic\n \nvoid\n \ntestSomething\n()\n \n{\n\n        \nRULE\n.\ngetBean\n(\nMyService\n.\nclass\n).\ndoSomething\n();\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nAs with dropwizard rule, configuration is optional\n\n\nnew\n \nGuiceyAppRule\n<>(\nMyApplication\n.\nclass\n,\n \nnull\n)\n\n\n\n\n\nTesting web logic\n\u00b6\n\n\nFor web component tests (servlets, filters, resources) use \n\nDropwizardAppRule\n.\n\n\nTo access guice beans use injector lookup:\n\n\nInjectorLookup\n.\ngetInjector\n(\nRULE\n.\ngetApplication\n()).\ngetBean\n(\nMyService\n.\nclass\n);\n\n\n\n\n\nCustomizing guicey configuration\n\u00b6\n\n\nAs \ndescribed above\n guicey provides a way to modify it's configuration in tests.\nYou can apply configuration hook using rule:\n\n\n// there may be exact class instead of lambda\n\n\nnew\n \nGuiceyConfigurationRule\n((\nbuilder\n)\n \n->\n \nbuilder\n.\nmodules\n(...))\n\n\n\n\n\nTo use it with \nDropwizardAppRule\n or \nGuiceyAppRule\n you will have to apply explicit order:\n\n\nstatic\n \nGuiceyAppRule\n \nRULE\n \n=\n \nnew\n \nGuiceyAppRule\n(\nApp\n.\nclass\n,\n \nnull\n);\n\n\n@ClassRule\n\n\npublic\n \nstatic\n \nRuleChain\n \nchain\n \n=\n \nRuleChain\n\n       \n.\nouterRule\n(\nnew\n \nGuiceyConfigurationRule\n((\nbuilder\n)\n \n->\n \nbuilder\n.\nmodules\n(...)))\n\n       \n.\naround\n(\nRULE\n);\n\n\n\n\n\n\n\nAttention\n\n\nRuleChain is required because rules execution order is not guaranteed and\nconfiguration rule must obviously be executed before application rule. \n\n\n\n\nIf you need to declare configurations common for all tests then declare rule instace\nin base test class and use it in chain (at each test):\n\n\npublic\n \nclass\n \nBaseTest\n \n{\n\n    \n// IMPORTANT no @ClassRule annotation here!\n\n     \nstatic\n \nGuiceyConfigurationRule\n \nBASE\n \n=\n \nnew\n \nGuiceyConfigurationRule\n((\nbuilder\n)\n \n->\n \nbuilder\n.\nmodules\n(...))\n\n \n}\n\n\n \npublic\n \nclass\n \nSomeTest\n \nextends\n \nBaseTest\n \n{\n\n     \nstatic\n \nGuiceyAppRule\n \nRULE\n \n=\n \nnew\n \nGuiceyAppRule\n(\nApp\n.\nclass\n,\n \nnull\n);\n\n     \n@ClassRule\n\n     \npublic\n \nstatic\n \nRuleChain\n \nchain\n \n=\n \nRuleChain\n\n        \n.\nouterRule\n(\nBASE\n)\n\n        \n// optional test-specific staff\n\n        \n.\naround\n(\nnew\n \nGuiceyConfigurationRule\n((\nbuilder\n)\n \n->\n \nbuilder\n.\nmodules\n(...))\n \n        \n.\naround\n(\nRULE\n);\n\n \n}\n\n\n\n\n\n\n\nWarning\n\n\nDon't use configuration rule with spock becuase it will not work. Use special spock extension instead.\n\n\n\n\nTesting startup errors\n\u00b6\n\n\nIf exception occur on startup dropwizard will call \nSystem\n.\nexit\n(\n1\n)\n instead of throwing exception (as it was before 1.1.0).\nSystem exit could be intercepted with \nsystem rules\n.\n\n\nSpecial rule is provided to simplify work with system rules: \nStartupErrorRule\n.\nIt's a combination of exit and out/err outputs interception rules.\n\n\nTo use this rule add dependency: \ncom.github.stefanbirkner:system-rules:1.16.0\n\n\npublic\n \nclass\n \nMyErrTest\n \n{\n\n\n    \n@Rule\n\n    \npublic\n \nStartupErrorRule\n \nRULE\n \n=\n \nStartupErrorRule\n.\ncreate\n();\n\n\n    \npublic\n \nvoid\n \ntestSomething\n()\n \n{\n\n        \nnew\n \nMyErrApp\n().\nmain\n(\n'\nserver\n'\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nThis test will pass only if application will throw exception during startup.\n\n\nIn junit it is impossible to apply checks after exit statement, so such checks\nmust be registered as a special callback:\n\n\npublic\n \nclass\n \nMyErrTest\n \n{\n\n\n    \n@Rule\n\n    \npublic\n \nStartupErrorRule\n \nRULE\n \n=\n \nStartupErrorRule\n.\ncreate\n((\nout\n,\n \nerr\n)\n \n->\n \n{\n\n        \nAssert\n.\nassertTrue\n(\nout\n.\ncontains\n(\n\"some log line\"\n));\n\n        \nAssert\n.\nassertTrue\n(\nerr\n.\ncontains\n(\n\"expected exception message\"\n));\n\n    \n});\n\n\n    \npublic\n \nvoid\n \ntestSomething\n()\n \n{\n\n        \nnew\n \nMyErrApp\n().\nmain\n(\n'\nserver\n'\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nNote that err will contain full exception stack trace and so you can check exception type too\nby using contains statement like above.\n\n\nCheck callback(s) may be added after rule creation:\n\n\n@Rule\n\n\npublic\n \nStartupErrorRule\n \nRULE\n \n=\n \nStartupErrorRule\n.\ncreate\n();\n\n\n\npublic\n \nvoid\n \ntestSomething\n()\n \nthrows\n \nException\n \n{\n\n    \nRULE\n.\ncheckAfterExit\n((\nout\n,\n \nerr\n)\n \n->\n \n{\n\n            \nAssert\n.\nassertTrue\n(\nerr\n.\ncontains\n(\n\"expected exception message\"\n));\n\n        \n});\n\n    \n...\n\n\n}\n\n\n\n\n\nMultiple check callbacks may be registered (even if the first one was registered in rule's \ncreate call).\n\n\n\n\nRule works a bit differently with spock (see below).\n\n\n\n\nSpock\n\u00b6\n\n\nIf you use \nspock framework\n you can use spock specific extensions:\n\n\n\n\n@UseGuiceyApp\n - internally use \nGuiceyAppRule\n\n\n@UseDropwizardApp\n - internally use \nDropwizardAppRule\n\n\n\n\nBoth extensions allows using injections directly in specifications (like spock-guice).\n\n\n@UseGuiceyConfiguration\n extension could be used to apply \nconfiguration hook\n \ncommon for all tests\n\n\nSpock lifecycle hooks\n\u00b6\n\n\nclass\n \nMyTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n@ClassRule\n \n@Shared\n\n    \nJunitRule\n \nsharedRule\n \n=\n \nnew\n \nJunitRule\n()\n\n\n    \n@Rule\n\n    \nJunitRule2\n \nrule\n \n=\n \nnew\n \nJunitRule2\n()\n\n\n    \ndef\n \nsetupSpec\n()\n \n{\n\n    \n}\n\n\n    \ndef\n \nsetup\n()\n \n{\n\n    \n}\n\n\n    \ndef\n \n\"Test method body\"\n \n()\n \n{\n\n        \nsetup:\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nClass rules are applied once per test class (same as \nsetupSpec\n).\nRules are applied per test method (same as \nsetup\n).\n\n\n\n\nSetup order:\n\n\n\n\nClass rule\n\n\nSetup spec method\n\n\nRule\n\n\nSetup method\n\n\nTest method's setup section\n\n\n\n\n@UseGuiceyApp\n\u00b6\n\n\n@UseGuiceyApp\n runs all guice logic without starting jetty (so resources, servlets and filters are not available).\nManaged objects are handled correctly.\n\n\n@UseGuiceyApp\n(\nMyApplication\n)\n\n\nclass\n \nAutoScanModeTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n@Inject\n \nMyService\n \nservice\n\n\n    \ndef\n \n\"My service test\"\n \n{\n\n        \nwhen:\n \n'calling service'\n\n        \ndef\n \nres\n \n=\n \nservice\n.\ngetSmth\n()\n\n        \nthen:\n \n'correct result returned'\n\n        \nres\n \n==\n \n'hello'\n\n    \n}\n\n\n\n\n\nAnnotation allows you to configure the same things as rules does: application class, configuration file (optional),\nconfiguration overrides.\n\n\n@UseGuiceyApp\n(\nvalue\n \n=\n \nMyApplication\n,\n\n    \nconfig\n \n=\n \n'path/to/my/config.yml'\n,\n\n    \nconfigOverride\n \n=\n \n[\n\n            \n@ConfigOverride\n(\nkey\n \n=\n \n\"foo\"\n,\n \nvalue\n \n=\n \n\"2\"\n),\n\n            \n@ConfigOverride\n(\nkey\n \n=\n \n\"bar\"\n,\n \nvalue\n \n=\n \n\"12\"\n)\n\n    \n])\n\n\nclass\n \nConfigOverrideTest\n \nextends\n \nSpecification\n \n{\n\n\n\n\n\nAs with rules, \nconfigOverride\n may be used without setting config file (simply to fill some configurations)\n\n\n@UseDropwizardApp\n\u00b6\n\n\n@UseDropwizardApp\n is useful for complete integration testing (when web part is required):\n\n\n@UseDropwizardApp\n(\nMyApplication\n)\n\n\nclass\n \nWebModuleTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n@Inject\n \nMyService\n \nservice\n\n\n    \ndef\n \n\"Check web bindings\"\n()\n \n{\n\n\n        \nwhen:\n \n\"calling filter\"\n\n        \ndef\n \nres\n \n=\n \nnew\n \nURL\n(\n\"http://localhost:8080/dummyFilter\"\n).\ngetText\n()\n\n        \nthen:\n \n\"filter active\"\n\n        \nres\n \n==\n \n'Sample filter and service called'\n\n        \nservice\n.\nisCalled\n()\n\n\n\n\n\nAnnotation supports the same configuration options as \n@UseGuiceyApp\n (see above)\n\n\nCustomizing guicey configuration\n\u00b6\n\n\nAs \ndescribed above\n guicey provides a way to modify it's configuration in tests.\nYou can declare custom configuration hooks directly in extension annotations (described above):\n\n\n@UseDropwizardApp\n(\nvalue\n \n=\n \nMyApplication\n,\n \nhooks\n \n=\n \nMyHook\n)\n\n\n\n\n\nor\n\n\n@UseGuiceyApp\n(\nvalue\n \n=\n \nMyApplication\n,\n \nhooks\n \n=\n \nMyHook\n)\n\n\n\n\n\nWhere MyHook is:\n\n\nclass\n \nMyHook\n \nimplements\n \nGuiceyConfigurationHook\n \n{}\n\n\n\n\n\nWhen you need to register configurations common for all tests, declare hook at the base test class:\n\n\nUseGuiceyConfiguration\n(\nMyBaseHook\n)\n\n\nclass\n \nBaseTest\n \nextends\n \nSpecification\n \n{\n\n\n\n}\n\n\n\n@UseGuiceyApp\n(\nApp\n)\n\n\nclass\n \nSomeTest\n \nextends\n \nBaseTest\n \n{}\n\n\n\n\n\n\n\nNote\n\n\nYou \ncan still use\n test specific hooks together with declared base hook\n(to apply some more test-specific configuration).\n\n\n\n\n\n\nWarning\n\n\nOnly one \n@UseGuiceyConfiguration\n declaration may be used in test hierarchy:\nfor example, you can't declare it in base class and then another one on extended class\n- base for a group of tests. This is spock limitation (only one extension will actually work)\nbut should not be an issue for most cases.\n\n\n\n\nDropwizard startup error\n\u00b6\n\n\nStartupErrorRule\n may be used to intercept dropwizard \nSystem\n.\nexit\n(\n1\n)\n call.\nBut it will work different then for junit:\n\nthen\n section is always called with exception (\nCheckExitCalled\n). \nAlso, \nthen\n section may be used for assertion after exit calls and so there is \nno need to add custom assertion callbacks (required by junit tests).\n\n\nclass\n \nErrorTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n@Rule\n \nStartupErrorRule\n \nRULE\n \n=\n \nStartupErrorRule\n.\ncreate\n()\n\n\n    \ndef\n \n\"Check startup error\"\n()\n \n{\n\n\n        \nwhen:\n \n\"starting app with error\"\n\n        \nnew\n \nMyErrApp\n().\nmain\n([\n'server'\n])\n\n\n        \nthen:\n \n\"startup failed\"\n\n        \nthrown\n(\nRULE\n.\nindicatorExceptionType\n)\n\n        \nRULE\n.\noutput\n.\ncontains\n(\n'stating application'\n)\n\n        \nRULE\n.\nerror\n.\ncontains\n(\n'some error occur'\n)\n\n\n\n\n\nSpock extensions details\n\u00b6\n\n\nExtensions follow spock-guice style - application started once for all tests in class. It's the same as using rule with\n\n@ClassRule\n annotation. Rules may be used with spock too (the same way as in junit), but don't mix them with\nannotation extensions.\n\n\nThere are two limitations comparing to rules:\n\n\n\n\nApplication can't be created for each test separately (like with \n@Rule\n annotation). This is because of \n@Shared\n instances support.\n\n\nYou can't customize application creation: application class must have no-args constructor (with rules you can extend rule class\nand override \nnewApplication\n method). But this should be rare requirement.\n\n\n\n\n\n\nAll guicey tests use spock, so you can see extensions usage examples there.\n\n\n\n\nTo better understand injection scopes look the following test:\n\n\n@UseGuiceyApp\n(\nAutoScanApplication\n)\n\n\nclass\n \nInjectionTest\n \nextends\n \nSpecification\n \n{\n\n\n    \n// instance remain the same between tests\n\n    \n@Shared\n \n@Inject\n \nTestBean\n \nsharedBean\n\n\n    \n// new instance injected on each test\n\n    \n@Inject\n \nTestBean\n \nbean\n\n\n    \n// the same context used for all tests (in class), so the same bean instance inserted before each test\n\n    \n@Inject\n \nTestSingletonBean\n \nsingletonBean\n\n\n    \ndef\n \n\"Check injection types\"\n()\n \n{\n\n        \nwhen:\n \n\"changing state of injected beans\"\n\n        \nsharedBean\n.\nvalue\n \n=\n \n10\n\n        \nbean\n.\nvalue\n \n=\n \n5\n\n        \nsingletonBean\n.\nvalue\n \n=\n \n15\n\n\n        \nthen:\n \n\"instances are different\"\n\n        \nsharedBean\n.\nvalue\n \n==\n \n10\n\n        \nbean\n.\nvalue\n \n==\n \n5\n\n        \nsingletonBean\n.\nvalue\n \n==\n \n15\n\n\n    \n}\n\n\n    \ndef\n \n\"Check shared state\"\n()\n \n{\n\n\n        \nexpect:\n \n\"shared bean instance is the same, whereas other one re-injected\"\n\n        \nsharedBean\n.\nvalue\n \n==\n \n10\n\n        \nbean\n.\nvalue\n \n==\n \n0\n\n        \nsingletonBean\n.\nvalue\n \n==\n \n15\n \n// the same instance was set before second test\n\n    \n}\n\n\n    \n// bean is in prototype scope\n\n    \nstatic\n \nclass\n \nTestBean\n \n{\n\n        \nint\n \nvalue\n\n    \n}\n\n\n    \n@Singleton\n\n    \nstatic\n \nclass\n \nTestSingletonBean\n \n{\n\n        \nint\n \nvalue\n\n    \n}\n\n\n}\n\n\n\n\n\nOverriding overridden beans\n\u00b6\n\n\nGuicey provides \ndirect support for overriding guice bindings\n,\nso in most cases you don't need to do anything.\n\n\nBut, if you use this to override application bindings need to override such bindings in test (again), then you\n may use provided custom \ninjector factory\n:  \n\n\nRegister factory in guice bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\ninjectorFactory\n(\nnew\n \nBindingsOverrideInjectorFactory\n())\n\n\n\n\n\nAfter that you can register overriding bindings (which will override even modules registered in \nmodulesOverride\n)\nwith:\n\n\nBindingsOverrideInjectorFactory\n.\noverride\n(\nnew\n \nMyOverridingModule\n())\n\n\n\n\n\n\n\nImportant\n\n\nIt is assumed that overrding modules registration and application initialization\nwill be at the same thread (thread local used for holding registered modules to allow\nparallel tests usage). \n\n\n\n\nFor example, suppose we have some service \nCustomerService\n and it's implementation \nCustomerServiceImpl\n, \ndefined in some 3\nrd\n party module. For some reason we need to override this binding in the application:\n\n\npublic\n \nclass\n \nOverridingModule\n \nextends\n \nAbstractModule\n \n{\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nbind\n(\nCustomerService\n.\nclass\n).\nto\n(\nCustomCustomerServiceImpl\n.\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nIf we need to override this binding in test (again):\n\n\n(Simplified) registration looks like this:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\ninjectorFactory\n(\nnew\n \nBindingsOverrideInjectorFactory\n())\n\n    \n.\nmodules\n(\nnew\n \nThirdPatyModule\n())\n\n    \n// override binding for application needs\n\n    \n.\nmodulesOverride\n(\nnew\n \nOverridingModule\n())\n\n    \n...\n\n    \n.\nbuild\n()\n\n\n\n// register overriding somewhere\n\n\nBindingsOverrideInjectorFactory\n.\noverride\n(\nnew\n \nTestOverridingModule\n())\n    \n\n\n\n\n\n\nTip\n\n\nConfiguration hook\n may be used for static call (as a good integration point)\n\n\n\n\nAfter test startup, application will use customer service binding from TestOverridingModule.",
            "title": "Test"
        },
        {
            "location": "/guide/test/#testing",
            "text": "Test support require  io.dropwizard:dropwizard-testing:1.3.0  dependency.",
            "title": "Testing"
        },
        {
            "location": "/guide/test/#general-test-support",
            "text": "",
            "title": "General test support"
        },
        {
            "location": "/guide/test/#configuration-hooks",
            "text": "Guicey provides  hooks mechanism  to be able to modify\napplication configuration in tests.  Using hooks you can disable installers, extensions, guicey bundles \nor override guice bindings.  It may also be useful to register additional extensions (e.g. to validate some internal behaviour).  Example hook:  public   class   MyHook   implements   GuiceyConfigurationHook   { \n\n     public   void   configure ( GuiceBundle . Builder   builder )   { \n         builder \n             . disableModules ( FeatureXModule . class ) \n             . disable ( inPackage ( \"com.foo.feature\" )) \n             . modulesOverride ( new   MockDaoModule ()) \n             . option ( Myoptions . DebugOption ,   true ); \n     }  }    Note  You can modify  options  in hook and so could enable some custom\ndebug/monitoring options specifically for test.   There are special spock and junit extensions for hooks registrations.",
            "title": "Configuration hooks"
        },
        {
            "location": "/guide/test/#disables",
            "text": "You can use hooks to disable all not needed features in test:   installers    extensions    guice modules  guicey bundles     This way you can isolate (as possible) some feature for testing.   The most helpful should be bundles disable (if you use bundles for features grouping)\nand guice modules.  Use  predicate disabling .   Note  It is supposed that disabling will be used instead of mocking - you simply remove what\nyou don't need and register replacements, if required.",
            "title": "Disables"
        },
        {
            "location": "/guide/test/#guice-bindings-override",
            "text": "It is quite common requirement to override bindings for testing. For example, \nyou may want to mock database access.  Guicey could use guice  Modules.override()  to help you override required bindings.\nTo use it prepare module only with changed bindings (bindings that must override existing).\nFor example, you want to replace ServiceX. You have few options:   If it implement interface, implement your own service and bind as  bind(ServiceContract.class).to(MyServiceXImpl.class)  If service is a class, you can modify its behaviour with extended class bind(ServiceX.class).to(MyServiceXExt.class)  Or you can simply register some mock instance bind(ServiceX.class).toInstance(myMockInstance)   public   class   MyOverridingModule   extends   AbstractModule   { \n\n     protected   configure ()   { \n         bind ( ServiceX . class ). to ( MyServiceXExt . class );         \n     }  }   And register overriding module in hook:  public   class   MyHook   implements   GuiceyConfigurationHook   { \n     public   void   configure ( GuiceBundle . Builder   builder )   { \n         builder \n             . modulesOverride ( new   MyOverridingModule ()); \n     }  }",
            "title": "Guice bindings override"
        },
        {
            "location": "/guide/test/#debug-bundles",
            "text": "You can also use special guicey bundles, which modify application behaviour.\nBundles could contain additional listeners or services to gather additional metrics during\ntests or validate behaviour.  For example, guicey tests use bundle to enable restricted guice options like  disableCircularProxies .  Bundles are also able to:   disable installers, extensions, gucie modules  override guice bindings   You can use lookup mechanism to load bundles in tests. For example,  system properties lookup .",
            "title": "Debug bundles"
        },
        {
            "location": "/guide/test/#junit",
            "text": "",
            "title": "Junit"
        },
        {
            "location": "/guide/test/#testing-core-logic",
            "text": "For integration testing of guice specific logic you can use  GuiceyAppRule . It works almost like  DropwizardAppRule ,\nbut  doesn't start jetty  (and so jersey and guice web modules will not be initialized). \nManaged and lifecycle objects supported.  public   class   MyTest   { \n\n     @Rule \n     GuiceyAppRule < MyConfiguration >   RULE   =   new   GuiceyAppRule <>( MyApplication . class ,   \"path/to/configuration.yaml\" ); \n\n     public   void   testSomething ()   { \n         RULE . getBean ( MyService . class ). doSomething (); \n         ... \n     }  }   As with dropwizard rule, configuration is optional  new   GuiceyAppRule <>( MyApplication . class ,   null )",
            "title": "Testing core logic"
        },
        {
            "location": "/guide/test/#testing-web-logic",
            "text": "For web component tests (servlets, filters, resources) use  DropwizardAppRule .  To access guice beans use injector lookup:  InjectorLookup . getInjector ( RULE . getApplication ()). getBean ( MyService . class );",
            "title": "Testing web logic"
        },
        {
            "location": "/guide/test/#customizing-guicey-configuration",
            "text": "As  described above  guicey provides a way to modify it's configuration in tests.\nYou can apply configuration hook using rule:  // there may be exact class instead of lambda  new   GuiceyConfigurationRule (( builder )   ->   builder . modules (...))   To use it with  DropwizardAppRule  or  GuiceyAppRule  you will have to apply explicit order:  static   GuiceyAppRule   RULE   =   new   GuiceyAppRule ( App . class ,   null );  @ClassRule  public   static   RuleChain   chain   =   RuleChain \n        . outerRule ( new   GuiceyConfigurationRule (( builder )   ->   builder . modules (...))) \n        . around ( RULE );    Attention  RuleChain is required because rules execution order is not guaranteed and\nconfiguration rule must obviously be executed before application rule.    If you need to declare configurations common for all tests then declare rule instace\nin base test class and use it in chain (at each test):  public   class   BaseTest   { \n     // IMPORTANT no @ClassRule annotation here! \n      static   GuiceyConfigurationRule   BASE   =   new   GuiceyConfigurationRule (( builder )   ->   builder . modules (...)) \n  } \n\n  public   class   SomeTest   extends   BaseTest   { \n      static   GuiceyAppRule   RULE   =   new   GuiceyAppRule ( App . class ,   null ); \n      @ClassRule \n      public   static   RuleChain   chain   =   RuleChain \n         . outerRule ( BASE ) \n         // optional test-specific staff \n         . around ( new   GuiceyConfigurationRule (( builder )   ->   builder . modules (...))  \n         . around ( RULE ); \n  }    Warning  Don't use configuration rule with spock becuase it will not work. Use special spock extension instead.",
            "title": "Customizing guicey configuration"
        },
        {
            "location": "/guide/test/#testing-startup-errors",
            "text": "If exception occur on startup dropwizard will call  System . exit ( 1 )  instead of throwing exception (as it was before 1.1.0).\nSystem exit could be intercepted with  system rules .  Special rule is provided to simplify work with system rules:  StartupErrorRule .\nIt's a combination of exit and out/err outputs interception rules.  To use this rule add dependency:  com.github.stefanbirkner:system-rules:1.16.0  public   class   MyErrTest   { \n\n     @Rule \n     public   StartupErrorRule   RULE   =   StartupErrorRule . create (); \n\n     public   void   testSomething ()   { \n         new   MyErrApp (). main ( ' server ' ); \n     }  }   This test will pass only if application will throw exception during startup.  In junit it is impossible to apply checks after exit statement, so such checks\nmust be registered as a special callback:  public   class   MyErrTest   { \n\n     @Rule \n     public   StartupErrorRule   RULE   =   StartupErrorRule . create (( out ,   err )   ->   { \n         Assert . assertTrue ( out . contains ( \"some log line\" )); \n         Assert . assertTrue ( err . contains ( \"expected exception message\" )); \n     }); \n\n     public   void   testSomething ()   { \n         new   MyErrApp (). main ( ' server ' ); \n     }  }   Note that err will contain full exception stack trace and so you can check exception type too\nby using contains statement like above.  Check callback(s) may be added after rule creation:  @Rule  public   StartupErrorRule   RULE   =   StartupErrorRule . create ();  public   void   testSomething ()   throws   Exception   { \n     RULE . checkAfterExit (( out ,   err )   ->   { \n             Assert . assertTrue ( err . contains ( \"expected exception message\" )); \n         }); \n     ...  }   Multiple check callbacks may be registered (even if the first one was registered in rule's \ncreate call).   Rule works a bit differently with spock (see below).",
            "title": "Testing startup errors"
        },
        {
            "location": "/guide/test/#spock",
            "text": "If you use  spock framework  you can use spock specific extensions:   @UseGuiceyApp  - internally use  GuiceyAppRule  @UseDropwizardApp  - internally use  DropwizardAppRule   Both extensions allows using injections directly in specifications (like spock-guice).  @UseGuiceyConfiguration  extension could be used to apply  configuration hook  \ncommon for all tests",
            "title": "Spock"
        },
        {
            "location": "/guide/test/#spock-lifecycle-hooks",
            "text": "class   MyTest   extends   Specification   { \n\n     @ClassRule   @Shared \n     JunitRule   sharedRule   =   new   JunitRule () \n\n     @Rule \n     JunitRule2   rule   =   new   JunitRule2 () \n\n     def   setupSpec ()   { \n     } \n\n     def   setup ()   { \n     } \n\n     def   \"Test method body\"   ()   { \n         setup: \n     }  }    Class rules are applied once per test class (same as  setupSpec ).\nRules are applied per test method (same as  setup ).   Setup order:   Class rule  Setup spec method  Rule  Setup method  Test method's setup section",
            "title": "Spock lifecycle hooks"
        },
        {
            "location": "/guide/test/#useguiceyapp",
            "text": "@UseGuiceyApp  runs all guice logic without starting jetty (so resources, servlets and filters are not available).\nManaged objects are handled correctly.  @UseGuiceyApp ( MyApplication )  class   AutoScanModeTest   extends   Specification   { \n\n     @Inject   MyService   service \n\n     def   \"My service test\"   { \n         when:   'calling service' \n         def   res   =   service . getSmth () \n         then:   'correct result returned' \n         res   ==   'hello' \n     }   Annotation allows you to configure the same things as rules does: application class, configuration file (optional),\nconfiguration overrides.  @UseGuiceyApp ( value   =   MyApplication , \n     config   =   'path/to/my/config.yml' , \n     configOverride   =   [ \n             @ConfigOverride ( key   =   \"foo\" ,   value   =   \"2\" ), \n             @ConfigOverride ( key   =   \"bar\" ,   value   =   \"12\" ) \n     ])  class   ConfigOverrideTest   extends   Specification   {   As with rules,  configOverride  may be used without setting config file (simply to fill some configurations)",
            "title": "@UseGuiceyApp"
        },
        {
            "location": "/guide/test/#usedropwizardapp",
            "text": "@UseDropwizardApp  is useful for complete integration testing (when web part is required):  @UseDropwizardApp ( MyApplication )  class   WebModuleTest   extends   Specification   { \n\n     @Inject   MyService   service \n\n     def   \"Check web bindings\" ()   { \n\n         when:   \"calling filter\" \n         def   res   =   new   URL ( \"http://localhost:8080/dummyFilter\" ). getText () \n         then:   \"filter active\" \n         res   ==   'Sample filter and service called' \n         service . isCalled ()   Annotation supports the same configuration options as  @UseGuiceyApp  (see above)",
            "title": "@UseDropwizardApp"
        },
        {
            "location": "/guide/test/#customizing-guicey-configuration_1",
            "text": "As  described above  guicey provides a way to modify it's configuration in tests.\nYou can declare custom configuration hooks directly in extension annotations (described above):  @UseDropwizardApp ( value   =   MyApplication ,   hooks   =   MyHook )   or  @UseGuiceyApp ( value   =   MyApplication ,   hooks   =   MyHook )   Where MyHook is:  class   MyHook   implements   GuiceyConfigurationHook   {}   When you need to register configurations common for all tests, declare hook at the base test class:  UseGuiceyConfiguration ( MyBaseHook )  class   BaseTest   extends   Specification   {  }  @UseGuiceyApp ( App )  class   SomeTest   extends   BaseTest   {}    Note  You  can still use  test specific hooks together with declared base hook\n(to apply some more test-specific configuration).    Warning  Only one  @UseGuiceyConfiguration  declaration may be used in test hierarchy:\nfor example, you can't declare it in base class and then another one on extended class\n- base for a group of tests. This is spock limitation (only one extension will actually work)\nbut should not be an issue for most cases.",
            "title": "Customizing guicey configuration"
        },
        {
            "location": "/guide/test/#dropwizard-startup-error",
            "text": "StartupErrorRule  may be used to intercept dropwizard  System . exit ( 1 )  call.\nBut it will work different then for junit: then  section is always called with exception ( CheckExitCalled ). \nAlso,  then  section may be used for assertion after exit calls and so there is \nno need to add custom assertion callbacks (required by junit tests).  class   ErrorTest   extends   Specification   { \n\n     @Rule   StartupErrorRule   RULE   =   StartupErrorRule . create () \n\n     def   \"Check startup error\" ()   { \n\n         when:   \"starting app with error\" \n         new   MyErrApp (). main ([ 'server' ]) \n\n         then:   \"startup failed\" \n         thrown ( RULE . indicatorExceptionType ) \n         RULE . output . contains ( 'stating application' ) \n         RULE . error . contains ( 'some error occur' )",
            "title": "Dropwizard startup error"
        },
        {
            "location": "/guide/test/#spock-extensions-details",
            "text": "Extensions follow spock-guice style - application started once for all tests in class. It's the same as using rule with @ClassRule  annotation. Rules may be used with spock too (the same way as in junit), but don't mix them with\nannotation extensions.  There are two limitations comparing to rules:   Application can't be created for each test separately (like with  @Rule  annotation). This is because of  @Shared  instances support.  You can't customize application creation: application class must have no-args constructor (with rules you can extend rule class\nand override  newApplication  method). But this should be rare requirement.    All guicey tests use spock, so you can see extensions usage examples there.   To better understand injection scopes look the following test:  @UseGuiceyApp ( AutoScanApplication )  class   InjectionTest   extends   Specification   { \n\n     // instance remain the same between tests \n     @Shared   @Inject   TestBean   sharedBean \n\n     // new instance injected on each test \n     @Inject   TestBean   bean \n\n     // the same context used for all tests (in class), so the same bean instance inserted before each test \n     @Inject   TestSingletonBean   singletonBean \n\n     def   \"Check injection types\" ()   { \n         when:   \"changing state of injected beans\" \n         sharedBean . value   =   10 \n         bean . value   =   5 \n         singletonBean . value   =   15 \n\n         then:   \"instances are different\" \n         sharedBean . value   ==   10 \n         bean . value   ==   5 \n         singletonBean . value   ==   15 \n\n     } \n\n     def   \"Check shared state\" ()   { \n\n         expect:   \"shared bean instance is the same, whereas other one re-injected\" \n         sharedBean . value   ==   10 \n         bean . value   ==   0 \n         singletonBean . value   ==   15   // the same instance was set before second test \n     } \n\n     // bean is in prototype scope \n     static   class   TestBean   { \n         int   value \n     } \n\n     @Singleton \n     static   class   TestSingletonBean   { \n         int   value \n     }  }",
            "title": "Spock extensions details"
        },
        {
            "location": "/guide/test/#overriding-overridden-beans",
            "text": "Guicey provides  direct support for overriding guice bindings ,\nso in most cases you don't need to do anything.  But, if you use this to override application bindings need to override such bindings in test (again), then you\n may use provided custom  injector factory :    Register factory in guice bundle:  GuiceBundle . builder () \n     . injectorFactory ( new   BindingsOverrideInjectorFactory ())   After that you can register overriding bindings (which will override even modules registered in  modulesOverride )\nwith:  BindingsOverrideInjectorFactory . override ( new   MyOverridingModule ())    Important  It is assumed that overrding modules registration and application initialization\nwill be at the same thread (thread local used for holding registered modules to allow\nparallel tests usage).    For example, suppose we have some service  CustomerService  and it's implementation  CustomerServiceImpl , \ndefined in some 3 rd  party module. For some reason we need to override this binding in the application:  public   class   OverridingModule   extends   AbstractModule   { \n     @Override \n     protected   void   configure ()   { \n         bind ( CustomerService . class ). to ( CustomCustomerServiceImpl . class ); \n     }  }   If we need to override this binding in test (again):  (Simplified) registration looks like this:  GuiceBundle . builder () \n     . injectorFactory ( new   BindingsOverrideInjectorFactory ()) \n     . modules ( new   ThirdPatyModule ()) \n     // override binding for application needs \n     . modulesOverride ( new   OverridingModule ()) \n     ... \n     . build ()  // register overriding somewhere  BindingsOverrideInjectorFactory . override ( new   TestOverridingModule ())        Tip  Configuration hook  may be used for static call (as a good integration point)   After test startup, application will use customer service binding from TestOverridingModule.",
            "title": "Overriding overridden beans"
        },
        {
            "location": "/guide/dg-migration/",
            "text": "Migration from dropwizard-guice\n\u00b6\n\n\n\n\nIf you are not migrating from \ndropwizard-guice\n then\nskip straight to \ngetting started\n\n\n\n\nDifferences\n\u00b6\n\n\nThe libraries are different in core guice integration aspects.\n\n\nDropwizard-guice\n\u00b6\n\n\n\n\nNote\n\n\nI may not be exactly correct because it's been a long time since I look how all this works. \nPlease correct me if I'm wrong.\n\n\n\n\nDropwizard-guice rely on \njersey2-guice\n. \nInjector is created on initialization dropwizard phase.\n\n\nPros:\n\n\n\n\nClasspath scan for automatic registrations\n\n\nResources could be registered directly from gucie bindings\n\n\nResources and jersey extensions registration is the same as in core dropwizard (\nenv.jersey().register()\n)\n\n\nGuice bundles remain the main extension point and guice bindings might be used \ninside them.\n\n\n\n\nCons:\n\n\n\n\njersey2-guice hacks jersey locator lookup process which could potentially break on future versions\n\n\nGuice child injector created for each request \n\n\nNot declared services are managed by HK2 and you must be careful if you use guice AOP (as it works ony on beans, managed by guice)\n\n\nEnvironment\n and \nConfiguration\n objects may be used only as \nProvider\n in eager singletons (as injector created in \ninitialization phase when these objects are not available)\n\n\nAdmin context not covered by \nGuiceFilter\n (no request scope injections under admin context calls).\n\n\n\n\nOverall, integration feels transparent and super easy to learn (great!), but with a runtime price and caution in service definitions.\n\n\nGuicey\n\u00b6\n\n\nGuicey prefer guice-first approach when everything is created by guice and registered in jersey as instance\n(so HK2 does not manage services, resources etc.).\n\n\nIn contrast to dropwizard-guice, guicey brings a lot of \nnew concepts\n to better integrate guice.\nThis was necessary due to moving injector creation into dropwizard run phase\n(which is conceptually more correct).\n\n\nGuicey abstracts user of knowing registration details and use \nInstaller - Extension\n concept:\ninstallers did all required registrations automatically and hide boilerplate of managing extension instances with guice.     \n\n\nIn pure dropwizard you need to: \nenvironment.jersey().register(MyResource.class)\n whereas in guicey\nyou just need to declare extension class: \nbundle.extensions(MyResource.class)\n and everything else would be automatic.\n\n\n\n\nThe same for all other extensions (tasks, health checks, jersey providers etc.): only extenion class is required for \nregistration.  \n\n\n\n\nPros:\n\n\n\n\nClasspath scan for automatic registrations\n\n\nYou can be sure that guice manage everything (no problems with AOP)\n\n\nSimple extensions: only extension class required (and no need to know how to install it) \n\n\nWider range of supported extensions and ability to add more integrations (custom installers support)\n\n\nConfiguration bindings (by yaml path and internal configuration object) \n\n\nGuiceFilter\n works on both main and admin contexts\n\n\nIntegration tests support\n\n\n\n\nCons:\n\n\n\n\nResources must use \nProvider\n for all request-scoped injections\n\n\nSpecial bundles (\nGuiceyBundle\n) should be used instead of dropwizard bundles (\nBundle\n)\n    in order to use guice-related features (but, as dropwizard-guice could discover dwopwizard bundles, \n    guicey could discover it's bundles too).\n\n\nExtra diagnostic tools usage required for debug to understand internal state \n(more a pro, but additional thing to know, which is a con).        \n\n\n\n\nOverall, guicey has much more features, cleaner guice integration and very developer friendly (customizable and with extra tooling), \nbut with a coast of learning curve (additional concepts to know and use above dropwizard).\n\n\nMatrix\n\u00b6\n\n\n\n\nOnly dropwizard-guice features present for comparison\n\n\n\n\n\n\n\n\n\n\nfeature\n\n\ndropwizard-guice\n\n\nguicey\n\n\n\n\n\n\n\n\n\n\nAuto scan\n\n\n+\n\n\n+\n\n\n\n\n\n\nAuto scan load class to inspect\n\n\n-\n\n\n+\n\n\n\n\n\n\nAuto scan recognize\n\n\nBundle, ConfiguredBundle, HealthCheck, Task, @Provider, resource (@Path), ParamConverterProvider\n\n\nall the same (and more) except dropwizard bundles\n\n\n\n\n\n\nResources (rest) recognition directly from guice bindings\n\n\n+\n\n\n-\n\n\n\n\n\n\nResources (rest) default scope\n\n\n\"request\"\n\n\nsingleton\n\n\n\n\n\n\nDropwizard bundle lookup\n\n\n+\n\n\n- (but has custom bundles lookup)\n\n\n\n\n\n\nInjections in dropwizard Bundle\n\n\n+\n\n\n-\n\n\n\n\n\n\nInjector creation customization\n\n\n+\n\n\n+\n\n\n\n\n\n\nInjector creation (dropwizard) phase\n\n\ninitialization\n\n\nrun\n\n\n\n\n\n\nAccess Bootstrap, Environment, Configuration in guice modules\n\n\n-\n\n\n+\n\n\n\n\n\n\nGuiceFilter contexts\n\n\nmain\n\n\nmain, admin\n\n\n\n\n\n\n\n\nMigration\n\u00b6\n\n\nBundle\n\u00b6\n\n\nBundle registration is almost the same, just more methods available:\n\n\nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n      \n.\nmodules\n(\nnew\n \nHelloWorldModule\n())\n   \n// instead of addModule\n\n      \n.\nenableAutoConfig\n(\ngetClass\n().\ngetPackage\n().\ngetName\n())\n\n      \n// .setConfigClass(HelloWorldConfiguration.class) // not needed\n\n      \n.\nbuild\n());\n\n\n\n\n\nAuto scan\n\u00b6\n\n\n\n\nNote\n\n\nIn guicey, \nauto scan\n load all classes in providied package. The logic is - application classes would be loaded in any \ncase (in dropwizard-guice, classes are inspected by reading structure, without loading).\n\n\n\n\nAuto scan will find and install extensions, with few exceptions (below)\n\n\nHealth checks\n\u00b6\n\n\nUse \nNamedHealthCheck\n instead of \nInjectableHealthCheck\n as check class.\n\n\nBundles\n\u00b6\n\n\nGuicey will not find dropwizard bundles: all required bundles must be directly registered in bootstrap.\n\n\n\n\nImportant\n\n\nGuice injections will not work inside dropwizard bundles\n\n\n\n\nBut note, that bundles, used for features integrations may not be required as guicey perform automatic installation\n(removes redundant code).\nFor reusable bundles, consider using \nGuiceyBundle\n instead. Also, dropwzard bundles, registered in bootsrap \n\ncould be recognized as guicey bundles\n (to provide extra guicey features). \n\n\nResources (rest)\n\u00b6\n\n\nFirst of all, note that resource bound only in guice module will not be discovered (no installation from \nguice declaration like it was in jersey1 guice integration).\nUse either classpath scan to install resources or specify them directly into bundle: \nbundle.extensions(Resource1.class, Resoutrce2.class)\n.\n\n\nYou can still \ndelegate jersey extensions (resources, providers) management to HK2\n, but they will lack\nguice aop and require extra dependency - \nHK2-guice-bridge\n (official HK guice bridge)\n\n\n\n\nImportant\n\n\nResources are \nsingletons\n by default and so they will initialize with guice context \n(\nmay be disabled\n).\nYou may need to wrap some injections with \nProvider\n. Alternatively, you may use \n@LazyBinding\n, \n@HK2Managed\n, \nset \nDevelopment\n stage for guice context or use prototype scope on resources (\n@Prototype\n or with \nglobal option\n)\n\n\n\n\nDiagnostic\n\u00b6\n\n\nUse \n.printDiagnosticInfo()\n to see all extensions, installed by classpath scan.\n\n\nUse \n.printLifecyclePhases()\n to indicate lifecycle phases in logs (split logs to clearly \nunderstand onlgoing logic).\n\n\nInjector\n\u00b6\n\n\nRemember that injector is created at runtime phase when \nConfiguration\n and \nEnvironment\n objects are already present,\nso no need to use \nProvider\n for them.  \n\n\nAlso, you may use direct access for configuration values. See: \nbundle.printConfigurationBindings()\n\n\nTesting\n\u00b6\n\n\nGuicey provides more lightweight alternative to \nDropwizardAppRule\n: \nGuiceyAppRule\n \n(starts only guice context without jetty). Use it for core business logic integration tests.\n\n\nAlso, note that you may replace any extension or bean in context before test\n(\nGuiceyConfigurationRule\n).\n\n\nGo on\n\u00b6\n\n\nRead \ngetting started\n to get in common with guicey concepts",
            "title": "Migration from dropwizard-guice"
        },
        {
            "location": "/guide/dg-migration/#migration-from-dropwizard-guice",
            "text": "If you are not migrating from  dropwizard-guice  then\nskip straight to  getting started",
            "title": "Migration from dropwizard-guice"
        },
        {
            "location": "/guide/dg-migration/#differences",
            "text": "The libraries are different in core guice integration aspects.",
            "title": "Differences"
        },
        {
            "location": "/guide/dg-migration/#dropwizard-guice",
            "text": "Note  I may not be exactly correct because it's been a long time since I look how all this works. \nPlease correct me if I'm wrong.   Dropwizard-guice rely on  jersey2-guice . \nInjector is created on initialization dropwizard phase.  Pros:   Classpath scan for automatic registrations  Resources could be registered directly from gucie bindings  Resources and jersey extensions registration is the same as in core dropwizard ( env.jersey().register() )  Guice bundles remain the main extension point and guice bindings might be used \ninside them.   Cons:   jersey2-guice hacks jersey locator lookup process which could potentially break on future versions  Guice child injector created for each request   Not declared services are managed by HK2 and you must be careful if you use guice AOP (as it works ony on beans, managed by guice)  Environment  and  Configuration  objects may be used only as  Provider  in eager singletons (as injector created in \ninitialization phase when these objects are not available)  Admin context not covered by  GuiceFilter  (no request scope injections under admin context calls).   Overall, integration feels transparent and super easy to learn (great!), but with a runtime price and caution in service definitions.",
            "title": "Dropwizard-guice"
        },
        {
            "location": "/guide/dg-migration/#guicey",
            "text": "Guicey prefer guice-first approach when everything is created by guice and registered in jersey as instance\n(so HK2 does not manage services, resources etc.).  In contrast to dropwizard-guice, guicey brings a lot of  new concepts  to better integrate guice.\nThis was necessary due to moving injector creation into dropwizard run phase\n(which is conceptually more correct).  Guicey abstracts user of knowing registration details and use  Installer - Extension  concept:\ninstallers did all required registrations automatically and hide boilerplate of managing extension instances with guice.       In pure dropwizard you need to:  environment.jersey().register(MyResource.class)  whereas in guicey\nyou just need to declare extension class:  bundle.extensions(MyResource.class)  and everything else would be automatic.   The same for all other extensions (tasks, health checks, jersey providers etc.): only extenion class is required for \nregistration.     Pros:   Classpath scan for automatic registrations  You can be sure that guice manage everything (no problems with AOP)  Simple extensions: only extension class required (and no need to know how to install it)   Wider range of supported extensions and ability to add more integrations (custom installers support)  Configuration bindings (by yaml path and internal configuration object)   GuiceFilter  works on both main and admin contexts  Integration tests support   Cons:   Resources must use  Provider  for all request-scoped injections  Special bundles ( GuiceyBundle ) should be used instead of dropwizard bundles ( Bundle )\n    in order to use guice-related features (but, as dropwizard-guice could discover dwopwizard bundles, \n    guicey could discover it's bundles too).  Extra diagnostic tools usage required for debug to understand internal state \n(more a pro, but additional thing to know, which is a con).           Overall, guicey has much more features, cleaner guice integration and very developer friendly (customizable and with extra tooling), \nbut with a coast of learning curve (additional concepts to know and use above dropwizard).",
            "title": "Guicey"
        },
        {
            "location": "/guide/dg-migration/#matrix",
            "text": "Only dropwizard-guice features present for comparison      feature  dropwizard-guice  guicey      Auto scan  +  +    Auto scan load class to inspect  -  +    Auto scan recognize  Bundle, ConfiguredBundle, HealthCheck, Task, @Provider, resource (@Path), ParamConverterProvider  all the same (and more) except dropwizard bundles    Resources (rest) recognition directly from guice bindings  +  -    Resources (rest) default scope  \"request\"  singleton    Dropwizard bundle lookup  +  - (but has custom bundles lookup)    Injections in dropwizard Bundle  +  -    Injector creation customization  +  +    Injector creation (dropwizard) phase  initialization  run    Access Bootstrap, Environment, Configuration in guice modules  -  +    GuiceFilter contexts  main  main, admin",
            "title": "Matrix"
        },
        {
            "location": "/guide/dg-migration/#migration",
            "text": "",
            "title": "Migration"
        },
        {
            "location": "/guide/dg-migration/#bundle",
            "text": "Bundle registration is almost the same, just more methods available:  bootstrap . addBundle ( GuiceBundle . builder () \n       . modules ( new   HelloWorldModule ())     // instead of addModule \n       . enableAutoConfig ( getClass (). getPackage (). getName ()) \n       // .setConfigClass(HelloWorldConfiguration.class) // not needed \n       . build ());",
            "title": "Bundle"
        },
        {
            "location": "/guide/dg-migration/#auto-scan",
            "text": "Note  In guicey,  auto scan  load all classes in providied package. The logic is - application classes would be loaded in any \ncase (in dropwizard-guice, classes are inspected by reading structure, without loading).   Auto scan will find and install extensions, with few exceptions (below)",
            "title": "Auto scan"
        },
        {
            "location": "/guide/dg-migration/#health-checks",
            "text": "Use  NamedHealthCheck  instead of  InjectableHealthCheck  as check class.",
            "title": "Health checks"
        },
        {
            "location": "/guide/dg-migration/#bundles",
            "text": "Guicey will not find dropwizard bundles: all required bundles must be directly registered in bootstrap.   Important  Guice injections will not work inside dropwizard bundles   But note, that bundles, used for features integrations may not be required as guicey perform automatic installation\n(removes redundant code).\nFor reusable bundles, consider using  GuiceyBundle  instead. Also, dropwzard bundles, registered in bootsrap  could be recognized as guicey bundles  (to provide extra guicey features).",
            "title": "Bundles"
        },
        {
            "location": "/guide/dg-migration/#resources-rest",
            "text": "First of all, note that resource bound only in guice module will not be discovered (no installation from \nguice declaration like it was in jersey1 guice integration).\nUse either classpath scan to install resources or specify them directly into bundle:  bundle.extensions(Resource1.class, Resoutrce2.class) .  You can still  delegate jersey extensions (resources, providers) management to HK2 , but they will lack\nguice aop and require extra dependency -  HK2-guice-bridge  (official HK guice bridge)   Important  Resources are  singletons  by default and so they will initialize with guice context \n( may be disabled ).\nYou may need to wrap some injections with  Provider . Alternatively, you may use  @LazyBinding ,  @HK2Managed , \nset  Development  stage for guice context or use prototype scope on resources ( @Prototype  or with  global option )",
            "title": "Resources (rest)"
        },
        {
            "location": "/guide/dg-migration/#diagnostic",
            "text": "Use  .printDiagnosticInfo()  to see all extensions, installed by classpath scan.  Use  .printLifecyclePhases()  to indicate lifecycle phases in logs (split logs to clearly \nunderstand onlgoing logic).",
            "title": "Diagnostic"
        },
        {
            "location": "/guide/dg-migration/#injector",
            "text": "Remember that injector is created at runtime phase when  Configuration  and  Environment  objects are already present,\nso no need to use  Provider  for them.    Also, you may use direct access for configuration values. See:  bundle.printConfigurationBindings()",
            "title": "Injector"
        },
        {
            "location": "/guide/dg-migration/#testing",
            "text": "Guicey provides more lightweight alternative to  DropwizardAppRule :  GuiceyAppRule  \n(starts only guice context without jetty). Use it for core business logic integration tests.  Also, note that you may replace any extension or bean in context before test\n( GuiceyConfigurationRule ).",
            "title": "Testing"
        },
        {
            "location": "/guide/dg-migration/#go-on",
            "text": "Read  getting started  to get in common with guicey concepts",
            "title": "Go on"
        },
        {
            "location": "/installers/resource/",
            "text": "Resource installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nResourceInstaller\n\n\n\n\nInstalls \nrest resources\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with jax-rs \n@Path\n annotation and register them as rest resources.\nGuice will manage resource creation, so you may think of it as usual guice bean.\n\n\n@Path\n(\n\"/res\"\n)\n\n\n@Produces\n(\n'\napplication\n/\njson\n'\n)\n\n\nclass\n \nSampleResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/sample\"\n)\n\n    \npublic\n \nResponse\n \nsample\n()\n \n{\n\n        \nreturn\n \nResponse\n.\nok\n(\nservice\n.\nresult\n()).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nResources registered as \nsingletons\n, when no explicit scope annotation is used.\nBehaviour could be disabled with \noption\n:\n\n.\noption\n(\nInstallerOptions\n.\nForceSingletonForJerseyExtensions\n,\n \nfalse\n)\n\n\n\n\n\n\nSpecial \n@Protptype\n scope annotation may be used to mark resources in prototype scope.\nIt is useful when \nguice servlet support is disabled\n (and so \n@RequestScoped\n could not be used). \n\n\nInterface recognition\n\u00b6\n\n\nClass will also be recognized if \n@Path\n annotation found on directly implemented interface.\n\n\n@Path\n(\n\"/res\"\n)\n\n\n@Produces\n(\n'\napplication\n/\njson\n'\n)\n\n\ninterface\n \nResourceContract\n \n{\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/sample\"\n)\n\n    \nString\n \nsample\n();\n\n\n}\n\n\n\nclass\n \nSampleResource\n \nimplements\n \nResourceContract\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \n@Override\n\n    \npublic\n \nResponse\n \nsample\n()\n \n{\n\n        \nreturn\n \nResponse\n.\nok\n(\nservice\n.\nresult\n()).\nbuild\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nAnnotations on interfaces are useful for \njersey client proxies\n  \n\n\nClient\n \nclient\n \n=\n \nClientBuilder\n.\nnewClient\n();\n\n\nResourceContract\n \nresource\n \n=\n \nWebResourceFactory\n\n    \n.\nnewResource\n(\nResourceContract\n.\nclass\n,\n \nclient\n.\ntarget\n(\n\"http://localhost:8080/\"\n));\n\n\n\n// call sample method on remote resource http://localhost:8080/res/sample\n\n\nString\n \nresult\n \n=\n \nresource\n.\nsample\n();\n\n\n\n\n\n\n\nJersey client proxies requires extra dependency \norg.glassfish.jersey.ext:jersey-proxy-client\n\n\n\n\nRequest scope bindings\n\u00b6\n\n\nIf you need request scoped objects, use \nProvider\n:\n\n\nclass\n \nSampleResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nProvider\n<\nHttpServletRequest\n>\n \nrequestProvider\n;\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/sample\"\n)\n\n    \npublic\n \nResponse\n \nsample\n()\n \n{\n\n        \nHttpServletRequest\n \nrequest\n \n=\n \nrequestProvider\n.\nget\n();\n\n        \n...\n\n    \n}\n\n\n\n\n\nSee \njersey objects, available for injection\n.\n\n\n@Context usage\n\u00b6\n\n\n@Context\n annotation usage is a common point of confusion. You can't use it for class fields: \n\n\n\n\nthis will not work\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@Context\n \nUriInfo\n \ninfo\n;\n\n\n}\n\n\n\n\n\n\n\nUse provider instead:\n\n\n\n\ncorrect way\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@Inject\n \nProvider\n<\nUriInfo\n>\n \ninfoProvider\n;\n\n\n}\n\n\n\n\n\n\n\nBut, you can use \n@Context\n on method parameters:\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@GET\n\n    \npublic\n \nResponse\n \nget\n(\n@Context\n \nUriInfo\n \ninfo\n)\n \n{\n \n...\n \n}\n\n\n}\n\n\n\n\n\nHK2 managed resource\n\u00b6\n\n\nIf resource class is annotated with \n@HK2Managed\n then jersey HK2 container will manage bean creation instead of guice. \nInjection of guice managed beans \ncould still be possible\n via registered \nHK2-guice-bridge\n,\nbut guice aop features will not work.\n\n\n\n\nNote\n\n\nYou can manage resources with \nHK2 by default\n,\nbut this will also affect all \njersey extensions\n\n\n\n\n@Path\n(\n\"/res\"\n)\n\n\n@Produces\n(\n'\napplication\n/\njson\n'\n)\n\n\n@HK2Managed\n\n\nclass\n \nSampleResource\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\n@Context\n annotation on field will work on HK2 managed bean:\n\n@Path\n()\n\n\n@HK2Managed\n\n\npublic\n \nclass\n \nMyResource\n \n{\n\n    \n@Context\n \nUriInfo\n \ninfo\n;\n\n\n}",
            "title": "Resource"
        },
        {
            "location": "/installers/resource/#resource-installer",
            "text": "CoreInstallersBundle /  ResourceInstaller   Installs  rest resources .",
            "title": "Resource installer"
        },
        {
            "location": "/installers/resource/#recognition",
            "text": "Detects classes annotated with jax-rs  @Path  annotation and register them as rest resources.\nGuice will manage resource creation, so you may think of it as usual guice bean.  @Path ( \"/res\" )  @Produces ( ' application / json ' )  class   SampleResource   { \n\n     @Inject \n     private   MyService   service ; \n\n     @GET \n     @Path ( \"/sample\" ) \n     public   Response   sample ()   { \n         return   Response . ok ( service . result ()). build (); \n     }  }    Resources registered as  singletons , when no explicit scope annotation is used.\nBehaviour could be disabled with  option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions ,   false )    Special  @Protptype  scope annotation may be used to mark resources in prototype scope.\nIt is useful when  guice servlet support is disabled  (and so  @RequestScoped  could not be used).",
            "title": "Recognition"
        },
        {
            "location": "/installers/resource/#interface-recognition",
            "text": "Class will also be recognized if  @Path  annotation found on directly implemented interface.  @Path ( \"/res\" )  @Produces ( ' application / json ' )  interface   ResourceContract   { \n\n     @GET \n     @Path ( \"/sample\" ) \n     String   sample ();  }  class   SampleResource   implements   ResourceContract   { \n\n     @Inject \n     private   MyService   service ; \n\n     @Override \n     public   Response   sample ()   { \n         return   Response . ok ( service . result ()). build (); \n     }  }   Annotations on interfaces are useful for  jersey client proxies     Client   client   =   ClientBuilder . newClient ();  ResourceContract   resource   =   WebResourceFactory \n     . newResource ( ResourceContract . class ,   client . target ( \"http://localhost:8080/\" ));  // call sample method on remote resource http://localhost:8080/res/sample  String   result   =   resource . sample ();    Jersey client proxies requires extra dependency  org.glassfish.jersey.ext:jersey-proxy-client",
            "title": "Interface recognition"
        },
        {
            "location": "/installers/resource/#request-scope-bindings",
            "text": "If you need request scoped objects, use  Provider :  class   SampleResource   { \n\n     @Inject \n     private   Provider < HttpServletRequest >   requestProvider ; \n\n     @GET \n     @Path ( \"/sample\" ) \n     public   Response   sample ()   { \n         HttpServletRequest   request   =   requestProvider . get (); \n         ... \n     }   See  jersey objects, available for injection .",
            "title": "Request scope bindings"
        },
        {
            "location": "/installers/resource/#context-usage",
            "text": "@Context  annotation usage is a common point of confusion. You can't use it for class fields:    this will not work  public   class   MyResource   { \n     @Context   UriInfo   info ;  }    Use provider instead:   correct way  public   class   MyResource   { \n     @Inject   Provider < UriInfo >   infoProvider ;  }    But, you can use  @Context  on method parameters:  public   class   MyResource   { \n     @GET \n     public   Response   get ( @Context   UriInfo   info )   {   ...   }  }",
            "title": "@Context usage"
        },
        {
            "location": "/installers/resource/#hk2-managed-resource",
            "text": "If resource class is annotated with  @HK2Managed  then jersey HK2 container will manage bean creation instead of guice. \nInjection of guice managed beans  could still be possible  via registered  HK2-guice-bridge ,\nbut guice aop features will not work.   Note  You can manage resources with  HK2 by default ,\nbut this will also affect all  jersey extensions   @Path ( \"/res\" )  @Produces ( ' application / json ' )  @HK2Managed  class   SampleResource   { \n     ...  }    @Context  annotation on field will work on HK2 managed bean: @Path ()  @HK2Managed  public   class   MyResource   { \n     @Context   UriInfo   info ;  }",
            "title": "HK2 managed resource"
        },
        {
            "location": "/installers/task/",
            "text": "Task installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nTaskInstaller\n        \n\n\n\n\nInstalls \ndropwizard tasks\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes extending dropwizard \nTask\n and register their instances in environment.\n\n\npublic\n \nclass\n \nMyTask\n \nextends\n \nTask\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \npublic\n \nTruncateDatabaseTask\n()\n \n{\n\n        \nsuper\n(\n\"mytask\"\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nexecute\n(\nImmutableMultimap\n<\nString\n,\n \nString\n>\n \nparameters\n,\n \nPrintWriter\n \noutput\n)\n \nthrows\n \nException\n \n{\n\n        \nservice\n.\ndoSomething\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nTask can be triggered with: \nhttp://localhost:8081/tasks/mytask",
            "title": "Task"
        },
        {
            "location": "/installers/task/#task-installer",
            "text": "CoreInstallersBundle /  TaskInstaller            Installs  dropwizard tasks .",
            "title": "Task installer"
        },
        {
            "location": "/installers/task/#recognition",
            "text": "Detects classes extending dropwizard  Task  and register their instances in environment.  public   class   MyTask   extends   Task   { \n\n     @Inject \n     private   MyService   service ; \n\n     public   TruncateDatabaseTask ()   { \n         super ( \"mytask\" ); \n     } \n\n     @Override \n     public   void   execute ( ImmutableMultimap < String ,   String >   parameters ,   PrintWriter   output )   throws   Exception   { \n         service . doSomething (); \n     }  }   Task can be triggered with:  http://localhost:8081/tasks/mytask",
            "title": "Recognition"
        },
        {
            "location": "/installers/managed/",
            "text": "Managed installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nManagedInstaller\n        \n\n\n\n\nInstalls \ndropwizard managed objects\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes implementing dropwizard \nManaged\n and register their instances in environment.\n\n\npublic\n \nclass\n \nMyService\n \nimplements\n \nManaged\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n        \n...\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstop\n()\n \nthrows\n \nException\n \n{\n\n        \n...\n\n    \n}\n\n\n}\n\n\n\n\n\nIt is perfect for implementing guice \nservice lifecycle\n.\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order managed objects.\n\n@Order\n(\n10\n)\n\n\npublic\n \nclass\n \nMyService\n \nimplements\n \nManaged",
            "title": "Managed"
        },
        {
            "location": "/installers/managed/#managed-installer",
            "text": "CoreInstallersBundle /  ManagedInstaller            Installs  dropwizard managed objects .",
            "title": "Managed installer"
        },
        {
            "location": "/installers/managed/#recognition",
            "text": "Detects classes implementing dropwizard  Managed  and register their instances in environment.  public   class   MyService   implements   Managed   { \n\n     @Override \n     public   void   start ()   throws   Exception   { \n         ... \n     } \n\n     @Override \n     public   void   stop ()   throws   Exception   { \n         ... \n     }  }   It is perfect for implementing guice  service lifecycle .   Tip  Use guicey  @Order  annotation to order managed objects. @Order ( 10 )  public   class   MyService   implements   Managed",
            "title": "Recognition"
        },
        {
            "location": "/installers/lifecycle/",
            "text": "Lifecycle installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nLifeCycleInstaller\n        \n\n\n\n\nInstalls \njetty LifeCycle\n implementations.\n\n\nRecognition\n\u00b6\n\n\nDetects classes implementing jetty \nLifeCycle\n interface and register their instances in environment.\n\n\npublic\n \nclass\n \nMyCycle\n \nimplements\n \nLifeCycle\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\nIn most cases it's better to use \nmanaged object\n instead of implementing lifecycle.\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order managed objects.  \n\n\n@Order\n(\n10\n)\n\n\npublic\n \nclass\n \nMyCycle\n \nimplements\n \nLifeCycle",
            "title": "Lifecycle"
        },
        {
            "location": "/installers/lifecycle/#lifecycle-installer",
            "text": "CoreInstallersBundle /  LifeCycleInstaller            Installs  jetty LifeCycle  implementations.",
            "title": "Lifecycle installer"
        },
        {
            "location": "/installers/lifecycle/#recognition",
            "text": "Detects classes implementing jetty  LifeCycle  interface and register their instances in environment.  public   class   MyCycle   implements   LifeCycle   { \n     ...  }   In most cases it's better to use  managed object  instead of implementing lifecycle.   Tip  Use guicey  @Order  annotation to order managed objects.    @Order ( 10 )  public   class   MyCycle   implements   LifeCycle",
            "title": "Recognition"
        },
        {
            "location": "/installers/healthcheck/",
            "text": "Health check installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nHealthCheckInstaller\n        \n\n\n\n\nInstalls \ndropwizard health check\n.\n\n\nRecognition\n\u00b6\n\n\nDetects classes extending guicey \nNamedHealthCheck\n and register their instances in environment.\nCustom base class is required, because default \nHealthCheck\n did not provide check name, which is required for registration.\n\n\npublic\n \nclass\n \nMyHealthCheck\n \nextends\n \nNamedHealthCheck\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nMyService\n \nservice\n;\n\n\n    \n@Override\n\n    \nprotected\n \nResult\n \ncheck\n()\n \nthrows\n \nException\n \n{\n\n        \nif\n \n(\nservice\n.\nisOk\n())\n \n{\n\n            \nreturn\n \nResult\n.\nhealthy\n();\n\n        \n}\n \nelse\n \n{\n\n            \nreturn\n \nResult\n.\nunhealthy\n(\n\"Service is not ok\"\n);\n\n        \n}\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nString\n \ngetName\n()\n \n{\n\n        \nreturn\n \n\"my-service\"\n;\n\n    \n}\n\n\n}",
            "title": "Health check"
        },
        {
            "location": "/installers/healthcheck/#health-check-installer",
            "text": "CoreInstallersBundle /  HealthCheckInstaller            Installs  dropwizard health check .",
            "title": "Health check installer"
        },
        {
            "location": "/installers/healthcheck/#recognition",
            "text": "Detects classes extending guicey  NamedHealthCheck  and register their instances in environment.\nCustom base class is required, because default  HealthCheck  did not provide check name, which is required for registration.  public   class   MyHealthCheck   extends   NamedHealthCheck   { \n\n     @Inject \n     private   MyService   service ; \n\n     @Override \n     protected   Result   check ()   throws   Exception   { \n         if   ( service . isOk ())   { \n             return   Result . healthy (); \n         }   else   { \n             return   Result . unhealthy ( \"Service is not ok\" ); \n         } \n     } \n\n     @Override \n     public   String   getName ()   { \n         return   \"my-service\" ; \n     }  }",
            "title": "Recognition"
        },
        {
            "location": "/installers/jersey-ext/",
            "text": "Jersey extension installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nJerseyProviderInstaller\n        \n\n\n\n\nInstalls various jersey extensions, usually annotated with jersey \n@Provider\n annotation and installed via \nenvironment\n.\njersey\n().\nregister\n()\n:\n\n\nFactory, ExceptionMapper, ValueFactoryProvider, InjectionResolver, \nParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, \nReaderInterceptor, WriterInterceptor, ContainerRequestFilter, \nContainerResponseFilter, DynamicFeature, ApplicationEventListener\n\n\n\n\n\nRecognition\n\u00b6\n\n\nDetects  classes annotated with jersey \n@javax.ws.rs.ext.Provider\n annotation and register their instances in jersey.\n\n\n\n\nExtensions registered as \nsingletons\n, when no explicit scope annotation is used.\nBehaviour could be disabled with \noption\n:\n\n.\noption\n(\nInstallerOptions\n.\nForceSingletonForJerseyExtensions\n,\n \nfalse\n)\n\n\n\n\n\n\nSpecial \n@Protptype\n scope annotation may be used to mark resources in prototype scope.\nIt is useful when \nguice servlet support is disabled\n (and so \n@RequestScoped\n could not be used).\n\n\nDue to specifics of \nHK2 integration\n, you may need to use:\n\n\n\n\n@HK2Managed\n to delegate bean creation to HK2\n\n\n@LazyBinding\n to delay bean creation to time when all dependencies will be available \n\n\njavax.inject.Provider\n as universal workaround (to wrap not immediately available dependency).\n\n\n\n\nOr you can enable \nHK2 management for jersey extensions by default\n.\nNote that this will affect \nresources\n too and guice aop will not work on jersey extensions.\n\n\nFactory\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\nhk2\n.\napi\n.\nFactory\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nAuthFactory\n \nimplements\n \nFactory\n<\nUser\n>{\n\n\n    \n@Override\n\n    \npublic\n \nUser\n \nprovide\n()\n \n{\n\n        \nreturn\n \nnew\n \nUser\n();\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndispose\n(\nUser\n \ninstance\n)\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nFactories in essence are very like guice (or javax.inject) providers (\nProvider\n).\n\n\n\n\nExample of using jersey abstract class instead of direct implementation:\n\n\n@Provider\n\n\npublic\n \nclass\n \nLocaleInjectableProvider\n \nextends\n \nAbstractContainerRequestValueFactory\n<\nLocale\n>\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \njavax\n.\ninject\n.\nProvider\n<\nHttpHeaders\n>\n \nrequest\n;\n\n\n    \n@Override\n\n    \npublic\n \nLocale\n \nprovide\n()\n \n{\n\n        \nfinal\n \nList\n<\nLocale\n>\n \nlocales\n \n=\n \nrequest\n.\nget\n().\ngetAcceptableLanguages\n();\n\n        \nreturn\n \nlocales\n.\nisEmpty\n()\n \n?\n \nLocale\n.\nUS\n \n:\n \nlocales\n.\nget\n(\n0\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nExceptionMapper\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nExceptionMapper\n (or extending abstract class implementing it). \nUseful for \nerror handling customization\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nDummyExceptionMapper\n \nimplements\n \nExceptionMapper\n<\nRuntimeException\n>\n \n{\n\n\n    \nprivate\n \nfinal\n \nLogger\n \nlogger\n \n=\n \nLoggerFactory\n.\ngetLogger\n(\nDummyExceptionMapper\n.\nclass\n);\n\n\n    \n@Override\n\n    \npublic\n \nResponse\n \ntoResponse\n(\nRuntimeException\n \ne\n)\n \n{\n\n        \nlogger\n.\ndebug\n(\n\"Problem while executing\"\n,\n \ne\n);\n\n        \nreturn\n \nResponse\n.\nstatus\n(\nResponse\n.\nStatus\n.\nBAD_REQUEST\n)\n\n                \n.\ntype\n(\nMediaType\n.\nTEXT_PLAIN\n)\n\n                \n.\nentity\n(\ne\n.\ngetMessage\n())\n\n                \n.\nbuild\n();\n\n    \n}\n\n\n\n}\n\n\n\n\n\nValueFactoryProvider\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\njersey\n.\nserver\n.\nspi\n.\ninternal\n.\nValueFactoryProvider\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\n@LazyBinding\n \n\npublic\n \nclass\n \nAuthFactoryProvider\n \nextends\n \nAbstractValueFactoryProvider\n \n{\n\n\n    \nprivate\n \nfinal\n \nFactory\n<\nUser\n>\n \nauthFactory\n;\n\n\n    \n@Inject\n\n    \npublic\n \nAuthFactoryProvider\n(\nfinal\n \nMultivaluedParameterExtractorProvider\n \nextractorProvider\n,\n\n                               \nfinal\n \nAuthFactory\n \nfactory\n,\n \n                               \nfinal\n \nServiceLocator\n \ninjector\n)\n \n{\n\n        \nsuper\n(\nextractorProvider\n,\n \ninjector\n,\n \nParameter\n.\nSource\n.\nUNKNOWN\n);\n\n        \nthis\n.\nauthFactory\n \n=\n \nfactory\n;\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nFactory\n<?>\n \ncreateValueFactory\n(\nParameter\n \nparameter\n)\n \n{\n\n        \nfinal\n \nAuth\n \nauth\n \n=\n \nparameter\n.\ngetAnnotation\n(\nAuth\n.\nclass\n);\n\n        \nreturn\n \nauth\n \n!=\n \nnull\n \n?\n \nauthFactory\n \n:\n \nnull\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\n@LazyBinding\n was used to delay provider creation because required dependency \nMultivaluedParameterExtractorProvider\n\n(by super class) will be available only after HK2 context creation (which is created after guice context). \nAnother option could be using \n@HK2Managed\n (instead of lazy) which will delegate bean creation to HK2.\n\n\n\n\nInjectionResolver\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\nhk2\n.\napi\n.\nInjectionResolver\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\n@LazyBinding\n\n\npublic\n \nclass\n \nAuthInjectionResolver\n \nextends\n \nParamInjectionResolver\n<\nAuth\n>\n \n{\n\n\n    \npublic\n \nAuthInjectionResolver\n()\n \n{\n\n        \nsuper\n(\nAuthFactoryProvider\n.\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\n@LazyBinding\n was used to delay provider creation because super class will require HK2 service locator, \nwhich is not yet available. \n@HK2Managed\n could also be used instead.\n\n\n\n\nParamConverterProvider\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nParamConverterProvider\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nFooParamConverter\n \nimplements\n \nParamConverterProvider\n \n{\n\n\n    \n@Override\n\n    \npublic\n \n<\nT\n>\n \nParamConverter\n<\nT\n>\n \ngetConverter\n(\nClass\n<\nT\n>\n \nrawType\n,\n \nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n)\n \n{\n\n        \nif\n \n(\nFoo\n.\nclass\n.\nisAssignableFrom\n(\nrawType\n))\n \n{\n\n            \nreturn\n \n(\nParamConverter\n<\nT\n>)\n \nnew\n \nFooConverter\n();\n\n        \n}\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n    \nprivate\n \nstatic\n \nclass\n \nFooConverter\n \nimplements\n \nParamConverter\n<\nFoo\n>\n \n{\n\n        \n@Override\n\n        \npublic\n \nFoo\n \nfromString\n(\nString\n \nvalue\n)\n \n{\n\n            \nreturn\n \nnew\n \nFoo\n(\nvalue\n);\n\n        \n}\n\n\n        \n@Override\n\n        \npublic\n \nString\n \ntoString\n(\nFoo\n \nvalue\n)\n \n{\n\n            \nreturn\n \nvalue\n.\nvalue\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nContextResolver\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nContextResolver\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyContextResolver\n \nimplements\n \nContextResolver\n<\nContext\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nContext\n \ngetContext\n(\nClass\n \ntype\n)\n \n{\n\n        \nreturn\n \nnew\n \nContext\n();\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nclass\n \nContext\n \n{}\n\n\n}\n\n\n\n\n\nMessageBodyReader\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nMessageBodyReader\n (or extending abstract class implementing it).\nUseful for \ncustom representations\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nTypeMessageBodyReader\n \nimplements\n \nMessageBodyReader\n<\nType\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nisReadable\n(\nClass\n<?>\n \ntype\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n)\n \n{\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nType\n \nreadFrom\n(\nClass\n<\nType\n>\n \ntype\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n,\n \nMultivaluedMap\n<\nString\n,\n \nString\n>\n \nhttpHeaders\n,\n \nInputStream\n \nentityStream\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nclass\n \nType\n \n{}\n\n\n}\n\n\n\n\n\nMessageBodyWriter\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nMessageBodyWriter\n (or extending abstract class implementing it).\nUseful for \ncustom representations\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nTypeMessageBodyWriter\n \nimplements\n \nMessageBodyWriter\n<\nType\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nisWriteable\n(\nClass\n<?>\n \ntype\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n)\n \n{\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nlong\n \ngetSize\n(\nType\n \ntype\n,\n \nClass\n<?>\n \ntype2\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n)\n \n{\n\n        \nreturn\n \n0\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nwriteTo\n(\nType\n \ntype\n,\n \nClass\n<?>\n \ntype2\n,\n \njava\n.\nlang\n.\nreflect\n.\nType\n \ngenericType\n,\n \nAnnotation\n[]\n \nannotations\n,\n \nMediaType\n \nmediaType\n,\n \nMultivaluedMap\n<\nString\n,\n \nObject\n>\n \nhttpHeaders\n,\n \nOutputStream\n \nentityStream\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nclass\n \nType\n \n{}\n\n\n}\n\n\n\n\n\nReaderInterceptor\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nReaderInterceptor\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyReaderInterceptor\n \nimplements\n \nReaderInterceptor\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nObject\n \naroundReadFrom\n(\nReaderInterceptorContext\n \ncontext\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nWriterInterceptor\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\next\n.\nWriterInterceptor\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyWriterInterceptor\n \nimplements\n \nWriterInterceptor\n \n{\n\n\n    \n@Override\n\n    \nvoid\n \naroundWriteTo\n(\nWriterInterceptorContext\n \ncontext\n)\n \nthrows\n \nIOException\n,\n \nWebApplicationException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\nContainerRequestFilter\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\ncontainer\n.\nContainerRequestFilter\n (or extending abstract class implementing it).\nUseful for \nrequest modifications\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyContainerRequestFilter\n \nimplements\n \nContainerRequestFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nfilter\n(\nContainerRequestContext\n \nrequestContext\n)\n \nthrows\n \nIOException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\nContainerResponseFilter\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\ncontainer\n.\nContainerResponseFilter\n (or extending abstract class implementing it).\nUseful for \nresponse modifications\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyContainerResponseFilter\n \nimplements\n \nContainerResponseFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nfilter\n(\nContainerRequestContext\n \nrequestContext\n,\n \nContainerResponseContext\n \nresponseContext\n)\n \nthrows\n \nIOException\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\nDynamicFeature\n\u00b6\n\n\nAny class implementing \njavax\n.\nws\n.\nrs\n.\ncontainer\n.\nDynamicFeature\n (or extending abstract class implementing it).\nUseful for conditional \nactivation of filters\n.\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyDynamicFeature\n \nimplements\n \nDynamicFeature\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nconfigure\n(\nResourceInfo\n \nresourceInfo\n,\n \nFeatureContext\n \ncontext\n)\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\nApplicationEventListener\n\u00b6\n\n\nAny class implementing \norg\n.\nglassfish\n.\njersey\n.\nserver\n.\nmonitoring\n.\nApplicationEventListener\n (or extending abstract class implementing it).\n\n\n@Provider\n\n\npublic\n \nclass\n \nMyApplicationEventListener\n \nimplements\n \nApplicationEventListener\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonEvent\n(\nApplicationEvent\n \nevent\n)\n \n{\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nRequestEventListener\n \nonRequest\n(\nRequestEvent\n \nrequestEvent\n)\n \n{\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n}",
            "title": "Jersey extension"
        },
        {
            "location": "/installers/jersey-ext/#jersey-extension-installer",
            "text": "CoreInstallersBundle /  JerseyProviderInstaller            Installs various jersey extensions, usually annotated with jersey  @Provider  annotation and installed via  environment . jersey (). register () :  Factory, ExceptionMapper, ValueFactoryProvider, InjectionResolver, \nParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, \nReaderInterceptor, WriterInterceptor, ContainerRequestFilter, \nContainerResponseFilter, DynamicFeature, ApplicationEventListener",
            "title": "Jersey extension installer"
        },
        {
            "location": "/installers/jersey-ext/#recognition",
            "text": "Detects  classes annotated with jersey  @javax.ws.rs.ext.Provider  annotation and register their instances in jersey.   Extensions registered as  singletons , when no explicit scope annotation is used.\nBehaviour could be disabled with  option : . option ( InstallerOptions . ForceSingletonForJerseyExtensions ,   false )    Special  @Protptype  scope annotation may be used to mark resources in prototype scope.\nIt is useful when  guice servlet support is disabled  (and so  @RequestScoped  could not be used).  Due to specifics of  HK2 integration , you may need to use:   @HK2Managed  to delegate bean creation to HK2  @LazyBinding  to delay bean creation to time when all dependencies will be available   javax.inject.Provider  as universal workaround (to wrap not immediately available dependency).   Or you can enable  HK2 management for jersey extensions by default .\nNote that this will affect  resources  too and guice aop will not work on jersey extensions.",
            "title": "Recognition"
        },
        {
            "location": "/installers/jersey-ext/#factory",
            "text": "Any class implementing  org . glassfish . hk2 . api . Factory  (or extending abstract class implementing it).  @Provider  public   class   AuthFactory   implements   Factory < User >{ \n\n     @Override \n     public   User   provide ()   { \n         return   new   User (); \n     } \n\n     @Override \n     public   void   dispose ( User   instance )   { \n     }  }    Factories in essence are very like guice (or javax.inject) providers ( Provider ).   Example of using jersey abstract class instead of direct implementation:  @Provider  public   class   LocaleInjectableProvider   extends   AbstractContainerRequestValueFactory < Locale >   { \n\n     @Inject \n     private   javax . inject . Provider < HttpHeaders >   request ; \n\n     @Override \n     public   Locale   provide ()   { \n         final   List < Locale >   locales   =   request . get (). getAcceptableLanguages (); \n         return   locales . isEmpty ()   ?   Locale . US   :   locales . get ( 0 ); \n     }  }",
            "title": "Factory"
        },
        {
            "location": "/installers/jersey-ext/#exceptionmapper",
            "text": "Any class implementing  javax . ws . rs . ext . ExceptionMapper  (or extending abstract class implementing it). \nUseful for  error handling customization .  @Provider  public   class   DummyExceptionMapper   implements   ExceptionMapper < RuntimeException >   { \n\n     private   final   Logger   logger   =   LoggerFactory . getLogger ( DummyExceptionMapper . class ); \n\n     @Override \n     public   Response   toResponse ( RuntimeException   e )   { \n         logger . debug ( \"Problem while executing\" ,   e ); \n         return   Response . status ( Response . Status . BAD_REQUEST ) \n                 . type ( MediaType . TEXT_PLAIN ) \n                 . entity ( e . getMessage ()) \n                 . build (); \n     }  }",
            "title": "ExceptionMapper"
        },
        {
            "location": "/installers/jersey-ext/#valuefactoryprovider",
            "text": "Any class implementing  org . glassfish . jersey . server . spi . internal . ValueFactoryProvider  (or extending abstract class implementing it).  @Provider  @LazyBinding   public   class   AuthFactoryProvider   extends   AbstractValueFactoryProvider   { \n\n     private   final   Factory < User >   authFactory ; \n\n     @Inject \n     public   AuthFactoryProvider ( final   MultivaluedParameterExtractorProvider   extractorProvider , \n                                final   AuthFactory   factory ,  \n                                final   ServiceLocator   injector )   { \n         super ( extractorProvider ,   injector ,   Parameter . Source . UNKNOWN ); \n         this . authFactory   =   factory ; \n     } \n\n     @Override \n     protected   Factory <?>   createValueFactory ( Parameter   parameter )   { \n         final   Auth   auth   =   parameter . getAnnotation ( Auth . class ); \n         return   auth   !=   null   ?   authFactory   :   null ; \n     }  }    Note  @LazyBinding  was used to delay provider creation because required dependency  MultivaluedParameterExtractorProvider \n(by super class) will be available only after HK2 context creation (which is created after guice context). \nAnother option could be using  @HK2Managed  (instead of lazy) which will delegate bean creation to HK2.",
            "title": "ValueFactoryProvider"
        },
        {
            "location": "/installers/jersey-ext/#injectionresolver",
            "text": "Any class implementing  org . glassfish . hk2 . api . InjectionResolver  (or extending abstract class implementing it).  @Provider  @LazyBinding  public   class   AuthInjectionResolver   extends   ParamInjectionResolver < Auth >   { \n\n     public   AuthInjectionResolver ()   { \n         super ( AuthFactoryProvider . class ); \n     }  }    Note  @LazyBinding  was used to delay provider creation because super class will require HK2 service locator, \nwhich is not yet available.  @HK2Managed  could also be used instead.",
            "title": "InjectionResolver"
        },
        {
            "location": "/installers/jersey-ext/#paramconverterprovider",
            "text": "Any class implementing  javax . ws . rs . ext . ParamConverterProvider  (or extending abstract class implementing it).  @Provider  public   class   FooParamConverter   implements   ParamConverterProvider   { \n\n     @Override \n     public   < T >   ParamConverter < T >   getConverter ( Class < T >   rawType ,   Type   genericType ,   Annotation []   annotations )   { \n         if   ( Foo . class . isAssignableFrom ( rawType ))   { \n             return   ( ParamConverter < T >)   new   FooConverter (); \n         } \n         return   null ; \n     } \n\n     private   static   class   FooConverter   implements   ParamConverter < Foo >   { \n         @Override \n         public   Foo   fromString ( String   value )   { \n             return   new   Foo ( value ); \n         } \n\n         @Override \n         public   String   toString ( Foo   value )   { \n             return   value . value ; \n         } \n     }  }",
            "title": "ParamConverterProvider"
        },
        {
            "location": "/installers/jersey-ext/#contextresolver",
            "text": "Any class implementing  javax . ws . rs . ext . ContextResolver  (or extending abstract class implementing it).  @Provider  public   class   MyContextResolver   implements   ContextResolver < Context >   { \n\n     @Override \n     public   Context   getContext ( Class   type )   { \n         return   new   Context (); \n     } \n\n     public   static   class   Context   {}  }",
            "title": "ContextResolver"
        },
        {
            "location": "/installers/jersey-ext/#messagebodyreader",
            "text": "Any class implementing  javax . ws . rs . ext . MessageBodyReader  (or extending abstract class implementing it).\nUseful for  custom representations .  @Provider  public   class   TypeMessageBodyReader   implements   MessageBodyReader < Type >   { \n\n     @Override \n     public   boolean   isReadable ( Class <?>   type ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType )   { \n         return   false ; \n     } \n\n     @Override \n     public   Type   readFrom ( Class < Type >   type ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType ,   MultivaluedMap < String ,   String >   httpHeaders ,   InputStream   entityStream )   throws   IOException ,   WebApplicationException   { \n         return   null ; \n     } \n\n     public   static   class   Type   {}  }",
            "title": "MessageBodyReader"
        },
        {
            "location": "/installers/jersey-ext/#messagebodywriter",
            "text": "Any class implementing  javax . ws . rs . ext . MessageBodyWriter  (or extending abstract class implementing it).\nUseful for  custom representations .  @Provider  public   class   TypeMessageBodyWriter   implements   MessageBodyWriter < Type >   { \n\n     @Override \n     public   boolean   isWriteable ( Class <?>   type ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType )   { \n         return   false ; \n     } \n\n     @Override \n     public   long   getSize ( Type   type ,   Class <?>   type2 ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType )   { \n         return   0 ; \n     } \n\n     @Override \n     public   void   writeTo ( Type   type ,   Class <?>   type2 ,   java . lang . reflect . Type   genericType ,   Annotation []   annotations ,   MediaType   mediaType ,   MultivaluedMap < String ,   Object >   httpHeaders ,   OutputStream   entityStream )   throws   IOException ,   WebApplicationException   { \n     } \n\n     public   static   class   Type   {}  }",
            "title": "MessageBodyWriter"
        },
        {
            "location": "/installers/jersey-ext/#readerinterceptor",
            "text": "Any class implementing  javax . ws . rs . ext . ReaderInterceptor  (or extending abstract class implementing it).  @Provider  public   class   MyReaderInterceptor   implements   ReaderInterceptor   { \n\n     @Override \n     public   Object   aroundReadFrom ( ReaderInterceptorContext   context )   throws   IOException ,   WebApplicationException   { \n         return   null ; \n     }  }",
            "title": "ReaderInterceptor"
        },
        {
            "location": "/installers/jersey-ext/#writerinterceptor",
            "text": "Any class implementing  javax . ws . rs . ext . WriterInterceptor  (or extending abstract class implementing it).  @Provider  public   class   MyWriterInterceptor   implements   WriterInterceptor   { \n\n     @Override \n     void   aroundWriteTo ( WriterInterceptorContext   context )   throws   IOException ,   WebApplicationException   { \n     }  }",
            "title": "WriterInterceptor"
        },
        {
            "location": "/installers/jersey-ext/#containerrequestfilter",
            "text": "Any class implementing  javax . ws . rs . container . ContainerRequestFilter  (or extending abstract class implementing it).\nUseful for  request modifications .  @Provider  public   class   MyContainerRequestFilter   implements   ContainerRequestFilter   { \n\n     @Override \n     public   void   filter ( ContainerRequestContext   requestContext )   throws   IOException   { \n     }  }",
            "title": "ContainerRequestFilter"
        },
        {
            "location": "/installers/jersey-ext/#containerresponsefilter",
            "text": "Any class implementing  javax . ws . rs . container . ContainerResponseFilter  (or extending abstract class implementing it).\nUseful for  response modifications .  @Provider  public   class   MyContainerResponseFilter   implements   ContainerResponseFilter   { \n\n     @Override \n     public   void   filter ( ContainerRequestContext   requestContext ,   ContainerResponseContext   responseContext )   throws   IOException   { \n     }  }",
            "title": "ContainerResponseFilter"
        },
        {
            "location": "/installers/jersey-ext/#dynamicfeature",
            "text": "Any class implementing  javax . ws . rs . container . DynamicFeature  (or extending abstract class implementing it).\nUseful for conditional  activation of filters .  @Provider  public   class   MyDynamicFeature   implements   DynamicFeature   { \n\n     @Override \n     public   void   configure ( ResourceInfo   resourceInfo ,   FeatureContext   context )   { \n     }  }",
            "title": "DynamicFeature"
        },
        {
            "location": "/installers/jersey-ext/#applicationeventlistener",
            "text": "Any class implementing  org . glassfish . jersey . server . monitoring . ApplicationEventListener  (or extending abstract class implementing it).  @Provider  public   class   MyApplicationEventListener   implements   ApplicationEventListener   { \n\n     @Override \n     public   void   onEvent ( ApplicationEvent   event )   { \n     } \n\n     @Override \n     public   RequestEventListener   onRequest ( RequestEvent   requestEvent )   { \n         return   null ; \n     }  }",
            "title": "ApplicationEventListener"
        },
        {
            "location": "/installers/jersey-feature/",
            "text": "Jersey feature installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nJerseyFeatureInstaller\n\n\n\n\nRecognition\n\u00b6\n\n\nDetects classes implementing \njavax\n.\nws\n.\nrs\n.\ncore\n.\nFeature\n and register their instances in jersey.\n\n\nIt may be useful to configure jersey inside guice components:\n\n\npublic\n \nclass\n \nMyClass\n \n{\n\n    \n...\n   \n    \npublic\n \nstatic\n \nclass\n \nConfigurationFeature\n \nimplements\n \nFeature\n \n{\n\n        \n@Override\n\n        \npublic\n \nboolean\n \nconfigure\n(\nFeatureContext\n \ncontext\n)\n \n{\n\n            \ncontext\n.\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n            \ncontext\n.\nregister\n(\nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n            \nreturn\n \ntrue\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nInner classes are also recognized by classpath scan.\n\n\n\n\nBut often the same could be achieved by injecting \nEnvironment\n instance.\n\n\n@Singleton\n\n\npublic\n \nclass\n \nMyClass\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nMyClass\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\n\n                \nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n    \n}\n    \n\n}",
            "title": "Jersey feature"
        },
        {
            "location": "/installers/jersey-feature/#jersey-feature-installer",
            "text": "CoreInstallersBundle /  JerseyFeatureInstaller",
            "title": "Jersey feature installer"
        },
        {
            "location": "/installers/jersey-feature/#recognition",
            "text": "Detects classes implementing  javax . ws . rs . core . Feature  and register their instances in jersey.  It may be useful to configure jersey inside guice components:  public   class   MyClass   { \n     ...    \n     public   static   class   ConfigurationFeature   implements   Feature   { \n         @Override \n         public   boolean   configure ( FeatureContext   context )   { \n             context . register ( RolesAllowedDynamicFeature . class ); \n             context . register ( new   AuthValueFactoryProvider . Binder ( User . class )); \n             return   true ; \n         } \n     }  }    Inner classes are also recognized by classpath scan.   But often the same could be achieved by injecting  Environment  instance.  @Singleton  public   class   MyClass   { \n\n     @Inject \n     public   MyClass ( Environment   environment )   { \n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n         environment . jersey (). register ( \n                 new   AuthValueFactoryProvider . Binder ( User . class )); \n     }      }",
            "title": "Recognition"
        },
        {
            "location": "/installers/eager/",
            "text": "Eager singleton installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nEagerSingletonInstaller\n\n\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@EagerSingleton\n annotation and register them in guice injector. \nIt is equivalent of eager singleton registration \nbind\n(\ntype\n).\nasEagerSingleton\n()\n.\n\n\nUseful in case when you have bean not injected by other beans (so guice can't register\nit through aot). Normally, you would have to manually register such bean in module.\n\n\nMost likely, such bean will contain initialization logic. \nIdeal for cases not directly covered by installers. For example:\n\n\n@EagerSingleton\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nLifeCycle\n.\nListener\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nMyListener\n(\nEnvironment\n \nenvironment\n)\n \n{\n\n        \nenvironment\n.\nlifecicle\n.\naddListener\n(\nthis\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nClass will be recognized by eager singleton installer, environment object injected by guice and we manually register listener.\n\n\nMay be used in conjunction with \n@PostConstruct\n annotations (e.g. using \next-annotations\n):\ninstaller finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should\nbe used for quick prototyping only.",
            "title": "Eager singleton"
        },
        {
            "location": "/installers/eager/#eager-singleton-installer",
            "text": "CoreInstallersBundle /  EagerSingletonInstaller",
            "title": "Eager singleton installer"
        },
        {
            "location": "/installers/eager/#recognition",
            "text": "Detects classes annotated with  @EagerSingleton  annotation and register them in guice injector. \nIt is equivalent of eager singleton registration  bind ( type ). asEagerSingleton () .  Useful in case when you have bean not injected by other beans (so guice can't register\nit through aot). Normally, you would have to manually register such bean in module.  Most likely, such bean will contain initialization logic. \nIdeal for cases not directly covered by installers. For example:  @EagerSingleton  public   class   MyListener   implements   LifeCycle . Listener   { \n\n     @Inject \n     public   MyListener ( Environment   environment )   { \n         environment . lifecicle . addListener ( this ); \n     }  }   Class will be recognized by eager singleton installer, environment object injected by guice and we manually register listener.  May be used in conjunction with  @PostConstruct  annotations (e.g. using  ext-annotations ):\ninstaller finds and register bean and post construct annotation could run some logic. Note: this approach is against guice philosophy and should\nbe used for quick prototyping only.",
            "title": "Recognition"
        },
        {
            "location": "/installers/plugin/",
            "text": "Plugin installer\n\u00b6\n\n\n\n\nCoreInstallersBundle / \nPluginInstaller\n\n\n\n\nAllows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case).  \n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with guicey \n@Plugin\n annotation and bind them into set or map using guice \n\nmultibindings\n mechanism.\n\n\nSuppose you have plugin interface \npublic\n \ninterface\n \nPluginInterface\n.\n\n\nAnnotate plugin implementations with \n@Plugin\n:\n\n\n@Plugin\n(\nPluginInterface\n.\nclass\n)\n\n\npublic\n \nclass\n \nPluginImpl1\n \nimplements\n \nPluginInterface\n\n\n\n\n\nNow all implementations could be autowired as\n\n\n@Inject\n \nSet\n<\nPluginInterface\n>\n \nplugins\n;\n\n\n\n\n\n\n\nWarning\n\n\nAt least one implementation must be provided because otherwise guicey will not be able to register\nSet\n binding and guice startup will fail.\nIf no plugins situation is possible, then you will have to manually register empty (default)\nplugins binding: \n\npublic\n \nclass\n \nMyModule\n \nextends\n \nAbstractModule\n \n{\n    \n    \n@Override\n\n    \nprotected\n \nconfigure\n()\n \n{\n\n        \nMultibinder\n.\nnewSetBinder\n(\nbinder\n(),\n \nPluginInterface\n.\nclass\n);\n\n    \n}\n\n\n}\n\n\n\nGuicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting.\n\n\n\n\nNamed plugins\n\u00b6\n\n\nSometimes it's required to have named plugin mapping: to bind, Map\n instead of simple set.\nFor example, when you have multiple authorization providers and each provider implementation must be registered with name.\n\n\nMost likely, you would use enum for keys:\n\n\npublic\n \nenum\n \nPluginKey\n \n{\n\n    \nFIRST\n,\n \nSECOND\n\n\n}\n\n\n\n\n\nCustom plugin annotation needs to be defined to use new keys:\n\n\n@Plugin\n(\nPluginInterface\n.\nclass\n)\n\n\n@Target\n(\nElementType\n.\nTYPE\n)\n\n\n@Retention\n(\nRetentionPolicy\n.\nRUNTIME\n)\n\n\npublic\n \n@interface\n \nMyPlugin\n \n{\n\n    \nPluginKey\n \nvalue\n();\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nAnnotation itself is annotated with \n@Plugin\n, defining target plugin interface.\nGuicey will detect your custom annotation usage by analyzing its annotations. \n\n\n\n\nAnnotating plugin implementation:\n\n\n@MyPlugin\n(\nPluginKey\n.\nFIRST\n)\n\n\npublic\n \nclass\n \nPluginImpl1\n \nimplements\n \nPluginInterface\n\n\n\n\n\nAll plugins could be referenced as map:\n\n\n@Inject\n \nMap\n<\nPluginKey\n,\n \nPluginInterface\n>\n \nplugins\n;\n\n\n\n\n\n\n\nNote\n\n\nIt's not required to use enum as key. Any type could be set in your custom annotation. \nFor example, string key could be used: \n\npublic\n \n@interface\n \nMyPlugin\n \n{\n\n    \nString\n \nvalue\n();\n\n\n}\n\n\n\n@MyPlugin\n(\n\"first\"\n)\n\n\npublic\n \nclass\n \nPluginImpl1\n \nimplements\n \nPluginInterface\n\n\n\n@Inject\n \nMap\n<\nString\n,\n \nPluginInterface\n>\n \nplugins\n;\n\n\n\n\n\n\n\n\nWarning\n\n\nAs with simple plugin bindings, at least one plugin must be registered so guice could create map binding.\nOtherwise, you need to manually declare empty (default) plugnis map binding:\n\nMapBinder\n.\nnewMapBinder\n(\nbinder\n,\n \nkeyType\n,\n \npluginType\n);",
            "title": "Plugin"
        },
        {
            "location": "/installers/plugin/#plugin-installer",
            "text": "CoreInstallersBundle /  PluginInstaller   Allows automatic gathering of multiple implementations of some interface into bindable set or map (dynamic plugins case).",
            "title": "Plugin installer"
        },
        {
            "location": "/installers/plugin/#recognition",
            "text": "Detects classes annotated with guicey  @Plugin  annotation and bind them into set or map using guice  multibindings  mechanism.  Suppose you have plugin interface  public   interface   PluginInterface .  Annotate plugin implementations with  @Plugin :  @Plugin ( PluginInterface . class )  public   class   PluginImpl1   implements   PluginInterface   Now all implementations could be autowired as  @Inject   Set < PluginInterface >   plugins ;    Warning  At least one implementation must be provided because otherwise guicey will not be able to register\nSet  binding and guice startup will fail.\nIf no plugins situation is possible, then you will have to manually register empty (default)\nplugins binding:  public   class   MyModule   extends   AbstractModule   {     \n     @Override \n     protected   configure ()   { \n         Multibinder . newSetBinder ( binder (),   PluginInterface . class ); \n     }  }  \nGuicey can't register empty plugin set for you because it's impossible to know what plugins are you expecting.",
            "title": "Recognition"
        },
        {
            "location": "/installers/plugin/#named-plugins",
            "text": "Sometimes it's required to have named plugin mapping: to bind, Map  instead of simple set.\nFor example, when you have multiple authorization providers and each provider implementation must be registered with name.  Most likely, you would use enum for keys:  public   enum   PluginKey   { \n     FIRST ,   SECOND  }   Custom plugin annotation needs to be defined to use new keys:  @Plugin ( PluginInterface . class )  @Target ( ElementType . TYPE )  @Retention ( RetentionPolicy . RUNTIME )  public   @interface   MyPlugin   { \n     PluginKey   value ();  }    Note  Annotation itself is annotated with  @Plugin , defining target plugin interface.\nGuicey will detect your custom annotation usage by analyzing its annotations.    Annotating plugin implementation:  @MyPlugin ( PluginKey . FIRST )  public   class   PluginImpl1   implements   PluginInterface   All plugins could be referenced as map:  @Inject   Map < PluginKey ,   PluginInterface >   plugins ;    Note  It's not required to use enum as key. Any type could be set in your custom annotation. \nFor example, string key could be used:  public   @interface   MyPlugin   { \n     String   value ();  }  @MyPlugin ( \"first\" )  public   class   PluginImpl1   implements   PluginInterface  @Inject   Map < String ,   PluginInterface >   plugins ;     Warning  As with simple plugin bindings, at least one plugin must be registered so guice could create map binding.\nOtherwise, you need to manually declare empty (default) plugnis map binding: MapBinder . newMapBinder ( binder ,   keyType ,   pluginType );",
            "title": "Named plugins"
        },
        {
            "location": "/installers/servlet/",
            "text": "Web servlet installer\n\u00b6\n\n\n\n\nWebInstallersBundle / \nWebServletInstaller\n        \n\n\n\n\n\n\nWeb installers\n are not enabled by default. Enable it with \nbundle\n.\nuseWebInstallers\n()\n.\n\n\n\n\nRegister new servlet in main or admin contexts.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@javax.servlet.annotation.WebServlet\n annotation and register them in dropwizard environment.\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\nOnly the following annotation properties are supported: \nname\n, \nurlPatterns\n (or \nvalue\n), \ninitParams\n, \nasyncSupported\n.\n\n\nServlet name is not required. If name not provided, it will be generated as:\n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off.\nFor example, for class \"MyCoolServlet\" generated name will be \".mycool\".\n\n\n\n\nWarning\n\n\nOne or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings.\nIf you want to throw exception in this case, use special option:\n\nbundle\n.\noption\n(\nInstallersOptions\n.\nDenyServletRegistrationWithClash\n,\n \ntrue\n)\n\n\n\nNote that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later \n(and so exception will not be thrown).\n\n\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order servlets registration.\n\n@Order\n(\n10\n)\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n\n\n\n\n\nThere is a difference between using servlet installer and registering servlets with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\n\n\nInstaller use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).       \n\n\nAsync\n\u00b6\n\n\nExample of async servlet definition:\n\n\n@WebServlet\n(\nurlPatterns\n \n=\n \n\"/async\"\n,\n \nasyncSupported\n \n=\n \ntrue\n)\n\n\npublic\n \nclass\n \nAsyncServlet\n \nextends\n \nHttpServlet\n \n{\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \ndoGet\n(\nHttpServletRequest\n \nreq\n,\n \nHttpServletResponse\n \nresp\n)\n \nthrows\n \nServletException\n,\n \nIOException\n \n{\n\n        \nfinal\n \nAsyncContext\n \ncontext\n \n=\n \nreq\n.\nstartAsync\n();\n\n        \ncontext\n.\nstart\n(()\n \n->\n \n{\n\n            \ncontext\n.\ngetResponse\n().\ngetWriter\n().\nwrite\n(\n\"done!\"\n);\n\n            \ncontext\n.\ncomplete\n();\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets.\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, installer target application context. If you want to install into admin context then \nuse guicey \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n{\n \n...\n \n}\n\n\n\n\n\nWill install servlet in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebServlet\n(\n\"/mapped\"\n)\n\n\npublic\n \nclass\n \nMyServlet\n \nextends\n \nHttpServlet\n \n{\n \n...\n \n}",
            "title": "Web servlet"
        },
        {
            "location": "/installers/servlet/#web-servlet-installer",
            "text": "WebInstallersBundle /  WebServletInstaller             Web installers  are not enabled by default. Enable it with  bundle . useWebInstallers () .   Register new servlet in main or admin contexts.",
            "title": "Web servlet installer"
        },
        {
            "location": "/installers/servlet/#recognition",
            "text": "Detects classes annotated with  @javax.servlet.annotation.WebServlet  annotation and register them in dropwizard environment.  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet   {   ...   }   Only the following annotation properties are supported:  name ,  urlPatterns  (or  value ),  initParams ,  asyncSupported .  Servlet name is not required. If name not provided, it will be generated as:\n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"servlet\" then it will be cut off.\nFor example, for class \"MyCoolServlet\" generated name will be \".mycool\".   Warning  One or more specified servlet url patterns may clash with already registered servlets. By default, such clashes are just logged as warnings.\nIf you want to throw exception in this case, use special option: bundle . option ( InstallersOptions . DenyServletRegistrationWithClash ,   true )  \nNote that clash detection relies on servlets registration order so clash may not appear on your servlet but on some other servlet manually registered later \n(and so exception will not be thrown).    Tip  Use guicey  @Order  annotation to order servlets registration. @Order ( 10 )  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet     There is a difference between using servlet installer and registering servlets with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).  Installer use guice only for servlet instance creation and register this instance directly in dropwizard environment (using annotation metadata).",
            "title": "Recognition"
        },
        {
            "location": "/installers/servlet/#async",
            "text": "Example of async servlet definition:  @WebServlet ( urlPatterns   =   \"/async\" ,   asyncSupported   =   true )  public   class   AsyncServlet   extends   HttpServlet   { \n\n     @Override \n     protected   void   doGet ( HttpServletRequest   req ,   HttpServletResponse   resp )   throws   ServletException ,   IOException   { \n         final   AsyncContext   context   =   req . startAsync (); \n         context . start (()   ->   { \n             context . getResponse (). getWriter (). write ( \"done!\" ); \n             context . complete (); \n         }); \n     }  }    Note that guice servlet module does not allow using async servlets, so installer is the only option to install async servlets.",
            "title": "Async"
        },
        {
            "location": "/installers/servlet/#admin-context",
            "text": "By default, installer target application context. If you want to install into admin context then \nuse guicey  @AdminContext  annotation.  For example:   @AdminContext  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet   {   ...   }   Will install servlet in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebServlet ( \"/mapped\" )  public   class   MyServlet   extends   HttpServlet   {   ...   }",
            "title": "Admin context"
        },
        {
            "location": "/installers/filter/",
            "text": "Web filter installer\n\u00b6\n\n\n\n\nWebInstallersBundle / \nWebFilterInstaller\n        \n\n\n\n\n\n\nWeb installers\n are not enabled by default. Enable it with \nbundle\n.\nuseWebInstallers\n()\n.\n\n\n\n\nRegister new filter in main or admin contexts.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@javax.servlet.annotation.WebFilter\n annotation and register them in dropwizard environment.\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}\n\n\n\n\n\nOnly the following annotation properties are supported: \nfilterName\n, \nurlPatterns\n (or \nvalue\n), \nservletNames\n, \ndispatcherTypes\n, \ninitParams\n, \nasyncSupported\n.\n\n\n\n\nWarning\n\n\nUrl patterns and servlet names can't be used at the same time.\n\n\n\n\nFilter name is not required. If name not provided, then it will be generated as: \n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off.\nFor example, for class \"MyCoolFilter\" generated name will be \".mycool\".\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order servlets registration.\n\n@Order\n(\n10\n)\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}\n\n\n\n\n\n\nThere is a difference between using filter installer and registering filters with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).\n\n\nInstaller use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata).       \n\n\nAsync\n\u00b6\n\n\nExample of async filter definition:\n\n\n@WebFilter\n(\nurlPatterns\n \n=\n \n\"/asyncfilter\"\n,\n \nasyncSupported\n \n=\n \ntrue\n)\n\n\npublic\n \nclass\n \nAsyncFilter\n \nimplements\n \nFilter\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninit\n(\nFilterConfig\n \nfilterConfig\n)\n \nthrows\n \nServletException\n \n{\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndoFilter\n(\nServletRequest\n \nrequest\n,\n \nServletResponse\n \nresponse\n,\n \nFilterChain\n \nchain\n)\n \nthrows\n \nIOException\n,\n \nServletException\n \n{\n\n        \nfinal\n \nAsyncContext\n \ncontext\n \n=\n \nrequest\n.\nstartAsync\n();\n\n        \ncontext\n.\nstart\n(()\n \n->\n \n{\n\n            \ncontext\n.\ngetResponse\n().\nwriter\n.\nwrite\n(\n\"done!\"\n);\n\n            \ncontext\n.\ncomplete\n();\n\n        \n});\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ndestroy\n()\n \n{\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote that guice servlet module does not allow using async filters, so installer is the only option to install async filters.\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, installer target application context. If you want to install into admin context then \nuse guicey \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}\n\n\n\n\n\nWill install filter in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebFilter\n(\n\"/some/*\"\n)\n\n\npublic\n \nclass\n \nMyFilter\n \nimplements\n \nFilter\n \n{\n \n...\n \n}",
            "title": "Web filter"
        },
        {
            "location": "/installers/filter/#web-filter-installer",
            "text": "WebInstallersBundle /  WebFilterInstaller             Web installers  are not enabled by default. Enable it with  bundle . useWebInstallers () .   Register new filter in main or admin contexts.",
            "title": "Web filter installer"
        },
        {
            "location": "/installers/filter/#recognition",
            "text": "Detects classes annotated with  @javax.servlet.annotation.WebFilter  annotation and register them in dropwizard environment.  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }   Only the following annotation properties are supported:  filterName ,  urlPatterns  (or  value ),  servletNames ,  dispatcherTypes ,  initParams ,  asyncSupported .   Warning  Url patterns and servlet names can't be used at the same time.   Filter name is not required. If name not provided, then it will be generated as: \n. (dot) at the beginning to indicate generated name, followed by lower-cased class name. If class ends with \"filter\" then it will be cut off.\nFor example, for class \"MyCoolFilter\" generated name will be \".mycool\".   Tip  Use guicey  @Order  annotation to order servlets registration. @Order ( 10 )  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }    There is a difference between using filter installer and registering filters with guice servlet module:\nguice servlet module handles registered servlets and filters internally in GuiceFilter (which is installed by guicey in both app and admin contexts).\nAs a side effect, there are some compatibility issues between guice servlets and native filters (rare and usually not blocking, but still).  Installer use guice only for filter instance creation and register this instance directly in dropwizard environment (using annotation metadata).",
            "title": "Recognition"
        },
        {
            "location": "/installers/filter/#async",
            "text": "Example of async filter definition:  @WebFilter ( urlPatterns   =   \"/asyncfilter\" ,   asyncSupported   =   true )  public   class   AsyncFilter   implements   Filter   { \n\n     @Override \n     public   void   init ( FilterConfig   filterConfig )   throws   ServletException   { \n     } \n\n     @Override \n     public   void   doFilter ( ServletRequest   request ,   ServletResponse   response ,   FilterChain   chain )   throws   IOException ,   ServletException   { \n         final   AsyncContext   context   =   request . startAsync (); \n         context . start (()   ->   { \n             context . getResponse (). writer . write ( \"done!\" ); \n             context . complete (); \n         }); \n     } \n\n     @Override \n     public   void   destroy ()   { \n     }  }    Note that guice servlet module does not allow using async filters, so installer is the only option to install async filters.",
            "title": "Async"
        },
        {
            "location": "/installers/filter/#admin-context",
            "text": "By default, installer target application context. If you want to install into admin context then \nuse guicey  @AdminContext  annotation.  For example:   @AdminContext  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }   Will install filter in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebFilter ( \"/some/*\" )  public   class   MyFilter   implements   Filter   {   ...   }",
            "title": "Admin context"
        },
        {
            "location": "/installers/listener/",
            "text": "Web listener installer\n\u00b6\n\n\n\n\nWebInstallersBundle / \nWebListenerInstaller\n        \n\n\n\n\n\n\nWeb installers\n are not enabled by default. Enable it with \nbundle\n.\nuseWebInstallers\n()\n.\n\n\n\n\nRegister new web listener in main or admin contexts.\n\n\nRecognition\n\u00b6\n\n\nDetects classes annotated with \n@javax.servlet.annotation.WebListener\n annotation and register them in dropwizard environment.\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n,\n \nServletRequestListener\n \n{...}\n\n\n\n\n\n\n\nListener could implement multiple listener interfaces and all types will be registered.\n\n\n\n\nSupported listeners (the same as declared in annotation):\n\n\n\n\njavax.servlet.ServletContextListener\n\n\njavax.servlet.ServletContextAttributeListener\n\n\njavax.servlet.ServletRequestListener\n\n\njavax.servlet.ServletRequestAttributeListener\n\n\njavax.servlet.http.HttpSessionListener\n\n\njavax.servlet.http.HttpSessionAttributeListener\n\n\njavax.servlet.http.HttpSessionIdListener\n\n\n\n\n\n\nBy default, dropwizard is not configured to support sessions. If you define session listeners without configured session support\nthen warning will be logged (and servlet listeners will actually not be registered).\nError is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work).\nIf you want to throw exception in such case, use special option:\n\nbundle\n.\noption\n(\nInstallersOptions\n.\nDenySessionListenersWithoutSession\n,\n \ntrue\n)\n\n\n\n\n\n\n\n\nTip\n\n\nUse guicey \n@Order\n annotation to order servlets registration.\n\n@Order\n(\n10\n)\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n \n{...}\n\n\n\n\n\n\nAdmin context\n\u00b6\n\n\nBy default, installer target application context. If you want to install into admin context then \nuse guicey \n@AdminContext\n annotation.\n\n\nFor example: \n\n\n@AdminContext\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n \n{...}\n\n\n\n\n\nWill install filter in admin context only.\n\n\nIf you want to install in both contexts use andMain attribute:\n\n\n@AdminContext\n(\nandMain\n \n=\n \ntrue\n)\n\n\n@WebListener\n\n\npublic\n \nclass\n \nMyListener\n \nimplements\n \nServletContextListener\n \n{...}",
            "title": "Web listener"
        },
        {
            "location": "/installers/listener/#web-listener-installer",
            "text": "WebInstallersBundle /  WebListenerInstaller             Web installers  are not enabled by default. Enable it with  bundle . useWebInstallers () .   Register new web listener in main or admin contexts.",
            "title": "Web listener installer"
        },
        {
            "location": "/installers/listener/#recognition",
            "text": "Detects classes annotated with  @javax.servlet.annotation.WebListener  annotation and register them in dropwizard environment.  @WebListener  public   class   MyListener   implements   ServletContextListener ,   ServletRequestListener   {...}    Listener could implement multiple listener interfaces and all types will be registered.   Supported listeners (the same as declared in annotation):   javax.servlet.ServletContextListener  javax.servlet.ServletContextAttributeListener  javax.servlet.ServletRequestListener  javax.servlet.ServletRequestAttributeListener  javax.servlet.http.HttpSessionListener  javax.servlet.http.HttpSessionAttributeListener  javax.servlet.http.HttpSessionIdListener    By default, dropwizard is not configured to support sessions. If you define session listeners without configured session support\nthen warning will be logged (and servlet listeners will actually not be registered).\nError is not thrown to let writing more universal bundles with listener extensions (session related extensions will simply not work).\nIf you want to throw exception in such case, use special option: bundle . option ( InstallersOptions . DenySessionListenersWithoutSession ,   true )     Tip  Use guicey  @Order  annotation to order servlets registration. @Order ( 10 )  @WebListener  public   class   MyListener   implements   ServletContextListener   {...}",
            "title": "Recognition"
        },
        {
            "location": "/installers/listener/#admin-context",
            "text": "By default, installer target application context. If you want to install into admin context then \nuse guicey  @AdminContext  annotation.  For example:   @AdminContext  @WebListener  public   class   MyListener   implements   ServletContextListener   {...}   Will install filter in admin context only.  If you want to install in both contexts use andMain attribute:  @AdminContext ( andMain   =   true )  @WebListener  public   class   MyListener   implements   ServletContextListener   {...}",
            "title": "Admin context"
        },
        {
            "location": "/examples/authentication/",
            "text": "Authentication\n\u00b6\n\n\nExample of \ndropwizard authentication\n usage with guice.\n\n\nSimple auth\n\u00b6\n\n\nUsing \ndropwizard oauth\n example as basement.\nOther auth types are configured in similar way.\n\n\n@Provider\n\n\npublic\n \nclass\n \nOAuthDynamicFeature\n \nextends\n \nAuthDynamicFeature\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nOAuthDynamicFeature\n(\nOAuthAuthenticator\n \nauthenticator\n,\n \n                                \nUserAuthorizer\n \nauthorizer\n,\n \n                                \nEnvironment\n \nenvironment\n)\n \n{\n\n        \nsuper\n(\nnew\n \nOAuthCredentialAuthFilter\n.\nBuilder\n<\nUser\n>()\n\n                \n.\nsetAuthenticator\n(\nauthenticator\n)\n\n                \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                \n.\nsetPrefix\n(\n\"Bearer\"\n)\n\n                \n.\nbuildAuthFilter\n());\n\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n    \n}\n\n\n    \n// classes below may be external (internal for simplicity)\n\n\n    \n@Singleton\n\n    \npublic\n \nstatic\n \nclass\n \nOAuthAuthenticator\n \nimplements\n \nAuthenticator\n<\nString\n,\n \nUser\n>\n \n{\n\n\n        \n@Override\n\n        \npublic\n \nOptional\n<\nUser\n>\n \nauthenticate\n(\nString\n \ncredentials\n)\n \nthrows\n \nAuthenticationException\n \n{\n\n            \nreturn\n \nOptional\n.\nfromNullable\n(\n\"valid\"\n.\nequals\n(\ncredentials\n)\n \n?\n \nnew\n \nUser\n()\n \n:\n \nnull\n);\n        \n}\n\n    \n}\n\n\n    \n@Singleton\n\n    \npublic\n \nstatic\n \nclass\n \nUserAuthorizer\n \nimplements\n \nAuthorizer\n<\nUser\n>\n \n{\n\n        \n@Override\n\n        \npublic\n \nboolean\n \nauthorize\n(\nUser\n \nuser\n,\n \nString\n \nrole\n)\n \n{\n\n            \nreturn\n \nuser\n.\ngetName\n().\nequals\n(\n\"good-guy\"\n)\n \n&&\n \nrole\n.\nequals\n(\n\"ADMIN\"\n);\n\n        \n}\n\n    \n}\n   \n\n}\n\n\n\n\n\nThe class is automatically picked up by the \njersey installer\n.\n\nOAuthAuthenticator\n and \nOAuthAuthorizer\n are simple guice beans (no special installation required).\n\n\nConstructor injection is used to obtain required guice managed instances and then configure\nauthentication the same way as described in dropwizard docs.\n\n\nIf auto configuration is enabled, then the class will be resolved and installed automatically.\n\n\nChained auth\n\u00b6\n\n\nChained auth\n can be used to support different authentication schemes.\n\n\nIntegration approach is the same as in simple case:\n\n\n@Provider\n\n\npublic\n \nclass\n \nChainedAuthDynamicFeature\n \nextends\n \nAuthDynamicFeature\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nChainedAuthDynamicFeature\n(\nBasicAuthenticator\n \nbasicAuthenticator\n,\n\n                                      \nOAuthAuthenticator\n \noauthAuthenticator\n,\n \n                                      \nUserAuthorizer\n \nauthorizer\n,\n \n                                      \nEnvironment\n \nenvironment\n)\n \n{\n\n        \nsuper\n(\nnew\n \nChainedAuthFilter\n(\nArrays\n.\nasList\n(\n\n                \nnew\n \nBasicCredentialAuthFilter\n.\nBuilder\n<>()\n\n                            \n.\nsetAuthenticator\n(\nbasicAuthenticator\n)\n\n                            \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                            \n.\nsetPrefix\n(\n\"Basic\"\n)\n\n                            \n.\nbuildAuthFilter\n(),\n\n                \nnew\n \nOAuthCredentialAuthFilter\n.\nBuilder\n<>()\n\n                            \n.\nsetAuthenticator\n(\noauthAuthenticator\n)\n\n                            \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                            \n.\nsetPrefix\n(\n\"Bearer\"\n)\n\n                            \n.\nbuildAuthFilter\n()\n\n        \n)));\n                \n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nnew\n \nAuthValueFactoryProvider\n.\nBinder\n(\nUser\n.\nclass\n));\n\n    \n}\n   \n\n}\n\n\n\n\n\nPolymorphic auth\n\u00b6\n\n\nPolymorphic auth\n allows using different auth schemes simultaneously.\n\n\nIntegration approach is the same as in simple case:\n\n\n@Provider\n\n\npublic\n \nclass\n \nPolyAuthDynamicFeature\n \nextends\n \nPolymorphicAuthDynamicFeature\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nPolyAuthDynamicFeature\n(\nBasicAuthenticator\n \nbasicAuthenticator\n,\n\n                                   \nOauthAuthenticator\n \noauthAuthenticator\n,\n\n                                   \nUserAuthorizer\n \nauthorizer\n,\n\n                                   \nEnvironment\n \nenvironment\n)\n \n{\n\n        \nsuper\n(\nImmutableMap\n.\nof\n(\n\n                  \nBasicPrincipal\n.\nclass\n,\n \nnew\n \nBasicCredentialAuthFilter\n.\nBuilder\n<\nBasicPrincipal\n>()\n\n                                                \n.\nsetAuthenticator\n(\nbasicAuthenticator\n)\n\n                                                \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                                                \n.\nsetRealm\n(\n\"SUPER SECRET STUFF\"\n)\n\n                                                \n.\nbuildAuthFilter\n(),\n\n                  \nOAuthPrincipal\n.\nclass\n,\n \nnew\n \nOAuthCredentialAuthFilter\n.\nBuilder\n<\nOAuthPrincipal\n>()\n\n                                                \n.\nsetAuthenticator\n(\noauthAuthenticator\n)\n\n                                                \n.\nsetAuthorizer\n(\nauthorizer\n)\n\n                                                \n.\nsetPrefix\n(\n\"Bearer\"\n)\n\n                                                \n.\nbuildAuthFilter\n()));\n             \n\n        \nfinal\n \nAbstractBinder\n \nbinder\n \n=\n \nnew\n \nPolymorphicAuthValueFactoryProvider\n.\nBinder\n<>(\n\n            \nImmutableSet\n.\nof\n(\nBasicPrincipal\n.\nclass\n,\n \nOAuthPrincipal\n.\nclass\n));\n\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nbinder\n);\n\n        \nenvironment\n.\njersey\n().\nregister\n(\nRolesAllowedDynamicFeature\n.\nclass\n);\n\n    \n}\n\n\n}",
            "title": "Authentication"
        },
        {
            "location": "/examples/authentication/#authentication",
            "text": "Example of  dropwizard authentication  usage with guice.",
            "title": "Authentication"
        },
        {
            "location": "/examples/authentication/#simple-auth",
            "text": "Using  dropwizard oauth  example as basement.\nOther auth types are configured in similar way.  @Provider  public   class   OAuthDynamicFeature   extends   AuthDynamicFeature   { \n\n     @Inject \n     public   OAuthDynamicFeature ( OAuthAuthenticator   authenticator ,  \n                                 UserAuthorizer   authorizer ,  \n                                 Environment   environment )   { \n         super ( new   OAuthCredentialAuthFilter . Builder < User >() \n                 . setAuthenticator ( authenticator ) \n                 . setAuthorizer ( authorizer ) \n                 . setPrefix ( \"Bearer\" ) \n                 . buildAuthFilter ()); \n\n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n         environment . jersey (). register ( new   AuthValueFactoryProvider . Binder ( User . class )); \n     } \n\n     // classes below may be external (internal for simplicity) \n\n     @Singleton \n     public   static   class   OAuthAuthenticator   implements   Authenticator < String ,   User >   { \n\n         @Override \n         public   Optional < User >   authenticate ( String   credentials )   throws   AuthenticationException   { \n             return   Optional . fromNullable ( \"valid\" . equals ( credentials )   ?   new   User ()   :   null );          } \n     } \n\n     @Singleton \n     public   static   class   UserAuthorizer   implements   Authorizer < User >   { \n         @Override \n         public   boolean   authorize ( User   user ,   String   role )   { \n             return   user . getName (). equals ( \"good-guy\" )   &&   role . equals ( \"ADMIN\" ); \n         } \n     }     }   The class is automatically picked up by the  jersey installer . OAuthAuthenticator  and  OAuthAuthorizer  are simple guice beans (no special installation required).  Constructor injection is used to obtain required guice managed instances and then configure\nauthentication the same way as described in dropwizard docs.  If auto configuration is enabled, then the class will be resolved and installed automatically.",
            "title": "Simple auth"
        },
        {
            "location": "/examples/authentication/#chained-auth",
            "text": "Chained auth  can be used to support different authentication schemes.  Integration approach is the same as in simple case:  @Provider  public   class   ChainedAuthDynamicFeature   extends   AuthDynamicFeature   { \n\n     @Inject \n     public   ChainedAuthDynamicFeature ( BasicAuthenticator   basicAuthenticator , \n                                       OAuthAuthenticator   oauthAuthenticator ,  \n                                       UserAuthorizer   authorizer ,  \n                                       Environment   environment )   { \n         super ( new   ChainedAuthFilter ( Arrays . asList ( \n                 new   BasicCredentialAuthFilter . Builder <>() \n                             . setAuthenticator ( basicAuthenticator ) \n                             . setAuthorizer ( authorizer ) \n                             . setPrefix ( \"Basic\" ) \n                             . buildAuthFilter (), \n                 new   OAuthCredentialAuthFilter . Builder <>() \n                             . setAuthenticator ( oauthAuthenticator ) \n                             . setAuthorizer ( authorizer ) \n                             . setPrefix ( \"Bearer\" ) \n                             . buildAuthFilter () \n         )));                 \n\n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n         environment . jersey (). register ( new   AuthValueFactoryProvider . Binder ( User . class )); \n     }     }",
            "title": "Chained auth"
        },
        {
            "location": "/examples/authentication/#polymorphic-auth",
            "text": "Polymorphic auth  allows using different auth schemes simultaneously.  Integration approach is the same as in simple case:  @Provider  public   class   PolyAuthDynamicFeature   extends   PolymorphicAuthDynamicFeature   { \n\n     @Inject \n     public   PolyAuthDynamicFeature ( BasicAuthenticator   basicAuthenticator , \n                                    OauthAuthenticator   oauthAuthenticator , \n                                    UserAuthorizer   authorizer , \n                                    Environment   environment )   { \n         super ( ImmutableMap . of ( \n                   BasicPrincipal . class ,   new   BasicCredentialAuthFilter . Builder < BasicPrincipal >() \n                                                 . setAuthenticator ( basicAuthenticator ) \n                                                 . setAuthorizer ( authorizer ) \n                                                 . setRealm ( \"SUPER SECRET STUFF\" ) \n                                                 . buildAuthFilter (), \n                   OAuthPrincipal . class ,   new   OAuthCredentialAuthFilter . Builder < OAuthPrincipal >() \n                                                 . setAuthenticator ( oauthAuthenticator ) \n                                                 . setAuthorizer ( authorizer ) \n                                                 . setPrefix ( \"Bearer\" ) \n                                                 . buildAuthFilter ()));              \n\n         final   AbstractBinder   binder   =   new   PolymorphicAuthValueFactoryProvider . Binder <>( \n             ImmutableSet . of ( BasicPrincipal . class ,   OAuthPrincipal . class )); \n\n         environment . jersey (). register ( binder ); \n         environment . jersey (). register ( RolesAllowedDynamicFeature . class ); \n     }  }",
            "title": "Polymorphic auth"
        },
        {
            "location": "/examples/governator/",
            "text": "Governator integration\n\u00b6\n\n\nInclude the \nNetflix Governator\n dependency:\n\n\ncompile\n \n\"com.netflix.governator:governator:1.5.11\"\n\n\n\n\n\nGovernator \nowns injector creation\n, \nso we need to create custom guicey \nInjectorFactory\n\n\npublic\n \nclass\n \nGovernatorInjectorFactory\n \nimplements\n \nInjectorFactory\n \n{\n\n    \npublic\n \nInjector\n \ncreateInjector\n(\nfinal\n \nStage\n \nstage\n,\n \nfinal\n \nIterable\n<?\n \nextends\n \nModule\n>\n \nmodules\n)\n \n{\n\n        \nreturn\n \nLifecycleInjector\n.\nbuilder\n().\nwithModules\n(\nmodules\n).\ninStage\n(\nstage\n).\nbuild\n().\ncreateInjector\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nConfigure the new factory in the guice bundle:\n\n\n@Override\n\n\npublic\n \nvoid\n \ninitialize\n(\nBootstrap\n<\nConfiguration\n>\n \nbootstrap\n)\n \n{\n\n    \nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\ninjectorFactory\n(\nnew\n \nGovernatorInjectorFactory\n())\n\n            \n.\nenableAutoConfig\n(\n\"com.mycompany.myapp\"\n)\n\n            \n...\n\n            \n.\nbuild\n()\n\n    \n);\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nAuto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package).\n\n\n\n\nGovernator Lifecycle\n\u00b6\n\n\nMany Governator enhancements are only available when the Governator \nLifecycleManager\n \nis properly \nstarted and closed\n \nwith the application. \n\n\nUse dropwizard's \nmanaged object\n \nto control governator lifecycle:\n\n\nimport\n \nio.dropwizard.lifecycle.Managed\n;\n\n\nimport\n \nru.vyarus.dropwizard.guice.GuiceBundle\n;\n\n\nimport\n \ncom.netflix.governator.lifecycle.LifecycleManager\n;\n\n\nimport\n \njavax.inject.Inject\n;\n\n\n\npublic\n \nclass\n \nGovernatorLifecycle\n \nimplements\n \nManaged\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nLifecycleManager\n \nmanager\n;\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstart\n()\n \nthrows\n \nException\n \n{\n\n        \nmanager\n.\nstart\n();\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstop\n()\n \nthrows\n \nException\n \n{\n\n        \nmanager\n.\nclose\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nGuicey will find this managed bean, create governator injector (using a custom factory), create a managed bean instance and register it in dropwizard. \nThis will \"bind\" the governator lifecycle to the dropwizard lifecycle.\n\n\n\n\nNote\n\n\nIf you need to control the order which the managed beans are started, use the \n@Order annotation\n.",
            "title": "Governator"
        },
        {
            "location": "/examples/governator/#governator-integration",
            "text": "Include the  Netflix Governator  dependency:  compile   \"com.netflix.governator:governator:1.5.11\"   Governator  owns injector creation , \nso we need to create custom guicey  InjectorFactory  public   class   GovernatorInjectorFactory   implements   InjectorFactory   { \n     public   Injector   createInjector ( final   Stage   stage ,   final   Iterable <?   extends   Module >   modules )   { \n         return   LifecycleInjector . builder (). withModules ( modules ). inStage ( stage ). build (). createInjector (); \n     }  }   Configure the new factory in the guice bundle:  @Override  public   void   initialize ( Bootstrap < Configuration >   bootstrap )   { \n     bootstrap . addBundle ( GuiceBundle . builder () \n             . injectorFactory ( new   GovernatorInjectorFactory ()) \n             . enableAutoConfig ( \"com.mycompany.myapp\" ) \n             ... \n             . build () \n     );  }    Note  Auto scan is enabled and managed bean, described below, will be discovered and installed automatically (assuming its inside scanned package).",
            "title": "Governator integration"
        },
        {
            "location": "/examples/governator/#governator-lifecycle",
            "text": "Many Governator enhancements are only available when the Governator  LifecycleManager  \nis properly  started and closed  \nwith the application.   Use dropwizard's  managed object  \nto control governator lifecycle:  import   io.dropwizard.lifecycle.Managed ;  import   ru.vyarus.dropwizard.guice.GuiceBundle ;  import   com.netflix.governator.lifecycle.LifecycleManager ;  import   javax.inject.Inject ;  public   class   GovernatorLifecycle   implements   Managed   { \n\n     @Inject \n     private   LifecycleManager   manager ; \n\n     @Override \n     public   void   start ()   throws   Exception   { \n         manager . start (); \n     } \n\n     @Override \n     public   void   stop ()   throws   Exception   { \n         manager . close (); \n     }  }   Guicey will find this managed bean, create governator injector (using a custom factory), create a managed bean instance and register it in dropwizard. \nThis will \"bind\" the governator lifecycle to the dropwizard lifecycle.   Note  If you need to control the order which the managed beans are started, use the  @Order annotation .",
            "title": "Governator Lifecycle"
        },
        {
            "location": "/examples/hibernate/",
            "text": "Hibernate integration\n\u00b6\n\n\nExample of \ndropwizard-hibernate\n bundle usage with guicey.\n\n\n\n\nExample \nsource code\n\n\n\n\nConfiguration\n\u00b6\n\n\nAdditional dependencies required:\n\n\n    \ncompile\n \n'io.dropwizard:dropwizard-hibernate:1.3.0'\n\n    \ncompile\n \n'com.h2database:h2:1.4.193'\n\n\n\n\n\n\n\nH2 used as the simplest example.\n\n\n\n\nOverall configuration is exactly the same as described in \ndropwizard docs\n, \nbut extracted to separate class for simplicity:\n\n\npublic\n \nclass\n \nHbnBundle\n \nextends\n \nHibernateBundle\n<\nHbnAppConfiguration\n>\n \n{\n\n\n    \npublic\n \nHbnBundle\n()\n \n{\n\n        \nsuper\n(\nSample\n.\nclass\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nPooledDataSourceFactory\n \ngetDataSourceFactory\n(\nHbnAppConfiguration\n \nconfiguration\n)\n \n{\n\n        \nreturn\n \nconfiguration\n.\ngetDataSourceFactory\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nAll model classes are configured inside the constructor: \nsuper\n(\nSample\n.\nclass\n);\n\n\n\n\nConfiguration class:\n\n\npublic\n \nclass\n \nHbnAppConfiguration\n \nextends\n \nConfiguration\n \n{\n\n    \n@Valid\n\n    \n@NotNull\n\n    \n@JsonProperty\n\n    \nprivate\n \nDataSourceFactory\n \ndatabase\n \n=\n \nnew\n \nDataSourceFactory\n();\n\n\n    \npublic\n \nDataSourceFactory\n \ngetDataSourceFactory\n()\n \n{\n\n        \nreturn\n \ndatabase\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nConfiguration file for in-memory database and automatic schema creation:\n\n\ndatabase\n:\n\n  \ndriverClass\n:\n \norg.h2.Driver\n\n  \nuser\n:\n \nsa\n\n  \npassword\n:\n\n  \nurl\n:\n \njdbc:h2:mem:sample\n\n\n  \nproperties\n:\n\n    \ncharSet\n:\n \nUTF-8\n\n    \nhibernate.dialect\n:\n \norg.hibernate.dialect.H2Dialect\n\n    \nhibernate.hbm2ddl.auto\n:\n \ncreate\n\n\n\n\n\nGuice integration\n\u00b6\n\n\nGuice module used to provide SessionFactory instance into guice context:\n\n\npublic\n \nclass\n \nHbnModule\n \nextends\n \nAbstractModule\n \n{\n\n\n    \nprivate\n \nfinal\n \nHbnBundle\n \nhbnBundle\n;\n\n\n    \npublic\n \nHbnModule\n(\nHbnBundle\n \nhbnBundle\n)\n \n{\n\n        \nthis\n.\nhbnBundle\n \n=\n \nhbnBundle\n;\n\n    \n}\n\n\n    \n@Override\n\n    \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n        \nbind\n(\nSessionFactory\n.\nclass\n).\ntoInstance\n(\nhbnBundle\n.\ngetSessionFactory\n());\n\n    \n}\n\n\n}\n\n\n\n\n\nApplication:\n\n\n@Override\n\n\npublic\n \nvoid\n \ninitialize\n(\nBootstrap\n<\nHbnAppConfiguration\n>\n \nbootstrap\n)\n \n{\n\n    \nfinal\n \nHbnBundle\n \nhibernate\n \n=\n \nnew\n \nHbnBundle\n();\n\n    \n// register hbn bundle before guice to make sure factory initialized before guice context start\n\n    \nbootstrap\n.\naddBundle\n(\nhibernate\n);\n\n    \nbootstrap\n.\naddBundle\n(\nGuiceBundle\n.\nbuilder\n()\n\n            \n.\nenableAutoConfig\n(\n\"com.myapp.package\"\n)\n\n            \n.\nmodules\n(\nnew\n \nHbnModule\n(\nhibernate\n))\n\n            \n.\nbuild\n());\n\n\n}\n\n\n\n\n\nUsage\n\u00b6\n\n\nIt is simpler to use dropwizard \nAbstractDAO\n for hibernate logic:\n\n\npublic\n \nclass\n \nSampleService\n \nextends\n \nAbstractDAO\n<\nSample\n>\n \n{\n\n\n    \n@Inject\n\n    \npublic\n \nSampleService\n(\nSessionFactory\n \nfactory\n)\n \n{\n\n        \nsuper\n(\nfactory\n);\n\n    \n}\n\n\n    \npublic\n \nvoid\n \ncreate\n(\nSample\n \nsample\n)\n \n{\n\n        \nreturn\n \npersist\n(\nsample\n);\n\n    \n}\n\n\n    \npublic\n \nList\n<\nSample\n>\n \nfindAll\n()\n \n{\n\n        \nreturn\n \nlist\n(\ncurrentSession\n().\ncreateQuery\n(\n\"from Sample\"\n));\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nYou will need to use dropwizard \n@UnitOfWork\n annotation to declare transaction scope.\n\n\n\n\nFor example:\n\n\n@Path\n(\n\"/sample\"\n)\n\n\n@Produces\n(\n\"application/json\"\n)\n\n\npublic\n \nclass\n \nSampleResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nSampleService\n \nservice\n;\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/\"\n)\n\n    \n@Timed\n\n    \n@UnitOfWork\n\n    \npublic\n \nResponse\n \ndoStaff\n()\n \n{\n\n        \nfinal\n \nSample\n \nsample\n \n=\n \nnew\n \nSample\n(\n\"sample\"\n);\n\n        \nservice\n.\ncreate\n(\nsample\n);\n\n        \nfinal\n \nList\n<\nSample\n>\n \nres\n \n=\n \nservice\n.\nfindAll\n();\n\n        \n// using response to render entities inside unit of work and avoid lazy load exceptions\n\n        \nreturn\n \nResponse\n.\nok\n(\nres\n).\nbuild\n();\n\n    \n}\n\n\n}",
            "title": "Hibernate"
        },
        {
            "location": "/examples/hibernate/#hibernate-integration",
            "text": "Example of  dropwizard-hibernate  bundle usage with guicey.   Example  source code",
            "title": "Hibernate integration"
        },
        {
            "location": "/examples/hibernate/#configuration",
            "text": "Additional dependencies required:       compile   'io.dropwizard:dropwizard-hibernate:1.3.0' \n     compile   'com.h2database:h2:1.4.193'    H2 used as the simplest example.   Overall configuration is exactly the same as described in  dropwizard docs , \nbut extracted to separate class for simplicity:  public   class   HbnBundle   extends   HibernateBundle < HbnAppConfiguration >   { \n\n     public   HbnBundle ()   { \n         super ( Sample . class ); \n     } \n\n     @Override \n     public   PooledDataSourceFactory   getDataSourceFactory ( HbnAppConfiguration   configuration )   { \n         return   configuration . getDataSourceFactory (); \n     }  }    Note  All model classes are configured inside the constructor:  super ( Sample . class );   Configuration class:  public   class   HbnAppConfiguration   extends   Configuration   { \n     @Valid \n     @NotNull \n     @JsonProperty \n     private   DataSourceFactory   database   =   new   DataSourceFactory (); \n\n     public   DataSourceFactory   getDataSourceFactory ()   { \n         return   database ; \n     }  }   Configuration file for in-memory database and automatic schema creation:  database : \n   driverClass :   org.h2.Driver \n   user :   sa \n   password : \n   url :   jdbc:h2:mem:sample \n\n   properties : \n     charSet :   UTF-8 \n     hibernate.dialect :   org.hibernate.dialect.H2Dialect \n     hibernate.hbm2ddl.auto :   create",
            "title": "Configuration"
        },
        {
            "location": "/examples/hibernate/#guice-integration",
            "text": "Guice module used to provide SessionFactory instance into guice context:  public   class   HbnModule   extends   AbstractModule   { \n\n     private   final   HbnBundle   hbnBundle ; \n\n     public   HbnModule ( HbnBundle   hbnBundle )   { \n         this . hbnBundle   =   hbnBundle ; \n     } \n\n     @Override \n     protected   void   configure ()   { \n         bind ( SessionFactory . class ). toInstance ( hbnBundle . getSessionFactory ()); \n     }  }   Application:  @Override  public   void   initialize ( Bootstrap < HbnAppConfiguration >   bootstrap )   { \n     final   HbnBundle   hibernate   =   new   HbnBundle (); \n     // register hbn bundle before guice to make sure factory initialized before guice context start \n     bootstrap . addBundle ( hibernate ); \n     bootstrap . addBundle ( GuiceBundle . builder () \n             . enableAutoConfig ( \"com.myapp.package\" ) \n             . modules ( new   HbnModule ( hibernate )) \n             . build ());  }",
            "title": "Guice integration"
        },
        {
            "location": "/examples/hibernate/#usage",
            "text": "It is simpler to use dropwizard  AbstractDAO  for hibernate logic:  public   class   SampleService   extends   AbstractDAO < Sample >   { \n\n     @Inject \n     public   SampleService ( SessionFactory   factory )   { \n         super ( factory ); \n     } \n\n     public   void   create ( Sample   sample )   { \n         return   persist ( sample ); \n     } \n\n     public   List < Sample >   findAll ()   { \n         return   list ( currentSession (). createQuery ( \"from Sample\" )); \n     }  }    You will need to use dropwizard  @UnitOfWork  annotation to declare transaction scope.   For example:  @Path ( \"/sample\" )  @Produces ( \"application/json\" )  public   class   SampleResource   { \n\n     @Inject \n     private   SampleService   service ; \n\n     @GET \n     @Path ( \"/\" ) \n     @Timed \n     @UnitOfWork \n     public   Response   doStaff ()   { \n         final   Sample   sample   =   new   Sample ( \"sample\" ); \n         service . create ( sample ); \n         final   List < Sample >   res   =   service . findAll (); \n         // using response to render entities inside unit of work and avoid lazy load exceptions \n         return   Response . ok ( res ). build (); \n     }  }",
            "title": "Usage"
        },
        {
            "location": "/examples/eventbus/",
            "text": "Guava EventBus integration\n\u00b6\n\n\nExample of \nguicey-eventbus\n extension usage.\n\n\n\n\nExample \nsource code\n\n\n\n\nThe \neventbus extension\n is used for:\n\n\n\n\nautomatic listeners registration\n\n\nbinding eventbus instance in guice context (for publication)\n\n\nprinting available listeners to console\n\n\n\n\nConfiguration\n\u00b6\n\n\nAn additional dependency is required:\n\n\ncompile\n \n'ru.vyarus.guicey:guicey-eventbus:0.4.0'\n\n\n\n\n\n\n\nNote\n\n\nguicey-eventbus version could be managed with \nBOM\n\n\n\n\nRegister eventbus bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n      \n.\nbundles\n(\nnew\n \nEventBusBundle\n())\n\n\n\n\n\nEvent\n\u00b6\n\n\nEvents are simple POJOs. Create event classes with properties you need (or without everything):\n\n\npublic\n \nclass\n \nFooEvent\n \n{\n\n    \nprivate\n \nString\n \nsomething\n;\n\n\n    \npublic\n \nFooEvent\n(\nString\n \nsomething\n)\n \n{\n\n        \nthis\n.\nsomething\n \n=\n \nsomething\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \ngetSomething\n()\n \n{\n\n        \nreturn\n \nsomething\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nUse event hierarchies, if appropriate:\n\n\npublic\n \nabstract\n \nclass\n \nBaseEvent\n \n{}\n\n\n\npublic\n \nclass\n \nFooEvent\n \nextends\n \nBaseEvent\n \n{}\n\n\n\npublic\n \nclass\n \nBarEvent\n \nextends\n \nBaseEvent\n \n{}\n\n\n\n\n\n\n\nFor simplicity, properties are omitted.\n\n\n\n\nPublication\n\u00b6\n\n\nInject the eventbus instance to enable publication:\n\n\n@Inject\n \nEventBus\n \neventbus\n;\n\n\n\npublic\n \nvoid\n \nsomeAction\n()\n \n{\n\n    \n...\n\n    \neventbus\n.\npost\n(\nnew\n \nFooEvent\n());\n\n\n}\n\n\n\n\n\nListening\n\u00b6\n\n\nListener methods must be annotated with \n@Subscribe\n and contain only one parameter of the target event type:\n\n\n@Subscribe\n\n\npublic\n \nvoid\n \nonFooEvent\n(\nFooEvent\n \nevent\n)\n \n{}\n\n\n\n@Subscribe\n\n\n// listen for all events of type (FooEvent, BarEvent)\n\n\npublic\n \nvoid\n \nonMultipleEvents\n(\nBaseEvent\n \nevent\n)\n \n{}\n\n\n\n\n\n\n\nAttention\n\n\nListener methods will only be registered for \"known\" guice beans. That means any extension\nor manually declared guice bean (using module) or bean created with guice AOT (because it's declared\nas dependency for other bean) will be searched for listener methods.\n\n\n\n\nSee \na complete example",
            "title": "EventBus"
        },
        {
            "location": "/examples/eventbus/#guava-eventbus-integration",
            "text": "Example of  guicey-eventbus  extension usage.   Example  source code   The  eventbus extension  is used for:   automatic listeners registration  binding eventbus instance in guice context (for publication)  printing available listeners to console",
            "title": "Guava EventBus integration"
        },
        {
            "location": "/examples/eventbus/#configuration",
            "text": "An additional dependency is required:  compile   'ru.vyarus.guicey:guicey-eventbus:0.4.0'    Note  guicey-eventbus version could be managed with  BOM   Register eventbus bundle:  GuiceBundle . builder () \n       . bundles ( new   EventBusBundle ())",
            "title": "Configuration"
        },
        {
            "location": "/examples/eventbus/#event",
            "text": "Events are simple POJOs. Create event classes with properties you need (or without everything):  public   class   FooEvent   { \n     private   String   something ; \n\n     public   FooEvent ( String   something )   { \n         this . something   =   something ; \n     } \n\n     public   void   getSomething ()   { \n         return   something ; \n     }  }   Use event hierarchies, if appropriate:  public   abstract   class   BaseEvent   {}  public   class   FooEvent   extends   BaseEvent   {}  public   class   BarEvent   extends   BaseEvent   {}    For simplicity, properties are omitted.",
            "title": "Event"
        },
        {
            "location": "/examples/eventbus/#publication",
            "text": "Inject the eventbus instance to enable publication:  @Inject   EventBus   eventbus ;  public   void   someAction ()   { \n     ... \n     eventbus . post ( new   FooEvent ());  }",
            "title": "Publication"
        },
        {
            "location": "/examples/eventbus/#listening",
            "text": "Listener methods must be annotated with  @Subscribe  and contain only one parameter of the target event type:  @Subscribe  public   void   onFooEvent ( FooEvent   event )   {}  @Subscribe  // listen for all events of type (FooEvent, BarEvent)  public   void   onMultipleEvents ( BaseEvent   event )   {}    Attention  Listener methods will only be registered for \"known\" guice beans. That means any extension\nor manually declared guice bean (using module) or bean created with guice AOT (because it's declared\nas dependency for other bean) will be searched for listener methods.   See  a complete example",
            "title": "Listening"
        },
        {
            "location": "/examples/jdbi/",
            "text": "JDBI integration\n\u00b6\n\n\nExample of \nguicey-jdbi\n extension usage.\n\n\n\n\nExample \nsource code\n\n\n\n\nThe \nJDBI extension\n allows:\n\n\n\n\nusing jdbi proxies as guice beans\n\n\nusing injection inside proxies\n\n\nusing AOP on proxies\n\n\nusing annotations for transaction definition\n\n\nautomatic repository and mapper installation\n\n\n\n\nConfiguration\n\u00b6\n\n\nAdditional dependencies required:\n\n\ncompile\n \n'ru.vyarus.guicey:guicey-jdbi:0.4.0'\n\n\ncompile\n \n'com.h2database:h2:1.4.193'\n\n\n\n\n\n\n\nNote\n\n\nguicey-jdbi version could be managed with \nBOM\n\n\n\n\ndropwizard-jdbi\n is used to configure \nand create dbi instance:\n\n\npublic\n \nclass\n \nJdbiAppConfiguration\n \nextends\n \nConfiguration\n \n{\n\n\n    \n@Valid\n\n    \n@NotNull\n\n    \n@JsonProperty\n\n    \nprivate\n \nDataSourceFactory\n \ndatabase\n \n=\n \nnew\n \nDataSourceFactory\n();\n\n\n    \npublic\n \nDataSourceFactory\n \ngetDatabase\n()\n \n{\n\n        \nreturn\n \ndatabase\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nFor simplicity, an embedded H2 database is used:\n\n\ndatabase\n:\n\n  \ndriverClass\n:\n \norg.h2.Driver\n\n  \nuser\n:\n \nsa\n\n  \npassword\n:\n\n  \nurl\n:\n \njdbc:h2:~/sample\n\n  \nproperties\n:\n\n    \ncharSet\n:\n \nUTF-8\n\n  \nmaxWaitForConnection\n:\n \n1s\n\n  \nvalidationQuery\n:\n \n\"SELECT\n \n1\"\n\n  \nvalidationQueryTimeout\n:\n \n3s\n\n  \nminSize\n:\n \n8\n\n  \nmaxSize\n:\n \n32\n\n  \ncheckConnectionWhileIdle\n:\n \nfalse\n\n  \nevictionInterval\n:\n \n10s\n\n  \nminIdleTime\n:\n \n1 minute\n\n\n\n\n\n\n\nWarning\n\n\nDatabase scheme must be created manually. You can use \n\ndropwizard-flyway\n module to prepare database. \nSee \nexample app source\n for details. \n\n\n\n\nDBI instance created exactly as described in \ndropwizard docs\n \nusing provided db configuration:\n\n\nGuiceBundle\n.\nbuilder\n()\n\n    \n.\nbundles\n(\nJdbiBundle\n.<\nJdbiAppConfiguration\n>\nforDatabase\n((\nconf\n,\n \nenv\n)\n \n->\n \nconf\n.\ngetDatabase\n()))\n\n\n\n\n\n\n\nNote\n\n\nYou can use \npre-build dbi instance\n instead.\n\n\n\n\nRepository definition\n\u00b6\n\n\n\n\nWarning\n\n\nAll jdbi repositories must be annotated with \n@JdbiRepository\n to let the \nrepository installer\n\nrecognize and properly install them.\n\n\n\n\n@JdbiRepository\n\n\n@InTransaction\n\n\npublic\n \nabstract\n \nclass\n \nUserRepository\n \nextends\n \nCrud\n<\nUser\n>\n \n{\n\n\n    \n// have to use field injection because class is still used by dbi (which is no aware of guice) for proxy creation\n\n    \n@Inject\n\n    \nprivate\n \nRandomNameGenerator\n \ngenerator\n;\n\n\n    \n// sample of hybrid method in repository, using injected service\n\n    \npublic\n \nUser\n \ncreateRandomUser\n()\n \n{\n\n        \nfinal\n \nUser\n \nuser\n \n=\n \nnew\n \nUser\n();\n\n        \nuser\n.\nsetName\n(\ngenerator\n.\ngenerateName\n());\n\n        \nsave\n(\nuser\n);\n\n        \nreturn\n \nuser\n;\n\n    \n}\n\n\n    \n@Override\n\n    \n@SqlUpdate\n(\n\"insert into users (name, version) values (:name, :version)\"\n)\n\n    \n@GetGeneratedKeys\n\n    \npublic\n \nabstract\n \nlong\n \ninsert\n(\n@UserBind\n \nUser\n \nentry\n);\n\n\n    \n@SqlUpdate\n(\n\"update users set version=:version, name=:name where id=:id and version=:version - 1\"\n)\n\n    \n@Override\n\n    \npublic\n \nabstract\n \nint\n \nupdate\n(\n@UserBind\n \nUser\n \nentry\n);\n\n\n    \n@SqlQuery\n(\n\"select * from users\"\n)\n\n    \npublic\n \nabstract\n \nList\n<\nUser\n>\n \nfindAll\n();\n\n\n    \n@SqlQuery\n(\n\"select * from users where name = :name\"\n)\n\n    \npublic\n \nabstract\n \nUser\n \nfindByName\n(\n@Bind\n(\n\"name\"\n)\n \nString\n \nname\n);\n\n\n}\n\n\n\n\n\nWhere \nCrud\n base class tries to unify repositories and provide hibernate-like optimistic locking behaviour \n(on each entity save version field is assigned/incremented and checked during update to prevent data loss):\n\n\npublic\n \nabstract\n \nclass\n \nCrud\n<\nT\n \nextends\n \nIdEntity\n>\n \n{\n\n\n    \n@InTransaction\n\n    \npublic\n \nT\n \nsave\n(\nfinal\n \nT\n \nentry\n)\n \n{\n\n        \n// hibernate-like optimistic locking mechanism: provided entity must have the same version as in database\n\n        \nif\n \n(\nentry\n.\ngetId\n()\n \n==\n \n0\n)\n \n{\n\n            \nentry\n.\nsetVersion\n(\n1\n);\n\n            \nentry\n.\nsetId\n(\ninsert\n(\nentry\n));\n\n        \n}\n \nelse\n \n{\n\n            \nfinal\n \nint\n \nver\n \n=\n \nentry\n.\ngetVersion\n();\n\n            \nentry\n.\nsetVersion\n(\nver\n \n+\n \n1\n);\n\n            \nif\n \n(\nupdate\n(\nentry\n)\n \n==\n \n0\n)\n \n{\n\n                \nthrow\n \nnew\n \nConcurrentModificationException\n(\nString\n.\nformat\n(\n\n                        \n\"Concurrent modification for object %s %s version %s\"\n,\n\n                        \nentry\n.\ngetClass\n().\ngetName\n(),\n \nentry\n.\ngetId\n(),\n \nver\n));\n\n            \n}\n\n        \n}\n\n        \nreturn\n \nentry\n;\n\n    \n}\n\n\n    \npublic\n \nabstract\n \nlong\n \ninsert\n(\nT\n \nentry\n);\n\n\n    \npublic\n \nabstract\n \nint\n \nupdate\n(\nT\n \nentry\n);\n\n\n}\n\n\n\n\n\n\n\nYou don't necessarily need to use \nCrud\n - it's an advanced usage example.\n\n\n\n\nThe repository is annotated with \n@InTransaction\n to allow direct usage; repository method calls are the smallest transaction scope. \nThe transaction scope can be enlarged by using annotations on calling guice beans or \n\ndeclaring transactions manually\n.\nIn order to better understand how transactions work, read the \nunit of work docs section\n.\n\n\n\n\nNote\n\n\n@InTransaction\n is handled with guice AOP, so you can use any other guice aop related features.\n\n\n\n\n\n\nAttention\n\n\nConstructor injection is impossible in repositories, but you can use field injections:\n\n \n@Inject\n\n \nprivate\n \nRandomNameGenerator\n \ngenerator\n;\n\n\n\n\n\n\nResult set mapper\n\u00b6\n\n\nResult set mapper is used to map query result set to entity: \n\n\npublic\n \nclass\n \nUserMapper\n \nimplements\n \nResultSetMapper\n<\nUser\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nUser\n \nmap\n(\nint\n \nindex\n,\n \nResultSet\n \nr\n,\n \nStatementContext\n \nctx\n)\n \nthrows\n \nSQLException\n \n{\n\n        \nUser\n \nuser\n \n=\n \nnew\n \nUser\n();\n\n        \nuser\n.\nsetId\n(\nr\n.\ngetLong\n(\n\"id\"\n));\n\n        \nuser\n.\nsetVersion\n(\nr\n.\ngetInt\n(\n\"version\"\n));\n\n        \nuser\n.\nsetName\n(\nr\n.\ngetString\n(\n\"name\"\n));\n\n        \nreturn\n \nuser\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nMappers are installed with the \nmapper installer\n.\nIf auto scan is enabled then all mappers will be detected automatically and registered in the dbi instance.\nMappers are instantiated as normal guice beans without restrictions which means you can use injection and aop \n(it's only not shown in example mapper).\n\n\n\n\nNote\n\n\nThe mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean\nand you dont want to use auto configuration then you can register it manually in dbi instance, making it available for injection.\n\n\n\n\nAlso, see complementing binding annotation, used to bind object to query parameters:\n\n\n@BindingAnnotation\n(\nUserBind\n.\nUserBinder\n.\nclass\n)\n\n\n@Retention\n(\nRetentionPolicy\n.\nRUNTIME\n)\n\n\n@Target\n(\nElementType\n.\nPARAMETER\n)\n\n\npublic\n \n@interface\n \nUserBind\n \n{\n\n\n    \nclass\n \nUserBinder\n \nimplements\n \nBinderFactory\n<\nUserBind\n>\n \n{\n\n        \n@Override\n\n        \npublic\n \nBinder\n \nbuild\n(\nUserBind\n \nannotation\n)\n \n{\n\n            \nreturn\n \n(\nBinder\n<\nUserBind\n,\n \nUser\n>)\n \n(\nq\n,\n \nbind\n,\n \narg\n)\n \n->\n \n{\n\n                \nq\n.\nbind\n(\n\"id\"\n,\n \narg\n.\ngetId\n())\n\n                        \n.\nbind\n(\n\"version\"\n,\n \narg\n.\ngetVersion\n())\n\n                        \n.\nbind\n(\n\"name\"\n,\n \narg\n.\ngetName\n());\n\n            \n};\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nSee \n@UserBind\n usage above in repository definition.\n\n\nThere is no custom installer for annotation because it's detected automatically by DBI.  \n\n\nUsage\n\u00b6\n\n\nRepositories are used as normal guice beans:\n\n\n@Path\n(\n\"/users\"\n)\n\n\n@Produces\n(\n\"application/json\"\n)\n\n\npublic\n \nclass\n \nUserResource\n \n{\n\n\n    \n@Inject\n\n    \nprivate\n \nfinal\n \nUserRepository\n \nrepository\n;\n\n\n    \n@POST\n\n    \n@Path\n(\n\"/\"\n)\n\n    \npublic\n \nUser\n \ncreate\n(\nString\n \nname\n)\n \n{\n\n        \nUser\n \nuser\n \n=\n \nnew\n \nUser\n();\n\n        \nuser\n.\nsetName\n(\nname\n);\n\n        \nreturn\n \nrepository\n.\nsave\n(\nuser\n);\n\n    \n}\n\n\n    \n@GET\n\n    \n@Path\n(\n\"/\"\n)\n\n    \npublic\n \nList\n<\nUser\n>\n \nfindAll\n()\n \n{\n\n        \nreturn\n \nrepository\n.\nfindAll\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nUserMapper\n and \nUserBind\n are used implicitly to convert the POJO into a db record and back.\n\n\nYou can use \n@InTransaction\n on repository method to enlarge transaction scope, but, in contrast\nto hibernate you dont't have to always declare it to avoid lazy initialization exception \n(because jdbi produces simple pojos).\n\n\n\n\nNote\n\n\n@InTrasaction\n is named to avoid confusion with the commonly used \n@Transactional\n annotation.\nYou \ncan bind any annotation class\n if you like to use a different name (the annotation is just a marker)",
            "title": "JDBI"
        },
        {
            "location": "/examples/jdbi/#jdbi-integration",
            "text": "Example of  guicey-jdbi  extension usage.   Example  source code   The  JDBI extension  allows:   using jdbi proxies as guice beans  using injection inside proxies  using AOP on proxies  using annotations for transaction definition  automatic repository and mapper installation",
            "title": "JDBI integration"
        },
        {
            "location": "/examples/jdbi/#configuration",
            "text": "Additional dependencies required:  compile   'ru.vyarus.guicey:guicey-jdbi:0.4.0'  compile   'com.h2database:h2:1.4.193'    Note  guicey-jdbi version could be managed with  BOM   dropwizard-jdbi  is used to configure \nand create dbi instance:  public   class   JdbiAppConfiguration   extends   Configuration   { \n\n     @Valid \n     @NotNull \n     @JsonProperty \n     private   DataSourceFactory   database   =   new   DataSourceFactory (); \n\n     public   DataSourceFactory   getDatabase ()   { \n         return   database ; \n     }  }   For simplicity, an embedded H2 database is used:  database : \n   driverClass :   org.h2.Driver \n   user :   sa \n   password : \n   url :   jdbc:h2:~/sample \n   properties : \n     charSet :   UTF-8 \n   maxWaitForConnection :   1s \n   validationQuery :   \"SELECT   1\" \n   validationQueryTimeout :   3s \n   minSize :   8 \n   maxSize :   32 \n   checkConnectionWhileIdle :   false \n   evictionInterval :   10s \n   minIdleTime :   1 minute    Warning  Database scheme must be created manually. You can use  dropwizard-flyway  module to prepare database. \nSee  example app source  for details.    DBI instance created exactly as described in  dropwizard docs  \nusing provided db configuration:  GuiceBundle . builder () \n     . bundles ( JdbiBundle .< JdbiAppConfiguration > forDatabase (( conf ,   env )   ->   conf . getDatabase ()))    Note  You can use  pre-build dbi instance  instead.",
            "title": "Configuration"
        },
        {
            "location": "/examples/jdbi/#repository-definition",
            "text": "Warning  All jdbi repositories must be annotated with  @JdbiRepository  to let the  repository installer \nrecognize and properly install them.   @JdbiRepository  @InTransaction  public   abstract   class   UserRepository   extends   Crud < User >   { \n\n     // have to use field injection because class is still used by dbi (which is no aware of guice) for proxy creation \n     @Inject \n     private   RandomNameGenerator   generator ; \n\n     // sample of hybrid method in repository, using injected service \n     public   User   createRandomUser ()   { \n         final   User   user   =   new   User (); \n         user . setName ( generator . generateName ()); \n         save ( user ); \n         return   user ; \n     } \n\n     @Override \n     @SqlUpdate ( \"insert into users (name, version) values (:name, :version)\" ) \n     @GetGeneratedKeys \n     public   abstract   long   insert ( @UserBind   User   entry ); \n\n     @SqlUpdate ( \"update users set version=:version, name=:name where id=:id and version=:version - 1\" ) \n     @Override \n     public   abstract   int   update ( @UserBind   User   entry ); \n\n     @SqlQuery ( \"select * from users\" ) \n     public   abstract   List < User >   findAll (); \n\n     @SqlQuery ( \"select * from users where name = :name\" ) \n     public   abstract   User   findByName ( @Bind ( \"name\" )   String   name );  }   Where  Crud  base class tries to unify repositories and provide hibernate-like optimistic locking behaviour \n(on each entity save version field is assigned/incremented and checked during update to prevent data loss):  public   abstract   class   Crud < T   extends   IdEntity >   { \n\n     @InTransaction \n     public   T   save ( final   T   entry )   { \n         // hibernate-like optimistic locking mechanism: provided entity must have the same version as in database \n         if   ( entry . getId ()   ==   0 )   { \n             entry . setVersion ( 1 ); \n             entry . setId ( insert ( entry )); \n         }   else   { \n             final   int   ver   =   entry . getVersion (); \n             entry . setVersion ( ver   +   1 ); \n             if   ( update ( entry )   ==   0 )   { \n                 throw   new   ConcurrentModificationException ( String . format ( \n                         \"Concurrent modification for object %s %s version %s\" , \n                         entry . getClass (). getName (),   entry . getId (),   ver )); \n             } \n         } \n         return   entry ; \n     } \n\n     public   abstract   long   insert ( T   entry ); \n\n     public   abstract   int   update ( T   entry );  }    You don't necessarily need to use  Crud  - it's an advanced usage example.   The repository is annotated with  @InTransaction  to allow direct usage; repository method calls are the smallest transaction scope. \nThe transaction scope can be enlarged by using annotations on calling guice beans or  declaring transactions manually .\nIn order to better understand how transactions work, read the  unit of work docs section .   Note  @InTransaction  is handled with guice AOP, so you can use any other guice aop related features.    Attention  Constructor injection is impossible in repositories, but you can use field injections:   @Inject \n  private   RandomNameGenerator   generator ;",
            "title": "Repository definition"
        },
        {
            "location": "/examples/jdbi/#result-set-mapper",
            "text": "Result set mapper is used to map query result set to entity:   public   class   UserMapper   implements   ResultSetMapper < User >   { \n\n     @Override \n     public   User   map ( int   index ,   ResultSet   r ,   StatementContext   ctx )   throws   SQLException   { \n         User   user   =   new   User (); \n         user . setId ( r . getLong ( \"id\" )); \n         user . setVersion ( r . getInt ( \"version\" )); \n         user . setName ( r . getString ( \"name\" )); \n         return   user ; \n     }  }   Mappers are installed with the  mapper installer .\nIf auto scan is enabled then all mappers will be detected automatically and registered in the dbi instance.\nMappers are instantiated as normal guice beans without restrictions which means you can use injection and aop \n(it's only not shown in example mapper).   Note  The mapper installer mostly automates (and unifies) registration. If your mapper does not need to be guice bean\nand you dont want to use auto configuration then you can register it manually in dbi instance, making it available for injection.   Also, see complementing binding annotation, used to bind object to query parameters:  @BindingAnnotation ( UserBind . UserBinder . class )  @Retention ( RetentionPolicy . RUNTIME )  @Target ( ElementType . PARAMETER )  public   @interface   UserBind   { \n\n     class   UserBinder   implements   BinderFactory < UserBind >   { \n         @Override \n         public   Binder   build ( UserBind   annotation )   { \n             return   ( Binder < UserBind ,   User >)   ( q ,   bind ,   arg )   ->   { \n                 q . bind ( \"id\" ,   arg . getId ()) \n                         . bind ( \"version\" ,   arg . getVersion ()) \n                         . bind ( \"name\" ,   arg . getName ()); \n             }; \n         } \n     }  }   See  @UserBind  usage above in repository definition.  There is no custom installer for annotation because it's detected automatically by DBI.",
            "title": "Result set mapper"
        },
        {
            "location": "/examples/jdbi/#usage",
            "text": "Repositories are used as normal guice beans:  @Path ( \"/users\" )  @Produces ( \"application/json\" )  public   class   UserResource   { \n\n     @Inject \n     private   final   UserRepository   repository ; \n\n     @POST \n     @Path ( \"/\" ) \n     public   User   create ( String   name )   { \n         User   user   =   new   User (); \n         user . setName ( name ); \n         return   repository . save ( user ); \n     } \n\n     @GET \n     @Path ( \"/\" ) \n     public   List < User >   findAll ()   { \n         return   repository . findAll (); \n     }  }   UserMapper  and  UserBind  are used implicitly to convert the POJO into a db record and back.  You can use  @InTransaction  on repository method to enlarge transaction scope, but, in contrast\nto hibernate you dont't have to always declare it to avoid lazy initialization exception \n(because jdbi produces simple pojos).   Note  @InTrasaction  is named to avoid confusion with the commonly used  @Transactional  annotation.\nYou  can bind any annotation class  if you like to use a different name (the annotation is just a marker)",
            "title": "Usage"
        },
        {
            "location": "/extras/admin-rest/",
            "text": "Admin REST\n\u00b6\n\n\nAll rest resources could be \"published\" in the admin context too.  This is just an emulation of rest: the same resources \nare accessible in both contexts. On admin side special servlet simply redirects all incoming requests into the jersey context.\n\n\nSuch an approach is better than registering a completely separate jersey context for admin rest because\nof no overhead and the simplicity of jersey extensions management.\n\n\nConfiguration\n\u00b6\n\n\nTo install admin rest servlet, register bundle:\n\n\nbootstrap\n.\naddBundle\n(\nnew\n \nAdminRestBundle\n());\n\n\n\n\n\nIn this case, rest is registered either to '/api/\n', if main context rest is mapped to root ('/\n')\nor to the same path as main context rest.\n\n\nTo register on a custom path:\n\n\nbootstrap\n.\naddBundle\n(\nnew\n \nAdminRestBundle\n(\n\"/custom/*\"\n));\n\n\n\n\n\nSecurity\n\u00b6\n\n\nIn order to hide specific resource methods or entire resources on the main context, annotate resource methods\nor resource classes with the \n@AdminResource\n annotation.\n\n\nFor example:\n\n\n@GET\n\n\n@Path\n(\n\"/admin\"\n)\n\n\n@AdminResource\n\n\npublic\n \nString\n \nadmin\n()\n \n{\n\n    \nreturn\n \n\"admin\"\n\n\n}\n\n\n\n\n\nThis (annotated) method will return 403 error when called from main context, but should function normally \nwhen called from the admin context.\n\n\nThis is just the simplest option to control resources access. Any other method may be used (with some security\nframework or something else).",
            "title": "Admin REST"
        },
        {
            "location": "/extras/admin-rest/#admin-rest",
            "text": "All rest resources could be \"published\" in the admin context too.  This is just an emulation of rest: the same resources \nare accessible in both contexts. On admin side special servlet simply redirects all incoming requests into the jersey context.  Such an approach is better than registering a completely separate jersey context for admin rest because\nof no overhead and the simplicity of jersey extensions management.",
            "title": "Admin REST"
        },
        {
            "location": "/extras/admin-rest/#configuration",
            "text": "To install admin rest servlet, register bundle:  bootstrap . addBundle ( new   AdminRestBundle ());   In this case, rest is registered either to '/api/ ', if main context rest is mapped to root ('/ ')\nor to the same path as main context rest.  To register on a custom path:  bootstrap . addBundle ( new   AdminRestBundle ( \"/custom/*\" ));",
            "title": "Configuration"
        },
        {
            "location": "/extras/admin-rest/#security",
            "text": "In order to hide specific resource methods or entire resources on the main context, annotate resource methods\nor resource classes with the  @AdminResource  annotation.  For example:  @GET  @Path ( \"/admin\" )  @AdminResource  public   String   admin ()   { \n     return   \"admin\"  }   This (annotated) method will return 403 error when called from main context, but should function normally \nwhen called from the admin context.  This is just the simplest option to control resources access. Any other method may be used (with some security\nframework or something else).",
            "title": "Security"
        },
        {
            "location": "/extras/bom/",
            "text": "Guicey BOM\n\u00b6\n\n\n\n\nExtensions project\n module\n\n\n\n\nMaven BOM containing guicey and guicey ext modules versions. Also includes dropwizard and guice boms.\n\n\n\n\nTip\n\n\nBOM's are useful for versions management. After including bom you can simply include required dependencies\n(dropwizard, guice, guicey, guicey-ext) without versions: bom version will control all versions.\n\n\n\n\n\n\n\n\n\n\nBOM version\n\n\nGuicey\n\n\nDropwizard\n\n\nGuice\n\n\n\n\n\n\n\n\n\n\n0.4.0\n\n\n4.2.0\n\n\n1.3.5\n\n\n4.2.0\n\n\n\n\n\n\n0.3.0\n\n\n4.1.0\n\n\n1.1.0\n\n\n4.1.0\n\n\n\n\n\n\n\n\nSetup\n\u00b6\n\n\n\n\n\n\nMaven:\n\n\n<!-- Implicitly imports Dropwizard and Guice BOMs -->\n\n\n<dependencyManagement>\n\n    \n<dependencies>\n\n        \n<dependency>\n\n            \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n            \n<artifactId>\nguicey-bom\n</artifactId>\n\n            \n<version>\n0.4.0\n</version>\n\n            \n<type>\npom\n</type>\n\n            \n<scope>\nimport\n</scope>\n\n        \n</dependency>\n\n    \n</dependencies>\n\n\n</dependencyManagement>\n\n\n\n<!-- declare guice and ext modules without versions -->\n\n\n<dependencies>\n\n    \n<dependency>\n\n      \n<groupId>\nru.vyarus\n</groupId>\n\n      \n<artifactId>\ndropwizard-guicey\n</artifactId>\n\n    \n</dependency>\n\n    \n<!-- For example, using dropwizard module (without version) -->\n\n    \n<dependency>\n\n      \n<groupId>\nio.dropwizard\n</groupId>\n\n      \n<artifactId>\ndropwizard-auth\n</artifactId>\n\n    \n</dependency>\n\n    \n<!-- Example of extension module usage -->\n\n    \n<dependency>\n\n          \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n          \n<artifactId>\nguicey-eventbus\n</artifactId>\n\n        \n</dependency>\n\n\n</dependencies>\n\n\n\n\n\nGradle:\n\n\nplugins\n \n{\n\n    \nid\n \n\"io.spring.dependency-management\"\n \nversion\n \n\"1.0.5.RELEASE\"\n\n\n}\n\n\n\ndependencyManagement\n \n{\n\n    \n// Implicitly imports Dropwizard and Guice BOMs \n\n    \nimports\n \n{\n\n        \nmavenBom\n \n\"ru.vyarus.guicey:guicey-bom:0.4.0\"\n\n    \n}\n\n\n}\n\n\n\n// declare guice and ext modules without versions \n\n\ndependencies\n \n{\n\n    \ncompile\n \n'ru.vyarus:dropwizard-guicey'\n\n    \n// For example, using dropwizard module (without version)\n\n    \ncompile\n \n'io.dropwizard:dropwizard-auth'\n\n    \n// Example of extension module usage\n\n    \ncompile\n \n'ru.vyarus.guicey:guicey-eventbus'\n \n\n}\n\n\n\n\n\nSpring's \ndependency management plugin\n is required to import BOM.\n\n\nDependencies override\n\u00b6\n\n\nYou may override BOM version for any dependency by simply specifying exact version in dependecy declaration section.\n\n\nIf you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly:\n\n\n\n\nio.dropwizard:dropwizard-bom:$VERSION\n for dropwizard\n\n\ncom.google.inject:guice-bom:$VERSION\n for guice",
            "title": "BOM"
        },
        {
            "location": "/extras/bom/#guicey-bom",
            "text": "Extensions project  module   Maven BOM containing guicey and guicey ext modules versions. Also includes dropwizard and guice boms.   Tip  BOM's are useful for versions management. After including bom you can simply include required dependencies\n(dropwizard, guice, guicey, guicey-ext) without versions: bom version will control all versions.      BOM version  Guicey  Dropwizard  Guice      0.4.0  4.2.0  1.3.5  4.2.0    0.3.0  4.1.0  1.1.0  4.1.0",
            "title": "Guicey BOM"
        },
        {
            "location": "/extras/bom/#setup",
            "text": "Maven:  <!-- Implicitly imports Dropwizard and Guice BOMs -->  <dependencyManagement> \n     <dependencies> \n         <dependency> \n             <groupId> ru.vyarus.guicey </groupId> \n             <artifactId> guicey-bom </artifactId> \n             <version> 0.4.0 </version> \n             <type> pom </type> \n             <scope> import </scope> \n         </dependency> \n     </dependencies>  </dependencyManagement>  <!-- declare guice and ext modules without versions -->  <dependencies> \n     <dependency> \n       <groupId> ru.vyarus </groupId> \n       <artifactId> dropwizard-guicey </artifactId> \n     </dependency> \n     <!-- For example, using dropwizard module (without version) --> \n     <dependency> \n       <groupId> io.dropwizard </groupId> \n       <artifactId> dropwizard-auth </artifactId> \n     </dependency> \n     <!-- Example of extension module usage --> \n     <dependency> \n           <groupId> ru.vyarus.guicey </groupId> \n           <artifactId> guicey-eventbus </artifactId> \n         </dependency>  </dependencies>   Gradle:  plugins   { \n     id   \"io.spring.dependency-management\"   version   \"1.0.5.RELEASE\"  }  dependencyManagement   { \n     // Implicitly imports Dropwizard and Guice BOMs  \n     imports   { \n         mavenBom   \"ru.vyarus.guicey:guicey-bom:0.4.0\" \n     }  }  // declare guice and ext modules without versions   dependencies   { \n     compile   'ru.vyarus:dropwizard-guicey' \n     // For example, using dropwizard module (without version) \n     compile   'io.dropwizard:dropwizard-auth' \n     // Example of extension module usage \n     compile   'ru.vyarus.guicey:guicey-eventbus'   }   Spring's  dependency management plugin  is required to import BOM.",
            "title": "Setup"
        },
        {
            "location": "/extras/bom/#dependencies-override",
            "text": "You may override BOM version for any dependency by simply specifying exact version in dependecy declaration section.  If you want to use newer version (then provided by guicey BOM) of dropwizard or guice then import also their BOMs directly:   io.dropwizard:dropwizard-bom:$VERSION  for dropwizard  com.google.inject:guice-bom:$VERSION  for guice",
            "title": "Dependencies override"
        },
        {
            "location": "/extras/eventbus/",
            "text": "Guava EventBus integration\n\u00b6\n\n\n\n\nExtensions project\n module\n\n\n\n\nIntegrates \nGuava EventBus\n with guice.\n\n\nFeatures:\n\n\n\n\nEventBus available for injection (to publish events)\n\n\nAutomatic registration of listener methods (annotated with \n@Subscribe\n)\n\n\nConsole reporting of registered listeners\n\n\n\n\nSetup\n\u00b6\n\n\n\n\n\n\nRemove \nversion\n in dependency declaration below if you using \nthe BOM extensions\n. \n\n\nMaven:\n\n\n<dependency>\n\n  \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n  \n<artifactId>\nguicey-eventbus\n</artifactId>\n\n  \n<version>\n0.4.0\n</version>\n\n\n</dependency>\n\n\n\n\n\nGradle:\n\n\ncompile\n \n'ru.vyarus.guicey:guicey-eventbus:0.4.0'\n\n\n\n\n\nSee the most recent version in the badge above.\n\n\nUsage\n\u00b6\n\n\nRegister bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n        \n        \n.\nbundles\n(\nnew\n \nEventBusBundle\n())\n\n        \n...\n\n\n\n\n\nCreate event:\n\n\npublic\n \nclass\n \nMyEvent\n \n{\n\n    \n// some state\n\n\n}\n\n\n\n\n\nInject \nEventBus\n to publish new events.\n\n\npublic\n \nclass\n \nSomeService\n \n{\n\n    \n@Inject\n\n    \nprivate\n \nEventBus\n \neventbus\n;\n    \n\n    \npublic\n \nvoid\n \ninSomeMethod\n()\n \n{\n\n        \nevetbus\n.\npost\n(\nnew\n \nMyEvent\n());\n\n    \n}\n\n\n}\n\n\n\n\n\nListen for event:\n\n\npublic\n \nclass\n \nSomeOtherService\n \n{\n\n\n    \n@Subscribe\n\n    \npublic\n \nvoid\n \nonEvent\n(\nMyEvent\n \nevent\n)\n \n{\n\n         \n// handle event   \n\n    \n}\n\n\n}\n\n\n\n\n\nAfter server start you should see all registered event listeners in the log:\n\n\nINFO  [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = \n\n    MyEvent\n        com.foo.something.SomeOtherService        \n\n\n\n\n\n\nNote\n\n\nOnly subscriptions of beans registered at the time of injector startup will be shown.\nFor example, if MyBean has a subscription method but a binding for it is not declared (and noone depends on it),\na JIT binding will be created later in time (when bean will be actually used) and will not be reflected in the logs. \n\n\n\n\nConsuming multiple events\n\u00b6\n\n\nNote that you can build event hierarchies and subscribe to some base event to receive any derived event.   \n\n\nTo receive all events use:\n\n\n@Subscribe\n\n\npublic\n \nvoid\n \nonEvent\n(\nObject\n \nevent\n){\n    \n\n}\n\n\n\n\n\nEvent bus\n\u00b6\n\n\nBy default, events will be handled synchronously (\nbus.push()\n waits while all subscribers process).\n\n\nIf you want events to be async use custom eventbus:\n\n\nnew\n \nEventBusBundle\n(\n\n        \nnew\n \nAsyncEventBus\n(\nsomeExecutor\n)\n\n\n)\n\n\n\n\n\nBy default, event listeners are not considered thread safe and no parallel events processing (for single method) \nwill be performed. To mark subscriber as thread safe use \n@AllowConcurrentEvents\n:\n\n\n@Subscribe\n\n\n@AllowConcurrentEvents\n\n\npublic\n \nvoid\n \nonEvent\n(\nMyEvent\n \nevent\n)\n      \n\n\n\n\nIf a listener method fails to process an event (throws an exception), then other listeners will still be processed\nand the exception will be logged. If you want to change this behaviour, set a custom exception \nhandler by creating a custom eventbus instance:\n\n\nnew\n \nEventBusBundle\n(\n\n        \nnew\n \nEventBus\n(\ncustomExceptionHandler\n)\n\n\n)\n\n\n\n\n\nListeners recognition\n\u00b6\n\n\nThe guice type listener is used to intercept \nall\n bean instances and thus looks at every method in the \nclass hierarchy; however, only beans that actually have \n@Subscribe\nrs will be registered with the event bus. \nThis process is fast and usually causes no issues. If needed, you can reduce the scope with a \ncustom class matcher:\n\n\nnew\n \nEventBusBundle\n()\n\n    \n.\nwithMatcher\n(\nMatchers\n.\ninSubpackage\n(\n\"some.package\"\n))\n\n\n\n\n\nIf you want maximum performance, then you can add a marker annotation (e.g. \n@HasEvents\n) and reduce\nscope to just annotated classes:\n\n\nnew\n \nEventBusBundle\n()\n\n    \n.\nwithMatcher\n(\nMatchers\n.\nannotatedWith\n(\nHasEvents\n.\nclass\n))\n\n\n\n\n\nConsole reporting\n\u00b6\n\n\nYou can switch off console reporting (for example, if you have too many listeners):\n\n\nnew\n \nEventBusBundle\n().\nnoReport\n()\n\n\n\n\n\n\n\nNote\n\n\nReporting has to use reflection to get subscribers list. If this fails with a newer guava version\n(not yet supported), then simply disable reporting and everything will work as expected.\n\n\n\n\nSubscribers info bean\n\u00b6\n\n\nEventSubscribersInfo\n is a registered (available for injection) bean that provides active listeners\nand used event types. As described above, it uses reflection internally to access the eventbus listeners map. \nIt may be useful for testing.",
            "title": "Guava EventBus"
        },
        {
            "location": "/extras/eventbus/#guava-eventbus-integration",
            "text": "Extensions project  module   Integrates  Guava EventBus  with guice.  Features:   EventBus available for injection (to publish events)  Automatic registration of listener methods (annotated with  @Subscribe )  Console reporting of registered listeners",
            "title": "Guava EventBus integration"
        },
        {
            "location": "/extras/eventbus/#setup",
            "text": "Remove  version  in dependency declaration below if you using  the BOM extensions .   Maven:  <dependency> \n   <groupId> ru.vyarus.guicey </groupId> \n   <artifactId> guicey-eventbus </artifactId> \n   <version> 0.4.0 </version>  </dependency>   Gradle:  compile   'ru.vyarus.guicey:guicey-eventbus:0.4.0'   See the most recent version in the badge above.",
            "title": "Setup"
        },
        {
            "location": "/extras/eventbus/#usage",
            "text": "Register bundle:  GuiceBundle . builder ()         \n         . bundles ( new   EventBusBundle ()) \n         ...   Create event:  public   class   MyEvent   { \n     // some state  }   Inject  EventBus  to publish new events.  public   class   SomeService   { \n     @Inject \n     private   EventBus   eventbus ;     \n\n     public   void   inSomeMethod ()   { \n         evetbus . post ( new   MyEvent ()); \n     }  }   Listen for event:  public   class   SomeOtherService   { \n\n     @Subscribe \n     public   void   onEvent ( MyEvent   event )   { \n          // handle event    \n     }  }   After server start you should see all registered event listeners in the log:  INFO  [2016-12-01 12:31:02,819] ru.vyarus.guicey.eventbus.report.EventsReporter: EventBus subscribers = \n\n    MyEvent\n        com.foo.something.SomeOtherService           Note  Only subscriptions of beans registered at the time of injector startup will be shown.\nFor example, if MyBean has a subscription method but a binding for it is not declared (and noone depends on it),\na JIT binding will be created later in time (when bean will be actually used) and will not be reflected in the logs.",
            "title": "Usage"
        },
        {
            "location": "/extras/eventbus/#consuming-multiple-events",
            "text": "Note that you can build event hierarchies and subscribe to some base event to receive any derived event.     To receive all events use:  @Subscribe  public   void   onEvent ( Object   event ){      }",
            "title": "Consuming multiple events"
        },
        {
            "location": "/extras/eventbus/#event-bus",
            "text": "By default, events will be handled synchronously ( bus.push()  waits while all subscribers process).  If you want events to be async use custom eventbus:  new   EventBusBundle ( \n         new   AsyncEventBus ( someExecutor )  )   By default, event listeners are not considered thread safe and no parallel events processing (for single method) \nwill be performed. To mark subscriber as thread safe use  @AllowConcurrentEvents :  @Subscribe  @AllowConcurrentEvents  public   void   onEvent ( MyEvent   event )         If a listener method fails to process an event (throws an exception), then other listeners will still be processed\nand the exception will be logged. If you want to change this behaviour, set a custom exception \nhandler by creating a custom eventbus instance:  new   EventBusBundle ( \n         new   EventBus ( customExceptionHandler )  )",
            "title": "Event bus"
        },
        {
            "location": "/extras/eventbus/#listeners-recognition",
            "text": "The guice type listener is used to intercept  all  bean instances and thus looks at every method in the \nclass hierarchy; however, only beans that actually have  @Subscribe rs will be registered with the event bus. \nThis process is fast and usually causes no issues. If needed, you can reduce the scope with a \ncustom class matcher:  new   EventBusBundle () \n     . withMatcher ( Matchers . inSubpackage ( \"some.package\" ))   If you want maximum performance, then you can add a marker annotation (e.g.  @HasEvents ) and reduce\nscope to just annotated classes:  new   EventBusBundle () \n     . withMatcher ( Matchers . annotatedWith ( HasEvents . class ))",
            "title": "Listeners recognition"
        },
        {
            "location": "/extras/eventbus/#console-reporting",
            "text": "You can switch off console reporting (for example, if you have too many listeners):  new   EventBusBundle (). noReport ()    Note  Reporting has to use reflection to get subscribers list. If this fails with a newer guava version\n(not yet supported), then simply disable reporting and everything will work as expected.",
            "title": "Console reporting"
        },
        {
            "location": "/extras/eventbus/#subscribers-info-bean",
            "text": "EventSubscribersInfo  is a registered (available for injection) bean that provides active listeners\nand used event types. As described above, it uses reflection internally to access the eventbus listeners map. \nIt may be useful for testing.",
            "title": "Subscribers info bean"
        },
        {
            "location": "/extras/jdbi/",
            "text": "JDBI integration\n\u00b6\n\n\n\n\nExtensions project\n module\n\n\n\n\nIntegrates \nJDBI\n with guice. Based on \ndropwizard-jdbi\n integration.\n\n\nFeatures:\n\n\n\n\nDBI instance available for injection\n\n\nIntroduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional)\n\n\nRepositories (JDBI proxies for interfaces and abstract classes):\n\n\ninstalled automatically (when classpath scan enabled)\n\n\nare normal guice beans, supporting aop and participating in global (thread bound) transaction.\n\n\nno need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction.\n\n\n\n\n\n\nAutomatic installation for custom \nResultSetMapper\n \n\n\n\n\nAdded installers:\n\n\n\n\nRepositoryInstaller\n - sql proxies\n\n\nMapperInstaller\n - result set mappers  \n\n\n\n\nSetup\n\u00b6\n\n\n\n\n\n\nAvoid version in dependency declaration below if you use \nextensions BOM\n. \n\n\nMaven:\n\n\n<dependency>\n\n  \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n  \n<artifactId>\nguicey-jdbi\n</artifactId>\n\n  \n<version>\n0.4.0\n</version>\n\n\n</dependency>\n\n\n\n\n\nGradle:\n\n\ncompile\n \n'ru.vyarus.guicey:guicey-jdbi:0.4.0'\n\n\n\n\n\nSee the most recent version in the badge above.\n\n\nUsage\n\u00b6\n\n\nRegister bundle:\n\n\nGuiceBundle\n.\nbuilder\n()\n        \n        \n.\nbundles\n(\nJdbiBundle\n.<\nConfType\n>\nforDatabase\n((\nconf\n,\n \nenv\n)\n \n->\n \nconf\n.\ngetDatabase\n()))\n\n        \n...\n\n\n\n\n\nHere default DBI instance will be created from database configuration (much like it's described in \n\ndropwizard documentation\n).\n\n\nOr build DBI instance yourself:\n\n\nJdbiBundle\n.\nforDbi\n((\nconf\n,\n \nenv\n)\n \n->\n \nlocateDbi\n())\n\n\n\n\n\nUnit of work\n\u00b6\n\n\nUnit of work concept states for: every database related operation must be performed inside unit of work.\n\n\nIn DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of\nsql object proxies: if you create it on-demand it would always create new handle; if you want to combine\nmultiple objects in one transaction, you have to always create them manually for each transaction.\n\n\nIntegration removes these restrictions: dao (repository) objects are normal guice beans and transaction\nscope is controlled by \n@InTransaction\n annotation (note that such name was intentional to avoid confusion with\nDBI own's Transaction annotation and more common Transactional annotations).\n\n\nAt the beginning of unit of work, DBI handle is created and bound to thread (thread local).\nAll repositories are simply using this bound handle and so share transaction inside unit of work.\n\n\n@InTransaction\n\u00b6\n\n\nAnnotation on method or class declares transactional scope. For example:\n\n\n@Inject\n \nMyDAO\n \ndao\n\n\n\n@InTransaction\n\n\npublic\n \nResult\n \ndoSomething\n()\n \n{\n\n   \ndao\n.\nselect\n();\n\n   \n...\n\n\n}\n\n\n\n\n\nTransaction opened before doSomething() method and closed after it. \nDao call is also performed inside transaction.\nIf exception appears during execution, it's propagated and transaction rolled back.\n\n\nNested annotations are allowed (they simply ignored).\n\n\nNote that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). \nBut, for simplicity, you may think of it as the same things, if you always use \n@InTransaction\n annotation. \n\n\nIf required, you may use your own annotation for transaction definition:\n\n\nJdbiBundle\n.\nforDatabase\n((\nconf\n,\n \nenv\n)\n \n->\n \nconf\n.\ngetDatabase\n())\n\n    \n.\nwithTxAnnotations\n(\nMyCustomTransactional\n.\nclass\n);\n\n\n\n\n\nNote that this will override default annotation support. If you want to support multiple annotations then specify\nall of them:\n\n\nJdbiBundle\n.\nforDatabase\n((\nconf\n,\n \nenv\n)\n \n->\n \nconf\n.\ngetDatabase\n())\n\n    \n.\nwithTxAnnotations\n(\nInTransaction\n.\nclass\n,\n \nMyCustomTransactional\n.\nclass\n);\n\n\n\n\n\nContext Handle\n\u00b6\n\n\nInside unit of work you may reference current handle by using:\n\n\n@Inject\n \nProvider\n<\nHandle\n>\n\n\n\n\n\nManual transaction definition\n\u00b6\n\n\nYou may define transaction (with unit of work) without annotation using:\n\n\n@Inject\n \nTransactionTenpate\n \ntemplate\n;\n\n\n...\n\n\ntemplate\n.\ninTrabsansaction\n((\nhandle\n)\n \n->\n \ndoSomething\n())\n\n\n\n\n\nNote that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as \nwith annotation.\n\n\nRepository\n\u00b6\n\n\nDeclare repository (interface or abstract class) as usual, using DBI annotations. \nIt only must be annotated with \n@JdbiRepository\n so installer\ncould recognize it and register in guice context.\n\n\n\n\nSingleton scope will be forced for repositories.\n\n\n\n\n@JdbiRepository\n\n\n@InTransaction\n\n\npublic\n \ninterface\n \nMyRepository\n \n{\n     \n\n    \n@SqlQuery\n(\n\"select name from something where id = :id\"\n)\n\n    \nString\n \nfindNameById\n(\n@Bind\n(\n\"id\"\n)\n \nint\n \nid\n);\n\n\n}\n\n\n\n\n\nNote the use of \n@InTransaction\n: it was used to be able to call repository methods without extra annotations\n(the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand\nsql object proxies.\n\n\n@InTransaction\n annotation is handled using guice aop. You can use any other guice aop related features.\n\n\nYou can also use injection inside repositories, but only field injection:\n\n\npublic\n \nabstract\n \nclass\n \nMyRepo\n \n{\n\n    \n@Inject\n \nSomeBean\n \nbean\n;\n\n\n}\n\n\n\n\n\nConstructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able\nto construct proxy for class with constructor injection.\n\n\nDon't use DBI @Transaction and @CreateSqlObject annotations anymore\n: probably they will even work, but they are not\nneeded now and may confuse.\n\n\nAll installed repositories are reported into console:\n\n\nINFO  [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = \n\n    (ru.vyarus.guicey.jdbi.support.repository.SampleRepository)\n\n\n\n\nResult set mapper\n\u00b6\n\n\nIf you have custom implementations of \nResultSetMapper\n, it may be registered automatically. \nYou will be able to use injections there because mappers become ususal guice beans (singletons).\nWhen classpath scan is enabled, such classes will be searched and installed automatically.\n\n\npublic\n \nclass\n \nCustomMapper\n \nimplements\n \nResutlSetMapper\n<\nCustom\n>\n \n{\n\n    \n@Override\n\n    \npublic\n \nCusom\n \nmap\n(\nint\n \nrow\n,\n \nResultSet\n \nrs\n,\n \nStatementContext\n \nctx\n)\n \n{\n\n        \n// mapping here\n\n        \nreturn\n \ncustom\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nAnd now Custom type could be used for queries:\n\n\n@JdbiRepository\n\n\n@InTransaction\n\n\npublic\n \ninterface\n \nCustomRepository\n \n{\n     \n\n    \n@SqlQuery\n(\n\"select * from custom where id = :id\"\n)\n\n    \nCustom\n \nfindNameById\n(\n@Bind\n(\n\"id\"\n)\n \nint\n \nid\n);\n\n\n}\n\n\n\n\n\nAll installed mappers are reported to console:\n\n\nINFO  [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = \n\n    Sample               (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper)\n\n\n\n\nManual unit of work definition\n\u00b6\n\n\nIf, for some reason, you don't need transaction at some place, you can declare raw unit of work and use \nassigned handle directly:\n\n\n@Inject\n \nUnitManager\n \nmanager\n;\n\n\n\nmanager\n.\nbeginUnit\n();\n\n\ntry\n \n{\n\n    \nHandle\n \nhandle\n \n=\n \nmanager\n.\nget\n();\n\n    \n// logic executed in unit of work but without transaction\n\n\n}\n \nfinally\n \n{\n\n    \nmanager\n.\nendUnit\n();\n\n\n}\n\n\n\n\n\nRepositories could also be called inside such manual unit (as unit of work is correctly started).",
            "title": "JDBI"
        },
        {
            "location": "/extras/jdbi/#jdbi-integration",
            "text": "Extensions project  module   Integrates  JDBI  with guice. Based on  dropwizard-jdbi  integration.  Features:   DBI instance available for injection  Introduce unit of work concept, which is managed by annotations and guice aop (very like spring's @Transactional)  Repositories (JDBI proxies for interfaces and abstract classes):  installed automatically (when classpath scan enabled)  are normal guice beans, supporting aop and participating in global (thread bound) transaction.  no need to compose repositories anymore (e.g. with @CreateSqlObject) to gain single transaction.    Automatic installation for custom  ResultSetMapper     Added installers:   RepositoryInstaller  - sql proxies  MapperInstaller  - result set mappers",
            "title": "JDBI integration"
        },
        {
            "location": "/extras/jdbi/#setup",
            "text": "Avoid version in dependency declaration below if you use  extensions BOM .   Maven:  <dependency> \n   <groupId> ru.vyarus.guicey </groupId> \n   <artifactId> guicey-jdbi </artifactId> \n   <version> 0.4.0 </version>  </dependency>   Gradle:  compile   'ru.vyarus.guicey:guicey-jdbi:0.4.0'   See the most recent version in the badge above.",
            "title": "Setup"
        },
        {
            "location": "/extras/jdbi/#usage",
            "text": "Register bundle:  GuiceBundle . builder ()         \n         . bundles ( JdbiBundle .< ConfType > forDatabase (( conf ,   env )   ->   conf . getDatabase ())) \n         ...   Here default DBI instance will be created from database configuration (much like it's described in  dropwizard documentation ).  Or build DBI instance yourself:  JdbiBundle . forDbi (( conf ,   env )   ->   locateDbi ())",
            "title": "Usage"
        },
        {
            "location": "/extras/jdbi/#unit-of-work",
            "text": "Unit of work concept states for: every database related operation must be performed inside unit of work.  In DBI such approach was implicit: you were always tied to initial handle. This lead to cumbersome usage of\nsql object proxies: if you create it on-demand it would always create new handle; if you want to combine\nmultiple objects in one transaction, you have to always create them manually for each transaction.  Integration removes these restrictions: dao (repository) objects are normal guice beans and transaction\nscope is controlled by  @InTransaction  annotation (note that such name was intentional to avoid confusion with\nDBI own's Transaction annotation and more common Transactional annotations).  At the beginning of unit of work, DBI handle is created and bound to thread (thread local).\nAll repositories are simply using this bound handle and so share transaction inside unit of work.",
            "title": "Unit of work"
        },
        {
            "location": "/extras/jdbi/#intransaction",
            "text": "Annotation on method or class declares transactional scope. For example:  @Inject   MyDAO   dao  @InTransaction  public   Result   doSomething ()   { \n    dao . select (); \n    ...  }   Transaction opened before doSomething() method and closed after it. \nDao call is also performed inside transaction.\nIf exception appears during execution, it's propagated and transaction rolled back.  Nested annotations are allowed (they simply ignored).  Note that unit of work is not the same as transaction scope (transaction scope could be less or equal to unit of work). \nBut, for simplicity, you may think of it as the same things, if you always use  @InTransaction  annotation.   If required, you may use your own annotation for transaction definition:  JdbiBundle . forDatabase (( conf ,   env )   ->   conf . getDatabase ()) \n     . withTxAnnotations ( MyCustomTransactional . class );   Note that this will override default annotation support. If you want to support multiple annotations then specify\nall of them:  JdbiBundle . forDatabase (( conf ,   env )   ->   conf . getDatabase ()) \n     . withTxAnnotations ( InTransaction . class ,   MyCustomTransactional . class );",
            "title": "@InTransaction"
        },
        {
            "location": "/extras/jdbi/#context-handle",
            "text": "Inside unit of work you may reference current handle by using:  @Inject   Provider < Handle >",
            "title": "Context Handle"
        },
        {
            "location": "/extras/jdbi/#manual-transaction-definition",
            "text": "You may define transaction (with unit of work) without annotation using:  @Inject   TransactionTenpate   template ;  ...  template . inTrabsansaction (( handle )   ->   doSomething ())   Note that inside such manual scope you may also call any repository bean, as it's absolutely the same definition as \nwith annotation.",
            "title": "Manual transaction definition"
        },
        {
            "location": "/extras/jdbi/#repository",
            "text": "Declare repository (interface or abstract class) as usual, using DBI annotations. \nIt only must be annotated with  @JdbiRepository  so installer\ncould recognize it and register in guice context.   Singleton scope will be forced for repositories.   @JdbiRepository  @InTransaction  public   interface   MyRepository   {      \n\n     @SqlQuery ( \"select name from something where id = :id\" ) \n     String   findNameById ( @Bind ( \"id\" )   int   id );  }   Note the use of  @InTransaction : it was used to be able to call repository methods without extra annotations\n(the lowest transaction scope it's repository itself). It will make beans \"feel the same\" as usual DBI on demand\nsql object proxies.  @InTransaction  annotation is handled using guice aop. You can use any other guice aop related features.  You can also use injection inside repositories, but only field injection:  public   abstract   class   MyRepo   { \n     @Inject   SomeBean   bean ;  }   Constructor injection is impossible, because DBI sql proxies are still used internally and DBI will not be able\nto construct proxy for class with constructor injection.  Don't use DBI @Transaction and @CreateSqlObject annotations anymore : probably they will even work, but they are not\nneeded now and may confuse.  All installed repositories are reported into console:  INFO  [2016-12-05 19:42:27,374] ru.vyarus.guicey.jdbi.installer.repository.RepositoryInstaller: repositories = \n\n    (ru.vyarus.guicey.jdbi.support.repository.SampleRepository)",
            "title": "Repository"
        },
        {
            "location": "/extras/jdbi/#result-set-mapper",
            "text": "If you have custom implementations of  ResultSetMapper , it may be registered automatically. \nYou will be able to use injections there because mappers become ususal guice beans (singletons).\nWhen classpath scan is enabled, such classes will be searched and installed automatically.  public   class   CustomMapper   implements   ResutlSetMapper < Custom >   { \n     @Override \n     public   Cusom   map ( int   row ,   ResultSet   rs ,   StatementContext   ctx )   { \n         // mapping here \n         return   custom ; \n     }  }   And now Custom type could be used for queries:  @JdbiRepository  @InTransaction  public   interface   CustomRepository   {      \n\n     @SqlQuery ( \"select * from custom where id = :id\" ) \n     Custom   findNameById ( @Bind ( \"id\" )   int   id );  }   All installed mappers are reported to console:  INFO  [2016-12-05 20:02:25,399] ru.vyarus.guicey.jdbi.installer.MapperInstaller: jdbi mappers = \n\n    Sample               (ru.vyarus.guicey.jdbi.support.mapper.SampleMapper)",
            "title": "Result set mapper"
        },
        {
            "location": "/extras/jdbi/#manual-unit-of-work-definition",
            "text": "If, for some reason, you don't need transaction at some place, you can declare raw unit of work and use \nassigned handle directly:  @Inject   UnitManager   manager ;  manager . beginUnit ();  try   { \n     Handle   handle   =   manager . get (); \n     // logic executed in unit of work but without transaction  }   finally   { \n     manager . endUnit ();  }   Repositories could also be called inside such manual unit (as unit of work is correctly started).",
            "title": "Manual unit of work definition"
        },
        {
            "location": "/extras/spa/",
            "text": "Single page applications support\n\u00b6\n\n\n\n\nExtensions project\n module\n\n\n\n\nProvides a replacement for \ndropwizard-assets\n \nbundle for single page applications (SPA) to properly\nhandle html5 client routing.\n\n\nFeatures:\n\n\n\n\nPure dropwizard bundle, but can be used with guicey bundles \n\n\nBuild above dropwizard-assets servlet\n\n\nSupport registration on main and admin contexts\n\n\nMultiple apps could be registered\n\n\nSets no-cache headers for index page\n\n\nRegex could be used to tune routes detection\n\n\n\n\nProblem\n\u00b6\n\n\nThe problem with SPA is html5 routing. For example, suppose your app base url is \n/app\n\nand client route url is \n/app/someroute\n (before there were no problem because route would\nlook like \n/app/#!/someroute\n). When user hit refresh (or bookmark) such route, server is actually\ncalled with route url. Server must recognize it and return index page.\n\n\nFor example, Angular 2 router use html5 mode my default.\n\n\nSolution\n\u00b6\n\n\nThe problem consists of two points:\n\n\n\n\nCorrectly process resource calls (css, js, images, etc) and return 404 for missed resources\n\n\nRecognize application routes and return index page instead\n\n\n\n\nBundles register dropwizard-assets servlet with special filter above it. Filter tries to process\nall incoming urls. This approach grants that all calls to resources will be processed and \nindex page will not be returned instead of resource (solves problem 1).\n\n\nIf resource is not found - index page returned. To avoid redirection in case of bad resources request,\nfilter will redirect only requests accepting 'text/html'. Additional regexp (configurable) \nis used to recognize most resource calls and avoid redirection (show correct 404).\n\n\nFrom example above, \n/app/someroute\n will return index page and \n/app/css/some.css\n will return css.\n\n/app/css/unknown.css\n will return 404 as resource call will be recognized and css file is not exists.\n\n\nSetup\n\u00b6\n\n\n\n\n\n\nAvoid version in dependency declaration below if you use \nextensions BOM\n. \n\n\nMaven:\n\n\n<dependency>\n\n  \n<groupId>\nru.vyarus.guicey\n</groupId>\n\n  \n<artifactId>\nguicey-spa\n</artifactId>\n\n  \n<version>\n0.4.0\n</version>\n\n\n</dependency>\n\n\n\n\n\nGradle:\n\n\ncompile\n \n'ru.vyarus.guicey:guicey-spa:0.4.0'\n\n\n\n\n\nSee the most recent version in the badge above.\n\n\nUsage\n\u00b6\n\n\nRegister dropwizard bundle:\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\napp\n(\n\"app\"\n,\n \n\"/app\"\n,\n \n\"/\"\n).\nbuild\n());\n\n\n\n\n\nThis will register app with name \"app\" (name is used to name servlets and filters and must be unique).\nApplication files are located in \"app\" package in classpath (e.g. resources inside jar).\nApplication is mapped to root context (note that this will work only if rest is mapped \nto some sub context: e.g. with \nserver.rootPath: '/rest/*'\n configuration).\n\n\nhttp://localhost:8080/ -> app index\nhttp://loclahost:8080/css/app.css -> application resource, located at /app/css/app.css in classpath\nhttp://localhost:8080/someroute -> application client route - index page returned\n\n\n\n\nExample registration to admin context:\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\nadminApp\n(\n\"admin\"\n,\n \n\"/com/mycompany/adminapp/\"\n,\n \n\"/manager\"\n).\nbuild\n());\n\n\n\n\n\nRegister \"admin\" application with resources in \"/com/mycompany/adminapp/\" package, served from \"manager' \nadmin context (note that admin root is already used by dropwizard admin servlet).\n\n\nhttp://localhost:8081/manager -> admin app index\n\n\n\n\nYou can register as many apps as you like. They just must use different urls and have different names:\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\napp\n(\n\"app\"\n,\n \n\"/app\"\n,\n \n\"/\"\n).\nbuild\n());\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\napp\n(\n\"app2\"\n,\n \n\"/app2\"\n,\n \n\"/\"\n).\nbuild\n());\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\nadminApp\n(\n\"admin\"\n,\n \n\"/com/mycompany/adminapp/\"\n,\n \n\"/manager\"\n).\nbuild\n());\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\nadminApp\n(\n\"admin2\"\n,\n \n\"/com/mycompany/adminapp2/\"\n,\n \n\"/manager2\"\n).\nbuild\n());\n\n\n\n\n\n\n\nNote\n\n\nIf you publish SPA application not in the root path, don't forget to set appropriate \n<base href=\"/path/\"/>\n tag.\nAll modern client side routers rely on it. Pay attention that path in base tag must end with \n/\n.\n\n\n\n\nIndex page\n\u00b6\n\n\nBy default, index page assumed to be \"index.html\". Could be changed with:\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\napp\n(\n\"app\"\n,\n \n\"/app\"\n,\n \n\"/\"\n).\nindexPage\n(\n\"main.html\"\n).\nbuild\n());\n\n\n\n\n\nPrevent redirect regex\n\u00b6\n\n\nBy default, the following regex is used to prevent resources redirection (to not send index for missed resource):\n\n\n\\.(html|css|js|png|jpg|jpeg|gif|ico|xml|rss|txt|eot|svg|ttf|woff|woff2|cur)(\\?((r|v|rel|rev)=[\\-\\.\\w]*)?)?$\n\n\n\n\nCould be changed with:\n\n\nbootstrap\n.\naddBundle\n(\nSpaBundle\n.\napp\n(\n\"app\"\n,\n \n\"/app\"\n,\n \n\"/\"\n)\n\n        \n.\npreventRedirectRegex\n(\n\"\\\\.\\\\w{2,5}(\\\\?.*)?$\"\n)\n\n        \n.\nbuild\n());\n\n\n\n\n\nThis regexp implements naive assumption that all app routes does not contain \"extension\".\n\n\nNote: regexp is applied with \nfind\n so use \n^\n or \n$\n to apply boundaries. \n\n\nUse with guicey bundle\n\u00b6\n\n\nBundle could be used inside guicey bundle:\n\n\npublic\n \nclass\n \nAppBundle\n \nimplements\n \nGuiceyBundle\n \n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \ninitialize\n(\nGuiceyBootstrap\n \nbootstrap\n)\n \n{\n\n        \nSpaBundle\n.\napp\n(\n\"app\"\n,\n \n\"/app\"\n,\n \n\"/\"\n).\nregister\n(\nbootstrap\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nThis allows you to register application from guicey bundles.\nTogether with bundles lookup guicey feature it could be used to auto installation of client apps\n(e.g. admin app) when jar appear in classpath.",
            "title": "SPA"
        },
        {
            "location": "/extras/spa/#single-page-applications-support",
            "text": "Extensions project  module   Provides a replacement for  dropwizard-assets  \nbundle for single page applications (SPA) to properly\nhandle html5 client routing.  Features:   Pure dropwizard bundle, but can be used with guicey bundles   Build above dropwizard-assets servlet  Support registration on main and admin contexts  Multiple apps could be registered  Sets no-cache headers for index page  Regex could be used to tune routes detection",
            "title": "Single page applications support"
        },
        {
            "location": "/extras/spa/#problem",
            "text": "The problem with SPA is html5 routing. For example, suppose your app base url is  /app \nand client route url is  /app/someroute  (before there were no problem because route would\nlook like  /app/#!/someroute ). When user hit refresh (or bookmark) such route, server is actually\ncalled with route url. Server must recognize it and return index page.  For example, Angular 2 router use html5 mode my default.",
            "title": "Problem"
        },
        {
            "location": "/extras/spa/#solution",
            "text": "The problem consists of two points:   Correctly process resource calls (css, js, images, etc) and return 404 for missed resources  Recognize application routes and return index page instead   Bundles register dropwizard-assets servlet with special filter above it. Filter tries to process\nall incoming urls. This approach grants that all calls to resources will be processed and \nindex page will not be returned instead of resource (solves problem 1).  If resource is not found - index page returned. To avoid redirection in case of bad resources request,\nfilter will redirect only requests accepting 'text/html'. Additional regexp (configurable) \nis used to recognize most resource calls and avoid redirection (show correct 404).  From example above,  /app/someroute  will return index page and  /app/css/some.css  will return css. /app/css/unknown.css  will return 404 as resource call will be recognized and css file is not exists.",
            "title": "Solution"
        },
        {
            "location": "/extras/spa/#setup",
            "text": "Avoid version in dependency declaration below if you use  extensions BOM .   Maven:  <dependency> \n   <groupId> ru.vyarus.guicey </groupId> \n   <artifactId> guicey-spa </artifactId> \n   <version> 0.4.0 </version>  </dependency>   Gradle:  compile   'ru.vyarus.guicey:guicey-spa:0.4.0'   See the most recent version in the badge above.",
            "title": "Setup"
        },
        {
            "location": "/extras/spa/#usage",
            "text": "Register dropwizard bundle:  bootstrap . addBundle ( SpaBundle . app ( \"app\" ,   \"/app\" ,   \"/\" ). build ());   This will register app with name \"app\" (name is used to name servlets and filters and must be unique).\nApplication files are located in \"app\" package in classpath (e.g. resources inside jar).\nApplication is mapped to root context (note that this will work only if rest is mapped \nto some sub context: e.g. with  server.rootPath: '/rest/*'  configuration).  http://localhost:8080/ -> app index\nhttp://loclahost:8080/css/app.css -> application resource, located at /app/css/app.css in classpath\nhttp://localhost:8080/someroute -> application client route - index page returned  Example registration to admin context:  bootstrap . addBundle ( SpaBundle . adminApp ( \"admin\" ,   \"/com/mycompany/adminapp/\" ,   \"/manager\" ). build ());   Register \"admin\" application with resources in \"/com/mycompany/adminapp/\" package, served from \"manager' \nadmin context (note that admin root is already used by dropwizard admin servlet).  http://localhost:8081/manager -> admin app index  You can register as many apps as you like. They just must use different urls and have different names:  bootstrap . addBundle ( SpaBundle . app ( \"app\" ,   \"/app\" ,   \"/\" ). build ());  bootstrap . addBundle ( SpaBundle . app ( \"app2\" ,   \"/app2\" ,   \"/\" ). build ());  bootstrap . addBundle ( SpaBundle . adminApp ( \"admin\" ,   \"/com/mycompany/adminapp/\" ,   \"/manager\" ). build ());  bootstrap . addBundle ( SpaBundle . adminApp ( \"admin2\" ,   \"/com/mycompany/adminapp2/\" ,   \"/manager2\" ). build ());    Note  If you publish SPA application not in the root path, don't forget to set appropriate  <base href=\"/path/\"/>  tag.\nAll modern client side routers rely on it. Pay attention that path in base tag must end with  / .",
            "title": "Usage"
        },
        {
            "location": "/extras/spa/#index-page",
            "text": "By default, index page assumed to be \"index.html\". Could be changed with:  bootstrap . addBundle ( SpaBundle . app ( \"app\" ,   \"/app\" ,   \"/\" ). indexPage ( \"main.html\" ). build ());",
            "title": "Index page"
        },
        {
            "location": "/extras/spa/#prevent-redirect-regex",
            "text": "By default, the following regex is used to prevent resources redirection (to not send index for missed resource):  \\.(html|css|js|png|jpg|jpeg|gif|ico|xml|rss|txt|eot|svg|ttf|woff|woff2|cur)(\\?((r|v|rel|rev)=[\\-\\.\\w]*)?)?$  Could be changed with:  bootstrap . addBundle ( SpaBundle . app ( \"app\" ,   \"/app\" ,   \"/\" ) \n         . preventRedirectRegex ( \"\\\\.\\\\w{2,5}(\\\\?.*)?$\" ) \n         . build ());   This regexp implements naive assumption that all app routes does not contain \"extension\".  Note: regexp is applied with  find  so use  ^  or  $  to apply boundaries.",
            "title": "Prevent redirect regex"
        },
        {
            "location": "/extras/spa/#use-with-guicey-bundle",
            "text": "Bundle could be used inside guicey bundle:  public   class   AppBundle   implements   GuiceyBundle   { \n     @Override \n     public   void   initialize ( GuiceyBootstrap   bootstrap )   { \n         SpaBundle . app ( \"app\" ,   \"/app\" ,   \"/\" ). register ( bootstrap ); \n     }  }   This allows you to register application from guicey bundles.\nTogether with bundles lookup guicey feature it could be used to auto installation of client apps\n(e.g. admin app) when jar appear in classpath.",
            "title": "Use with guicey bundle"
        },
        {
            "location": "/about/compatibility/",
            "text": "Dropwizard compatibility\n\u00b6\n\n\n\n\n\n\n\n\nDropwizard\n\n\nGuicey\n\n\n\n\n\n\n\n\n\n\n1.3.0\n\n\n4.2.0\n\n\n\n\n\n\n1.2.0\n\n\n4.1.0\n\n\n\n\n\n\n1.1.0\n\n\n4.1.0\n\n\n\n\n\n\n1.0\n\n\n4.0.1\n\n\n\n\n\n\n0.9\n\n\n3.3.0\n\n\n\n\n\n\n0.8\n\n\n3.1.0\n\n\n\n\n\n\n0.7\n\n\n1.1.0",
            "title": "Compatibility"
        },
        {
            "location": "/about/compatibility/#dropwizard-compatibility",
            "text": "Dropwizard  Guicey      1.3.0  4.2.0    1.2.0  4.1.0    1.1.0  4.1.0    1.0  4.0.1    0.9  3.3.0    0.8  3.1.0    0.7  1.1.0",
            "title": "Dropwizard compatibility"
        },
        {
            "location": "/about/history/",
            "text": "4.2.0\n (2018-06-25)\n\u00b6\n\n\n\n\nUpdate to guice 4.2.0\n\n\nremove guice-multibindings dependency as it's moved to guice core\n\n\n\n\n\n\nUpdate to dropwizard 1.3.5    \n\n\nAdd more disable items (mostly for tests): guicey bundles, guice modules (directly registered) and extensions:\n\n\nGuicey bundles disabled through main builder only: .disableBundles() \n\n\nOther disable methods available in both main bundle and guicey bundles bootstrap:\n\n\n.disableModules(Class...) - disable guice modules\n\n\n.disableExtensions(Class...) - extensions disabling (for possible replacement) \n\n\ngeneric disable method by predicate: .disable(Predicate) (for example, disable all extensions in package or all installed by some bundle etc.)\n\n\n\n\n\n\n\n\n\n\nAdd direct support for guice bindings override (using Modules.override() internally) to main bundle and guicey bundle bootstrap: \n    .modulesOverride(Module...)\n\n\nAdd BindingsOverrideInjectorFactory to override already overridden bindings (with modulesOverride) in test (edge case)     \n\n\n\n\n\n\nAdd hooks for configuration override in integration tests (#23):\n\n\nNew GuiceyConfigurationHook interface: hook receive bundle builder instance after application configuration and so could modify configuration (with new disable* methods)\n\n\nJunit:\n\n\nNew rule GuiceyConfigurationRule for hook registration \n\n\n\n\n\n\nSpock:\n\n\nNew @UseGuiceyConfiguration extension allows base hook definition (in base class)\n\n\nNew attribute hooks in @UseGuiceyApp and @UseDropwizardApp extensions to declare test-specific hooks                      \n\n\n\n\n\n\n\n\n\n\nAdd guicey lifecycle events (16 events): provide access to all possible internal state, available at this moment. \n    It may be used to write instance specific features (post processing) or just advanced logging\n\n\nAdd new method in main bundle or guicey bundle bootstrap: .listen(GuiceyLifecycleListener...)      \n\n\nAdd guicey lifecycle phases reporting methods in main bundle (useful for debugging startup logic):\n\n\n.printLifecyclePhases() - identify configuration stages in console logs \n\n\n.printLifecyclePhasesDetailed() -  identify lifecycle phases with detailed configuration report (in console logs) \n\n\n\n\n\n\n\n\n\n\nImprove options support:\n\n\nAdd OptionsAwareModule interface to let guice modules access options\n\n\nAdd OptionsMapper helper to simplify mapping of system properties and environment variables in builder.options() \n\n\n\n\n\n\nAdd ability to manage jersey extensions with HK2 by default (#41). \n    It's like using @HK2Managed on all jersey-related beans (resources, filters etc). \n    This is useful, for example, if you get common to jersey resources features like @Context injection.   \n\n\nAdd option InstallersOptions.JerseyExtensionsManagedByGuice set to false enable HK2 management by default.\n    HK2 bridge must be enabled (GuiceyOptions.UseHkBridge) for HK2-first mode (exception thrown if not).\n\n\nAdd @GuiceManaged annotation to mark exceptions in HK2-first mode (when @HK2Managed become useless).\n   In guice-first mode this annotation is useless.    \n\n\nBuilder shortcut: .useHK2ForJerseyExtensions() to simplify HK2-first mode enabling.\n\n\n\n\n\n\nGuice beans scope-related improvements:\n\n\nSingleton scope is not forced for jersey extensions with explicit scoping annotation \n\n\nAdd option for disabling forced singletons for jersey extensions: InstallerOptions.ForceSingletonForJerseyExtensions\n\n\nAdd annotation for guice prototype scope: @Prototype. Useful to declare some jersey extensions as default-scoped even when forced singletons enabled\n\n\nFix guice request scope delegation support (ServletScopes.transferRequest) for jersey-manager request objects (#49)\n\n\n\n\n\n\nAdd Bootstrap object accessible in GuiceyBundle: bootstrap() (return dropwizard bootstrap object)\n\n\nAdd ConfigScope enum for special scopes description (to not remember special classes).\n\n\nAdd shortcut methods in config related apis (Filters, Disables, GuiceyConfigurationInfo)        \n\n\n\n\n\n\n(breaking) Config reporting api changes:\n\n\nDiagnostic report configuration method rename: DiagnosticConfig.printDisabledInstallers renamed to printDisabledItems and affects now all disabled items\n\n\nDiagnostic tree report could hide application scope in ContextTreeConfig.hideScopes(ConfigItems.Application)\n\n\n\n\n\n\nNew configuration bindings:\n\n\nConfiguration object could be bound as:\n\n\nany class from configuration class hierarchy (as before)\n\n\nany class from hierarchy with @Config qualifier: @Inject @Config Configuration conf\n\n\ninterface, implemented by any class in hierarchy with qualifier: @Inject @Config ConfInterface config\n\n\n(Deprecated) GuiceyOptions.BindConfigurationInterfaces: when enabled it would bind configuration with interface (as before),\n    but prefer binding interfaces with qualifier (@Config), which is always available.\n    Option will be removed in the future versions\n\n\n(Deprecated) bundle's builder.bindConfigurationInterfaces()                 \n\n\n\n\n\n\nConfiguration value (property value) could be bound by path: @Inject @Config(\"server.serverPush.enabled\") Boolean enabledPush\n    Or entire sub configuration object: @Inject @Config(\"server\") ServerFactory serverCfg\n\n\nSub configuration objects could be bound without path if object type appear only once in configuration:\n    @Inject @Config ServerFactory serverCfg\n\n\nConfigurationTree - configuration introspection object is available for direct binding\n\n\nand from GuiceyConfigurationInfo bean: getConfigurationTree()\n\n\n\n\n\n\nAlternative configuration access:\n\n\nNew configuration access methods available inside GuiceyBundle and module (DropwizardAwareModule):\n\n\nconfiguration(String) - configuration value by path\n\n\nconfiguration(Class) - unique sub configuration object\n\n\nconfigurations(Class) - all sub configuration objects with assignable type (on any depth)\n\n\nconfigurationTree() - access raw introspection data for more complex searches                \n\n\n\n\n\n\n\n\n\n\nReports to see available config bindings (before injector creation for potential problems solving) in main bundle:\n\n\n.printConfigurationBindings() - log all bindings (including dropwizard Configuration) \n\n\n.printCustomConfigurationBindings() - log only custom bindings (from custom configuration classes)                  \n\n\n\n\n\n\n\n\n\n\nIncludes much improved \ngenerics-resolver\n\n\n\n\n4.1.0\n (2017-05-09)\n\u00b6\n\n\n\n\nUpdate to dropwizard 1.1.0\n\n\nAdd StartupErrorRule to simplify dropwizard startup error testing\n\n\n(breaking) HK2 guice-bridge dependency become optional. New option GuiceyOptions.UseHkBridge could be used \nto enable bridge (#28)  \n\n\nFix NPE when used with JRebel (#29)\n\n\nAdd binding for jersey javax.ws.rs.container.ResourceInfo (#26)\n\n\nFix loggers for GuiceyAppRule (junit) and @UseGuiceyApp (spock) (#32)\n\n\nFix guava conflict in guicey pom. Make guicey pom usable as BOM.\n\n\n\n\n4.0.1\n (2016-11-18)\n\u00b6\n\n\n\n\nUpdate to dropwizard 1.0.5 and fix compatibility (#24)\n\n\nFix guice version conflict for maven (#20)\n\n\n\n\n4.0.0\n (2016-08-22)\n\u00b6\n\n\n\n\nUpdate to dropwizard 1.0.0\n\n\n(breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle)\n\n\nAdd WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts:\n\n\nWebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter\n\n\nWebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet\n\n\nWebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener    \n\n\n\n\n\n\nAdd general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3\nrd\n party bundles use it's own low-level options.\n\n\nGuiceyBootstrap option(option) method provides access to defined options from bundles\n\n\nOptions guice bean provide access to options from guice services\n\n\nInstallers could access options by implementing WithOptions interface\n\n\nOptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions())\n\n\nOptions reporting added to DiagnosticBundle\n\n\n\n\n\n\n(breaking) remove GuiceBunldle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) \n    (use either shortcuts without parameters or generic options method instead)\n\n\n(breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option \n\n\n(breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava\n\n\n(breaking) InjectorLookup changed to use java8 Optional instead of guava    \n\n\nAdd ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option \n\n\nAdd ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources) \n\n\nJersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK2)\n\n\nAdd methods to GuiceBundle builder:\n\n\noption(option, value) - used to specify custom option value\n\n\noptions(Map) - used to provide multiple options at once (for custom options lookup mechanisms)\n\n\nprintAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features)\n\n\nuseWebInstallers() - shortcut for installing WebInstallersBundle\n\n\nnoGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support  \n\n\nnoDefaultInstallers() - disables CoreInstallersBundle automatic installation\n\n\n\n\n\n\n\n\n3.3.0\n (2016-08-02)\n\u00b6\n\n\n\n\nUpdate to guice 4.1.0\n\n\nUpdate to dropwizard 0.9.3\n\n\nGrant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings\n\n\nResourceInstaller looks for @Path on directly implemented interface (#10)\n\n\nFix bundles lookup reporting (correct multiline)\n\n\nFix duplicate extensions installation when registered both manually and by auto scan\n\n\nRestrict extension installation to one installer (first matching, according to installers order)\n\n\nImprove dropwizard configuration class binding:\n\n\nComplete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself)\n\n\n(optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages \n (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces()))\n\n\n\n\n\n\nAdd GuiceyBootstrap methods (extend GuiceyBundle abilities):\n\n\nbundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type.\n\n\napplication(): returns current application instance\n\n\n\n\n\n\nRewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item\n\n\nAdd GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc)\n\n\nAdd DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page). \n\n\n\n\n\n\nAdd GuiceBundle builder configuration options:\n\n\nbindConfigurationInterfaces() to enable configuration interface bindings\n\n\nstrictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests)\n\n\nprintDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs)\n\n\nshortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces()\n\n\n\n\n\n\n\n\nNOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api)    \n\n\n3.2.0\n (2016-01-23)\n\u00b6\n\n\n\n\nClear possible duplicate guicey bundle instances\n\n\nAdd GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources.\n\n\nDefault: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles.\n\n\nDefault: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions.\n\n\nAdd builder bundleLookup method to register custom lookup implementation\n\n\nAdd builder disableBundleLookup to disable default lookups\n\n\nDefault lookup implementation logs all resolved bundles\n\n\n\n\n\n\nFix JerseyProviderInstaller: prevent HK2 beans duplicate instantiations; fix DynamicFeature support.\n\n\nAdd HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed \nare managed by HK2 only. May be used in tests as extra validation.\n\n\nAdd JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration. \n\n\nUpdate to dropwizard 0.9\n\n\nRevert system exit on guice injector creation error (added in 3.1.1)\n\n\n\n\n3.1.1\n (2015-11-24)\n\u00b6\n\n\n\n\nExit on guice injector creation error.\n\n\nAdd classpath scan packages validation for intersection (to prevent duplicate instances)\n\n\n\n\n3.1.0\n (2015-09-06)\n\u00b6\n\n\n\n\nJerseyProviderInstaller: \n\n\nadd support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor,\n  ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener\n\n\nsupport multiple extension interfaces on the same bean\n\n\nIntroduce bundles (GuiceyBundle) to simplify extensions:\n\n\ncore installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed\n\n\nbuilder bundles() method to add guicey bundles\n\n\nbuilder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism)\n\n\nAdd admin context rest support (AdminRestBundle)\n\n\nAdd request scoped beans support in admin context\n\n\n\n\n3.0.1\n (2015-07-04)\n\u00b6\n\n\n\n\nAdd DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces\n\n\n\n\n3.0.0\n (2015-04-26)\n\u00b6\n\n\n\n\nFix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly) \n\n\n(breaking) Remove static state from GuiceBundle:\n\n\nGuiceBundle.getInjector method remain, but its now instance specific (instead of static)\n\n\nInjector could be referenced statically using application instance: InjectorLookup.getInjector(app).get() \n\n\nJerseyInstaller interface signature changed: now install method receives injector instance\n\n\n\n\n2.2.0\n (2015-04-17)\n\u00b6\n\n\n\n\nFix ExceptionMapper registration\n\n\nAdd installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 \n(to simplify custom installers injection between them)\n\n\n\n\n2.1.2\n (2015-03-03)\n\u00b6\n\n\n\n\nSpock 1.0 compatibility\n\n\n\n\n2.1.1\n (2015-01-25)\n\u00b6\n\n\n\n\nDropwizard 0.8-rc2 compatibility\n\n\n\n\n2.1.0\n (2015-01-04)\n\u00b6\n\n\n\n\nAdd ability to customize injector creation (required by some guice third party modules, like governator). Contributed by \nNicholas Pace\n\n\nAdd spock extensions to use injections directly in specification (like spock-guice do)\n\n\n\n\n2.0.0\n (2014-11-25)\n\u00b6\n\n\n\n\nDropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(HK2)).\nJersey integration completely rewritten.\n\n\nAdd JerseyInstaller installer type\n\n\nAdd @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request)\n\n\n\n\n1.1.0\n (2014-10-23)\n\u00b6\n\n\n\n\nFix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils\n\n\nDrop java 1.6 compatibility, because dropwizard is 1.7 compatible\n\n\nAdd junit rule for lightweight testing (run guice without starting jetty)\n\n\n\n\n1.0.0\n (2014-10-14)\n\u00b6\n\n\n\n\nAdd dependency on guice-multibindings\n\n\nInstallers may choose now from three types of installation (binding, type or instance) or combine them.\n\n\nAdd PluginInstaller: shortcut for multibindings mechanism\n\n\nUpdated guice (4.0.beta4 -> 4.0.beta5)\n\n\nForce singleton for resources\n\n\n@Eager renamed to @EagerSingleton and now forces singleton scope for bean\n\n\nAdd dropwizard style reporting for installed features (like resources or tasks)\n\n\nRemoved JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider\n\n\nAdd extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers)\n\n\nAdd admin context filter and servlet installers\n\n\nRename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions\n\n\n\n\n0.9.0\n (2014-09-05)\n\u00b6\n\n\n\n\nInitial release",
            "title": "Release notes"
        },
        {
            "location": "/about/history/#420-2018-06-25",
            "text": "Update to guice 4.2.0  remove guice-multibindings dependency as it's moved to guice core    Update to dropwizard 1.3.5      Add more disable items (mostly for tests): guicey bundles, guice modules (directly registered) and extensions:  Guicey bundles disabled through main builder only: .disableBundles()   Other disable methods available in both main bundle and guicey bundles bootstrap:  .disableModules(Class...) - disable guice modules  .disableExtensions(Class...) - extensions disabling (for possible replacement)   generic disable method by predicate: .disable(Predicate) (for example, disable all extensions in package or all installed by some bundle etc.)      Add direct support for guice bindings override (using Modules.override() internally) to main bundle and guicey bundle bootstrap: \n    .modulesOverride(Module...)  Add BindingsOverrideInjectorFactory to override already overridden bindings (with modulesOverride) in test (edge case)         Add hooks for configuration override in integration tests (#23):  New GuiceyConfigurationHook interface: hook receive bundle builder instance after application configuration and so could modify configuration (with new disable* methods)  Junit:  New rule GuiceyConfigurationRule for hook registration     Spock:  New @UseGuiceyConfiguration extension allows base hook definition (in base class)  New attribute hooks in @UseGuiceyApp and @UseDropwizardApp extensions to declare test-specific hooks                            Add guicey lifecycle events (16 events): provide access to all possible internal state, available at this moment. \n    It may be used to write instance specific features (post processing) or just advanced logging  Add new method in main bundle or guicey bundle bootstrap: .listen(GuiceyLifecycleListener...)        Add guicey lifecycle phases reporting methods in main bundle (useful for debugging startup logic):  .printLifecyclePhases() - identify configuration stages in console logs   .printLifecyclePhasesDetailed() -  identify lifecycle phases with detailed configuration report (in console logs)       Improve options support:  Add OptionsAwareModule interface to let guice modules access options  Add OptionsMapper helper to simplify mapping of system properties and environment variables in builder.options()     Add ability to manage jersey extensions with HK2 by default (#41). \n    It's like using @HK2Managed on all jersey-related beans (resources, filters etc). \n    This is useful, for example, if you get common to jersey resources features like @Context injection.     Add option InstallersOptions.JerseyExtensionsManagedByGuice set to false enable HK2 management by default.\n    HK2 bridge must be enabled (GuiceyOptions.UseHkBridge) for HK2-first mode (exception thrown if not).  Add @GuiceManaged annotation to mark exceptions in HK2-first mode (when @HK2Managed become useless).\n   In guice-first mode this annotation is useless.      Builder shortcut: .useHK2ForJerseyExtensions() to simplify HK2-first mode enabling.    Guice beans scope-related improvements:  Singleton scope is not forced for jersey extensions with explicit scoping annotation   Add option for disabling forced singletons for jersey extensions: InstallerOptions.ForceSingletonForJerseyExtensions  Add annotation for guice prototype scope: @Prototype. Useful to declare some jersey extensions as default-scoped even when forced singletons enabled  Fix guice request scope delegation support (ServletScopes.transferRequest) for jersey-manager request objects (#49)    Add Bootstrap object accessible in GuiceyBundle: bootstrap() (return dropwizard bootstrap object)  Add ConfigScope enum for special scopes description (to not remember special classes).  Add shortcut methods in config related apis (Filters, Disables, GuiceyConfigurationInfo)            (breaking) Config reporting api changes:  Diagnostic report configuration method rename: DiagnosticConfig.printDisabledInstallers renamed to printDisabledItems and affects now all disabled items  Diagnostic tree report could hide application scope in ContextTreeConfig.hideScopes(ConfigItems.Application)    New configuration bindings:  Configuration object could be bound as:  any class from configuration class hierarchy (as before)  any class from hierarchy with @Config qualifier: @Inject @Config Configuration conf  interface, implemented by any class in hierarchy with qualifier: @Inject @Config ConfInterface config  (Deprecated) GuiceyOptions.BindConfigurationInterfaces: when enabled it would bind configuration with interface (as before),\n    but prefer binding interfaces with qualifier (@Config), which is always available.\n    Option will be removed in the future versions  (Deprecated) bundle's builder.bindConfigurationInterfaces()                     Configuration value (property value) could be bound by path: @Inject @Config(\"server.serverPush.enabled\") Boolean enabledPush\n    Or entire sub configuration object: @Inject @Config(\"server\") ServerFactory serverCfg  Sub configuration objects could be bound without path if object type appear only once in configuration:\n    @Inject @Config ServerFactory serverCfg  ConfigurationTree - configuration introspection object is available for direct binding  and from GuiceyConfigurationInfo bean: getConfigurationTree()    Alternative configuration access:  New configuration access methods available inside GuiceyBundle and module (DropwizardAwareModule):  configuration(String) - configuration value by path  configuration(Class) - unique sub configuration object  configurations(Class) - all sub configuration objects with assignable type (on any depth)  configurationTree() - access raw introspection data for more complex searches                      Reports to see available config bindings (before injector creation for potential problems solving) in main bundle:  .printConfigurationBindings() - log all bindings (including dropwizard Configuration)   .printCustomConfigurationBindings() - log only custom bindings (from custom configuration classes)                        Includes much improved  generics-resolver",
            "title": "4.2.0 (2018-06-25)"
        },
        {
            "location": "/about/history/#410-2017-05-09",
            "text": "Update to dropwizard 1.1.0  Add StartupErrorRule to simplify dropwizard startup error testing  (breaking) HK2 guice-bridge dependency become optional. New option GuiceyOptions.UseHkBridge could be used \nto enable bridge (#28)    Fix NPE when used with JRebel (#29)  Add binding for jersey javax.ws.rs.container.ResourceInfo (#26)  Fix loggers for GuiceyAppRule (junit) and @UseGuiceyApp (spock) (#32)  Fix guava conflict in guicey pom. Make guicey pom usable as BOM.",
            "title": "4.1.0 (2017-05-09)"
        },
        {
            "location": "/about/history/#401-2016-11-18",
            "text": "Update to dropwizard 1.0.5 and fix compatibility (#24)  Fix guice version conflict for maven (#20)",
            "title": "4.0.1 (2016-11-18)"
        },
        {
            "location": "/about/history/#400-2016-08-22",
            "text": "Update to dropwizard 1.0.0  (breaking) Remove AdminServletInstaller and AdminFilterInstaller (replaced with new web bundle)  Add WebInstallersBundle (not installed by default) to install servlet and filters in both main and admin contexts:  WebFilterInstaller installs filters annotated with java.servlet.annotation.WebFilter  WebServletInstaller installs servlets annotated with java.servlet.annotation.WebServlet  WebListenerInstaller installs filters annotated with java.servlet.annotation.WebListener        Add general options mechanism. Used to generify core guicey options, provide runtime options access (for bundles and reporting) and allow 3 rd  party bundles use it's own low-level options.  GuiceyBootstrap option(option) method provides access to defined options from bundles  Options guice bean provide access to options from guice services  Installers could access options by implementing WithOptions interface  OptionsInfo guice bean used for accessing options metadata (also accessible through GuiceyConfigurationInfo.getOptions())  Options reporting added to DiagnosticBundle    (breaking) remove GuiceBunldle methods: searchCommands(boolean), configureFromDropwizardBundles(boolean), bindConfigurationInterfaces(boolean) \n    (use either shortcuts without parameters or generic options method instead)  (breaking) core installers bundle now always installed (for both auto scan and manual modes). May be disabled with GuiceyOptions.UseCoreInstallers option   (breaking) configuration info api (GuiceyConfigurationInfo.getData()) changed to use java8 Predicate instead of guava  (breaking) InjectorLookup changed to use java8 Optional instead of guava      Add ability to customize guice filter mapping DispatcherTypes (by default only REQUEST): GuiceyOptions.GuiceFilterRegistration option   Add ability to disable guice filter registration and guice servlet modules support (no request and session scopes, but request and response still may be injected in resources)   Jersey request specific services UriInfo, HttpHeaders, SecurityContext, Request, ContainerRequest, AsyncContext no longer bound in request scope (scope controlled by HK2)  Add methods to GuiceBundle builder:  option(option, value) - used to specify custom option value  options(Map) - used to provide multiple options at once (for custom options lookup mechanisms)  printAvailableInstallers() - diagnostic reporting configured to show only available installers (to easily spot available features)  useWebInstallers() - shortcut for installing WebInstallersBundle  noGuiceFilter() - disables guice filter installation for both contexts and guice servlet modules support    noDefaultInstallers() - disables CoreInstallersBundle automatic installation",
            "title": "4.0.0 (2016-08-22)"
        },
        {
            "location": "/about/history/#330-2016-08-02",
            "text": "Update to guice 4.1.0  Update to dropwizard 0.9.3  Grant compatibility with guice options: disableCircularProxies, requireExactBindingAnnotations and requireExplicitBindings  ResourceInstaller looks for @Path on directly implemented interface (#10)  Fix bundles lookup reporting (correct multiline)  Fix duplicate extensions installation when registered both manually and by auto scan  Restrict extension installation to one installer (first matching, according to installers order)  Improve dropwizard configuration class binding:  Complete configuration hierarchy bound (root, all classes between root and Configuration and Configuration itself)  (optional) Bind interfaces directly implemented by classes in configuration hierarchy except interfaces from java and groovy packages \n (it's common to use HasSomeConfig interface convention and now interface may be directly used for binding (when bindConfigurationInterfaces()))    Add GuiceyBootstrap methods (extend GuiceyBundle abilities):  bundles(): add transitive guicey bundles support (to install other guicey bundles from bundle). Duplicate bundles are detected by type.  application(): returns current application instance    Rewrite internal configuration mechanism (bundles, installers etc) to generalize it and introduce complete configuration tracking: store registration sources, disabling, used installers and other specific information for each item  Add GuiceyConfigurationInfo service to access tracked guicey configuration information (may be used for configuration diagnostic purposes, performing post configuration checks, printing complete configuration tree etc)  Add DiagnosticBundle to log configuration items diagnostic information. Log format is configurable. Rendering is externalized and may be re-used (e.g. for web page).     Add GuiceBundle builder configuration options:  bindConfigurationInterfaces() to enable configuration interface bindings  strictScopeControl() is shortcut to enable HK2DebugBundle (to control beans creation scope during development and tests)  printDiagnosticInfo() is shortcut to enable DiagnosticBundle with default preset (enable diagnostic logs)  shortcut methods for disabled boolean options: searchCommands(), configureFromDropwizardBundles() and bindConfigurationInterfaces()     NOTE: if used FeaturesHolder (internal api bean), now it's renamed to ExtensionsHolder to force upgrade: use new GuiceyConfigurationInfo bean instead (public api)",
            "title": "3.3.0 (2016-08-02)"
        },
        {
            "location": "/about/history/#320-2016-01-23",
            "text": "Clear possible duplicate guicey bundle instances  Add GuiceyBundleLookup to automatically resolve and install guicey bundles from various sources.  Default: check 'guicey.bundles' system property and install bundles described there. May be useful for tests to enable debug bundles.  Default: use ServiceLoader mechanism to load declared GuiceyBundle services. Useful for automatic loading of third party extensions.  Add builder bundleLookup method to register custom lookup implementation  Add builder disableBundleLookup to disable default lookups  Default lookup implementation logs all resolved bundles    Fix JerseyProviderInstaller: prevent HK2 beans duplicate instantiations; fix DynamicFeature support.  Add HK2DebugBundle. When enabled, checks that beans are instantiated by guice only and annotated with @HK2Managed \nare managed by HK2 only. May be used in tests as extra validation.  Add JerseyFeatureInstaller (included in code bundle) which installs javax.ws.rs.core.Feature. Useful for low level configuration.   Update to dropwizard 0.9  Revert system exit on guice injector creation error (added in 3.1.1)",
            "title": "3.2.0 (2016-01-23)"
        },
        {
            "location": "/about/history/#311-2015-11-24",
            "text": "Exit on guice injector creation error.  Add classpath scan packages validation for intersection (to prevent duplicate instances)",
            "title": "3.1.1 (2015-11-24)"
        },
        {
            "location": "/about/history/#310-2015-09-06",
            "text": "JerseyProviderInstaller:   add support for: ParamConverterProvider, ContextResolver, MessageBodyReader, MessageBodyWriter, ReaderInterceptor, WriterInterceptor,\n  ContainerRequestFilter, ContainerResponseFilter, DynamicFeature, ApplicationEventListener  support multiple extension interfaces on the same bean  Introduce bundles (GuiceyBundle) to simplify extensions:  core installers now registered with CoreInstallersBundle and classpath scan on core installers package is removed  builder bundles() method to add guicey bundles  builder configureFromDropwizardBundles method enables all registered dropwizard bundles lookup if they implement GuiceyBundle (unified extension mechanism)  Add admin context rest support (AdminRestBundle)  Add request scoped beans support in admin context",
            "title": "3.1.0 (2015-09-06)"
        },
        {
            "location": "/about/history/#301-2015-07-04",
            "text": "Add DropwizardAwareModule abstract module to remove boilerplate of using all aware interfaces",
            "title": "3.0.1 (2015-07-04)"
        },
        {
            "location": "/about/history/#300-2015-04-26",
            "text": "Fix HealthCheckInstaller: now installs only NamedHealthCheck classes and ignore other HealthCheck types (which it can't install properly)   (breaking) Remove static state from GuiceBundle:  GuiceBundle.getInjector method remain, but its now instance specific (instead of static)  Injector could be referenced statically using application instance: InjectorLookup.getInjector(app).get()   JerseyInstaller interface signature changed: now install method receives injector instance",
            "title": "3.0.0 (2015-04-26)"
        },
        {
            "location": "/about/history/#220-2015-04-17",
            "text": "Fix ExceptionMapper registration  Add installers ordering support with @Order annotation. Default installers are ordered now with indexes from 10 to 100 with gap 10 \n(to simplify custom installers injection between them)",
            "title": "2.2.0 (2015-04-17)"
        },
        {
            "location": "/about/history/#212-2015-03-03",
            "text": "Spock 1.0 compatibility",
            "title": "2.1.2 (2015-03-03)"
        },
        {
            "location": "/about/history/#211-2015-01-25",
            "text": "Dropwizard 0.8-rc2 compatibility",
            "title": "2.1.1 (2015-01-25)"
        },
        {
            "location": "/about/history/#210-2015-01-04",
            "text": "Add ability to customize injector creation (required by some guice third party modules, like governator). Contributed by  Nicholas Pace  Add spock extensions to use injections directly in specification (like spock-guice do)",
            "title": "2.1.0 (2015-01-04)"
        },
        {
            "location": "/about/history/#200-2014-11-25",
            "text": "Dropwizard 0.8 integration (as result, no more depends on jersey-guice, but depends on guice-bridge(HK2)).\nJersey integration completely rewritten.  Add JerseyInstaller installer type  Add @LazyBinding annotation, which allows extension not to be registered in guice context (it will be created on first request)",
            "title": "2.0.0 (2014-11-25)"
        },
        {
            "location": "/about/history/#110-2014-10-23",
            "text": "Fix interface generics resolution to support nested generics and moved generics resolution into GenericsUtils instead of FeatureUtils  Drop java 1.6 compatibility, because dropwizard is 1.7 compatible  Add junit rule for lightweight testing (run guice without starting jetty)",
            "title": "1.1.0 (2014-10-23)"
        },
        {
            "location": "/about/history/#100-2014-10-14",
            "text": "Add dependency on guice-multibindings  Installers may choose now from three types of installation (binding, type or instance) or combine them.  Add PluginInstaller: shortcut for multibindings mechanism  Updated guice (4.0.beta4 -> 4.0.beta5)  Force singleton for resources  @Eager renamed to @EagerSingleton and now forces singleton scope for bean  Add dropwizard style reporting for installed features (like resources or tasks)  Removed JerseyInjectableProviderInstaller. Now injectable providers must be annotated with @Provider  Add extensions ordering support using @Order annotation (by default for LifeCycle and Managed installers)  Add admin context filter and servlet installers  Rename bundle options: features -> installers, disabledFeatures -> disabledInstallers, beans -> extensions",
            "title": "1.0.0 (2014-10-14)"
        },
        {
            "location": "/about/history/#090-2014-09-05",
            "text": "Initial release",
            "title": "0.9.0 (2014-09-05)"
        },
        {
            "location": "/about/support/",
            "text": "Support\n\u00b6\n\n\n\n\nGoogle group\n - mailing list\n\n\nGitter\n - chat\n\n\nGithub issues\n - problems / enhancements",
            "title": "Support"
        },
        {
            "location": "/about/support/#support",
            "text": "Google group  - mailing list  Gitter  - chat  Github issues  - problems / enhancements",
            "title": "Support"
        },
        {
            "location": "/about/license/",
            "text": "The MIT License (MIT)\n\n\nCopyright \u00a9 2014-2018, Vyacheslav Rusakov\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "License"
        }
    ]
}